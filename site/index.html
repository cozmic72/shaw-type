<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaw Type - Shavian Typing Practice</title>
    <link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
    <link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
    <link rel="icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <style>
        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Medium.otf') format('opentype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Bold.otf') format('opentype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Ormin';
            src: url('fonts/Ormin-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter-Alia', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        p {
            margin-bottom: 1em;
        }

        h3 {
            color: #333;
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-size: 1.2em;
            font-weight: 600;
        }

        details {
            margin-bottom: 0.75em;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 0.5em;
        }

        summary {
            font-weight: 600;
            color: #667eea;
            cursor: pointer;
            padding: 0.5em;
            border-radius: 4px;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary:hover {
            background-color: #f0f0ff;
        }

        summary::marker {
            color: #667eea;
        }

        details[open] summary {
            margin-bottom: 0.5em;
        }

        details > ul {
            margin-left: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        ul {
            margin-left: 1.5em;
            margin-bottom: 0.5em;
        }

        li {
            margin-bottom: 0.25em;
            line-height: 1.5;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .back-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
            min-width: 40px;
        }

        .back-btn:hover {
            color: #5568d3;
        }

        .back-btn.hidden {
            visibility: hidden;
        }

        h1 {
            text-align: center;
            color: #333;
            margin: 0;
            font-size: 36px;
            font-weight: bold;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            flex: 1;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 18px;
            font-weight: normal;
        }

        .home-screen {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 50px;
        }

        .home-screen.hidden {
            display: none;
        }

        .countdown-screen {
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            padding: 40px;
            margin-top: 50px;
        }

        .countdown-screen.hidden {
            display: none !important;
        }

        .countdown-screen:not(.hidden) {
            display: flex;
        }

        .home-btn {
            padding: 20px;
            font-size: 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .home-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .game-content {
            display: block;
        }

        .game-content.hidden {
            display: none;
        }

        .word-display {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            min-height: 100px;
            position: relative;
            overflow: hidden;
        }

        .word-carousel {
            position: relative;
            height: 60px;
            overflow: hidden;
        }

        .word-slot {
            position: absolute;
            top: 50%;
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
            white-space: nowrap;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Position classes for the carousel - transform will be set dynamically */
        .word-slot.pos-prev-prev {
            opacity: 0;
        }

        .word-slot.pos-prev {
            opacity: 0.2;
        }

        .word-slot.pos-current {
            opacity: 1;
        }

        .word-slot.pos-next {
            opacity: 0.3;
        }

        .word-slot.pos-next-next {
            opacity: 0;
        }

        .word-display .word {
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
        }

        .word-display .char {
            display: inline-block;
            transition: all 0.2s ease;
            white-space: pre; /* Preserve spaces */
        }

        .word-display .char.correct {
            opacity: 0.4;
            color: #28a745;
        }

        .word-display .char.incorrect {
            color: #dc3545;
            font-weight: bold;
        }

        .input-container {
            margin-bottom: 20px;
        }

        #typingInput {
            width: 100%;
            padding: 15px;
            font-size: 32px;
            font-family: 'Inter-Alia', sans-serif;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            text-align: center;
            letter-spacing: 4px;
            transition: border-color 0.3s;
        }

        #typingInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #333;
            font-size: 24px;
            font-weight: bold;
        }

        .countdown-text {
            font-size: 72px;
            font-weight: bold;
            color: #667eea;
            animation: countdown-pulse 0.5s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes error-flash {
            0% {
                background-color: #e74c3c;
            }
            100% {
                background-color: white;
            }
        }

        .completion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .completion-modal.show {
            display: flex;
        }

        .completion-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .completion-content h2 {
            color: #667eea;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .completion-content .final-score {
            font-size: 48px;
            font-weight: bold;
            color: #333;
            margin: 20px 0;
        }

        .completion-content .stat-row {
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }

        .level-stats-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .level-stat {
            padding: 5px 0;
            font-size: 14px;
            color: #555;
            border-bottom: 1px solid #e0e0e0;
        }

        .level-stat:last-child {
            border-bottom: none;
        }

        .completion-content button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .completion-content button:hover {
            background: #5568d3;
        }

        .mode-btn {
            padding: 10px 30px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #f0f0ff;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .settings-btn {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s;
        }

        .settings-btn:hover {
            background: #f0f0ff;
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
        }

        .settings-content h2 {
            color: #667eea;
            font-size: 28px;
            margin-bottom: 25px;
        }

        .settings-option {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option label {
            display: flex;
            align-items: center;
            font-size: 16px;
            color: #333;
            cursor: pointer;
        }

        .settings-option input[type="checkbox"] {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .settings-option-desc {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
            margin-left: 32px;
        }

        .settings-close-btn {
            margin-top: 25px;
            padding: 12px 30px;
            font-size: 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .settings-close-btn:hover {
            background: #5568d3;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 32px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #333;
        }

        .completion-content,
        .settings-content {
            position: relative;
        }

        #lengthSelect {
            padding: 8px 15px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .burger-menu {
            position: relative;
            display: inline-block;
            min-width: 40px;
        }

        .burger-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
        }

        .burger-btn:hover {
            color: #5568d3;
        }

        .burger-dropdown {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 1000;
            overflow: hidden;
        }

        .burger-dropdown.show {
            display: block;
        }

        .burger-dropdown a {
            color: #333;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: background 0.3s;
        }

        .burger-dropdown a:hover {
            background: #f0f0ff;
        }

        .copyright {
            text-align: center;
            color: #000000;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
        }

        .lesson-option {
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .lesson-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .lesson-option strong {
            color: #333;
            font-size: 16px;
        }

        /* Mobile-friendly compact layout */
        @media (max-width: 768px) {
            h1 {
                font-size: 32px;
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 16px;
                margin-bottom: 20px;
            }

            .word-display {
                padding: 20px;
                margin-bottom: 20px;
                min-height: 60px;
            }

            .word-display .word {
                font-size: 36px;
                letter-spacing: 2px;
            }

            #typingInput {
                padding: 12px;
                font-size: 24px;
            }

            .input-container {
                margin-bottom: 15px;
            }

            .stats {
                gap: 15px;
                margin-bottom: 15px;
            }

            .countdown-text {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <button class="back-btn hidden" id="backBtn" onclick="goHome()">‚Üê</button>
            <h1 id="mainTitle">Shaw Type</h1>
            <div class="burger-menu">
                <button class="burger-btn" onclick="toggleBurgerMenu()">‚ò∞</button>
                <div class="burger-dropdown" id="burgerDropdown">
                    <a id="menuAbout" href="#" onclick="openContentModal('about'); return false;">About</a>
                    <a id="menuKeyboards" href="#" onclick="openContentModal('keyboards'); return false;">Keyboards</a>
                    <a id="menuResources" href="#" onclick="openContentModal('resources'); return false;">Resources</a>
                    <a id="menuSettings" href="#" onclick="openSettings(); closeBurgerMenu(); return false;">Settings</a>
                </div>
            </div>
        </div>

        <div class="subtitle" id="mainSubtitle">êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï</div>

        <!-- Home Screen -->
        <div class="home-screen" id="homeScreen">
            <button class="home-btn" id="homePlayBtn" onclick="startPlay()">Play</button>
            <button class="home-btn" id="homePracticeBtn" onclick="startPractice()">Practice</button>
            <button class="home-btn" id="homeSettingsBtn" onclick="openSettings()">Settings</button>
        </div>

        <!-- Countdown Screen -->
        <div class="countdown-screen hidden" id="countdownScreen">
            <div class="countdown-text" id="countdownText"></div>
        </div>

        <!-- Game Content -->
        <div class="game-content hidden" id="gameContent">
        <div class="word-display">
            <div class="word-carousel">
                <div class="word-slot slot-0" id="wordSlot0"></div>
                <div class="word-slot slot-1" id="wordSlot1"></div>
                <div class="word-slot slot-2" id="wordSlot2"></div>
                <div class="word-slot slot-3" id="wordSlot3"></div>
            </div>
        </div>

        <div class="input-container">
            <input type="text" id="typingInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label" id="levelLabel">Level</div>
                <div class="stat-value" id="levelDisplay">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Words</div>
                <div class="stat-value" id="wordCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">100%</div>
            </div>
        </div>

        <div id="currentLessonInfo" style="display: none; text-align: left; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 13px; color: #666;">
            <strong id="currentLessonName"></strong>
        </div>

        </div> <!-- End game-content -->
    </div> <!-- End container -->

    <div class="copyright">
        @2025 joro.io
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="completion-content">
            <span class="modal-close" onclick="goHome()">&times;</span>
            <h2 id="completionTitle">Congratulations!</h2>
            <p id="completionMessage">You completed 30 words!</p>
            <div class="final-score" id="finalScore">--</div>
            <div class="stat-row">WPM: <span id="finalWPM">--</span></div>
            <div class="stat-row">Letters/min: <span id="finalLPM">--</span></div>
            <div class="stat-row">Accuracy: <span id="finalAccuracy">--</span></div>
            <div class="stat-row" id="bestTimeRow"></div>
            <div class="stat-row" id="levelReachedRow">Level Reached: <span id="finalLevel">--</span></div>
            <div id="levelStatsContainer" class="level-stats-container"></div>
            <div id="completionButtons">
                <button onclick="resetPractice()">Practice Again</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <span class="modal-close" onclick="closeSettings()">&times;</span>
            <h2>Settings</h2>

            <div class="settings-option">
                <label id="settingsDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="gb" checked onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="us" onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <div class="settings-option">
                <label style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Keyboard Layout
                </label>
                <select id="layoutSelectSettings" onchange="onLayoutChangeSettings()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="new-imperial">New Shaw Imperial</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option" id="ligatureSettingOption">
                <label>
                    <input type="checkbox" id="ligatureToggleSettings" onchange="onLigatureToggleSettings()">
                    <span>My keyboard auto-converts ligatures (e.g., êë©+êëÆ ‚Üí êëº)</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="shavianUIToggle" onchange="toggleShavianUI()">
                    <span>Display UI in Shavian</span>
                </label>
                <div class="settings-option-desc">Show labels and text in Shavian alphabet instead of Latin</div>
            </div>

            <div class="settings-option" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                <label>
                    <input type="checkbox" id="hideWelcomeToggle" onchange="toggleHideWelcome()">
                    <span id="settingsHideWelcome">Hide welcome screen when page opens</span>
                </label>
            </div>
        </div>
    </div>

    <!-- Content Modal -->
    <div class="settings-modal" id="contentModal">
        <div class="settings-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <span class="modal-close" onclick="closeContentModal()">&times;</span>
            <h2 id="contentModalTitle">Content</h2>
            <div id="contentModalBody" style="margin-top: 20px;">
                Loading...
            </div>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div class="settings-modal" id="welcomeModal">
        <div class="settings-content" style="max-width: 600px;">
            <h2 id="welcomeTitle">Welcome to Shaw Type!</h2>
            <p id="welcomeSubtitle" style="margin: 15px 0; color: #666;">Choose your preferences to get started:</p>

            <div class="settings-option">
                <label id="welcomeDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectWelcome" value="gb" checked onchange="onDialectChangeWelcome()" style="margin-right: 8px;">
                        <span id="welcomeDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectWelcome" value="us" onchange="onDialectChangeWelcome()" style="margin-right: 8px;">
                        <span id="welcomeDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <div class="settings-option">
                <label id="welcomeLayoutLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Keyboard Layout
                </label>
                <select id="layoutSelectWelcome" onchange="onLayoutChangeWelcome()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="new-imperial">New Shaw Imperial</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option" id="ligatureWelcomeOption">
                <label>
                    <input type="checkbox" id="ligatureToggleWelcome" onchange="onLigatureToggleWelcome()">
                    <span id="welcomeLigatureLabel">Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="shavianUIToggleWelcome" onchange="toggleShavianUIWelcome()">
                    <span id="welcomeShavianUILabel">Display UI in Shavian</span>
                </label>
            </div>

            <button id="welcomeStartButton" class="settings-close-btn" onclick="closeWelcomeModal()" style="margin-top: 25px; width: 100%;">Start</button>
        </div>
    </div>

    <!-- Lesson Selector Modal -->
    <div class="settings-modal" id="lessonModal">
        <div class="settings-content" style="max-width: 500px;">
            <span class="modal-close" onclick="closeLessonModal()">&times;</span>
            <h2 id="lessonModalTitle">Choose a Lesson</h2>
            <p id="lessonModalSubtitle" style="margin: 15px 0; color: #666;">Select a lesson to practice:</p>

            <div id="lessonList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Lessons will be populated dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Words will be loaded from JSON file
        let wordsByLength = {};
        let learnWordsImperial = {};
        let learnWordsImperialNoLig = {};
        let learnWordsNewImperial = {};
        let learnWordsNewImperialNoLig = {};
        let learnWordsQwerty = {};
        let learnWords2layer = {};
        let learnWordsJafl = {};
        let learnWordsJaflNoLig = {};
        let wordsLoaded = false;

        // Current level/lesson state
        let currentLevelWordPool = []; // Source pool of words for current level/lesson
        let currentLevelWordCount = 5; // Number of words to complete this level/lesson
        let currentLevelTitle = ''; // Display title for current level/lesson
        let currentLevelType = 'level'; // 'level' or 'lesson' for UI labels
        let currentLevelTypeLabel = 'Level'; // Display label for UI
        let currentLevelNumber = 1;
        let currentLevelCompletionCallback = null; // Function to call when level completes

        // Carousel: 4 slots, we track which slot index maps to which position
        let carouselOffset = 0; // Current slot index for "current" word
        let words = ['', '', '', '']; // Words in slots [0, 1, 2, 3]
        let currentWord = ''; // The actual current word being typed
        let wordsCompleted = 0;
        let wordsInCurrentLevel = 0; // Words completed in current level
        let totalLettersTyped = 0;
        let correctLetters = 0;
        let recentWords = []; // Track recent words to avoid repeats
        let startTime = null; // Session start time
        let bestTime = null; // Best completion time from localStorage (in seconds)
        let levelStats = []; // Per-level statistics
        let currentLevelLettersTyped = 0; // Letters typed in current level
        let currentLevelCorrectLetters = 0; // Correct letters in current level

        // Shadow input: faithful representation of what user typed (browsers may strip combining chars)
        let shadowInput = '';

        // Track replacement info from beforeinput event (for insertReplacementText)
        let pendingReplacementStart = -1;
        let pendingReplacementEnd = -1;

        // Ligature mappings - each ligature can have multiple 2-character input sequences
        const VS1 = '\uFE00';
        const LIGATURES = {
            'êëº': [['êë©', 'êëÆ']],                      // ER: one way
            'êë∏': [['êë≠', 'êëÆ']],                      // AR: one way
            'êëπ': [['êë∑', 'êëÆ']],                      // OR: one way
            'êëø': [['êëò', 'êëµ']],                      // YEW: one way
            'êëΩ': [['êëæ', 'êëÆ']],                      // AIR (compound): one way
            'êëª': [['êëª', 'êëÆ'], ['êëª' + VS1, 'êëÆ'], ['êë≥', 'êëÆ']],  // ERR: three ways (err+roar, err+VS1+roar, up+roar JAFL)
            'êë∫': [['êë∫', 'êëÆ'], ['êë∫' + VS1, 'êëÆ']]                // AIR (simple): two ways (air+roar, air+VS1+roar)
        };

        // Reverse mapping: all component sequences to their compound ligature
        const COMPONENT_TO_LIGATURE = {};
        Object.keys(LIGATURES).forEach(compound => {
            LIGATURES[compound].forEach(sequence => {
                const key = sequence.join('');
                COMPONENT_TO_LIGATURE[key] = compound;
            });
        });

        // Form ligatures in a word by replacing component pairs with ligatures
        function formLigaturesInWord(word) {
            let result = word;
            let changed = true;

            while (changed) {
                changed = false;
                const chars = Array.from(result);

                for (let i = 0; i < chars.length - 1; i++) {
                    const pair = chars[i] + chars[i + 1];
                    if (COMPONENT_TO_LIGATURE[pair]) {
                        result = chars.slice(0, i).join('') +
                                COMPONENT_TO_LIGATURE[pair] +
                                chars.slice(i + 2).join('');
                        changed = true;
                        break;
                    }
                }
            }

            return result;
        }


        // Mode management
        let currentMode = 'play'; // 'learn' or 'play'
        let currentLayout = 'imperial'; // 'imperial' or 'qwerty'
        let useLigatures = false; // Toggle for ligatures - OFF by default
        let selectedLevel = 1; // Level selection: 1-7
        let useShavianUI = false; // Toggle for Shavian UI
        let currentDialect = 'gb'; // 'gb' or 'us' - English dialect for word lists
        let debugMode = false; // Toggle for debug logging

        // Helper function to toggle debug mode (can be called from console immediately)
        // Usage: setDebug(true) or setDebug(false)
        window.setDebug = function(enabled) {
            debugMode = !!enabled;
            localStorage.setItem('debugMode', debugMode);
            console.log('Debug mode ' + (debugMode ? 'enabled' : 'disabled') + ' and saved to localStorage');
            return debugMode;
        };
        console.log('setDebug function defined, available as window.setDebug() or setDebug()');

        // UI text translations
        const translations = {
            latin: {
                title: 'Shaw Type',
                subtitle: 'êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï',
                practice: 'Practice',
                play: 'Play',
                settings: 'Settings',
                keyboardLayout: 'Keyboard Layout',
                ligatures: 'Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)',
                lesson: 'Lesson:',
                wordLength: 'Word Length:',
                characters: 'characters',
                // Word length options
                length1: '1 character',
                length2: '2 characters',
                length3: '3 characters',
                length4: '4 characters',
                length5: '5 characters',
                length6: '6 characters',
                length7: '7 characters',
                length46: '4-6 characters',
                length57: '5-7 characters',
                lesson_label: 'Lesson',
                level_label: 'Level',
                words: 'Words',
                accuracy: 'Accuracy',
                gameInstructions: 'Type the words shown - hit space between words.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'Home Row Center',
                lessonFullHomeRow: 'Full Home Row',
                lessonIndexFingerReach: 'Index Finger Reach',
                lessonUpperLowerRows: 'Upper & Lower Rows',
                lessonNumberRowFocus: 'Number Row Focus',
                lessonHardToReach: 'Hard to Reach',
                lessonAllKeys: 'All Keys',
                lessonCompoundLetters: 'Compound Letters',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'Home Row + Shift',
                lessonAddUpperRow: 'Add Upper Row',
                lessonAddLowerRow: 'Add Lower Row',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'Essential Phonemes',
                lessonVowelVoyage: 'Vowel Voyage',
                lessonConsonantCommand: 'Consonant Command',
                lessonLigaturePower: 'Ligature Power',
                lessonShiftMastery: 'Shift Mastery',
                lessonCompleteControl: 'Complete Control',
                // Lesson names - JAFL
                lessonCoreFoundation: 'Core Foundation',
                lessonHomeSweet: 'Home Sweet Home',
                lessonUpperExpedition: 'Upper Expedition',
                lessonLowerExploration: 'Lower Exploration',
                lessonShiftIntroduction: 'Shift Introduction',
                lessonMasterTypist: 'Master Typist',
                congratulations: 'Congratulations!',
                completed30: 'You completed 30 words!',
                wpm: 'WPM:',
                lettersPerMin: 'Letters/min:',
                accuracy_final: 'Accuracy:',
                levelReached: 'Level Reached:',
                practiceAgain: 'Practice Again',
                settingsTitle: 'Settings',
                displayShavian: 'Display UI in Shavian',
                displayShavianDesc: 'Show labels and text in Shavian alphabet instead of Latin',
                close: 'Close',
                lessonModalTitle: 'Choose a Lesson',
                lessonModalSubtitle: 'Select a lesson to practice:',
                lessonModalCancel: 'Cancel',
                lessonPrefix: 'Lesson',
                // Lesson descriptions
                desc1: 'Middle fingers only, home row',
                desc2: 'All fingers, home row',
                desc3: 'Add index finger upper/lower reaches',
                desc4: 'Extend to more keys above and below',
                desc5: 'Add outer columns',
                desc6: 'Complete keyboard (all layers)',
                desc7: 'Practice typing ligatures: êëº êë∏ êëπ êëø êëΩ',
                desc8: 'Home row with shift layer',
                desc9: 'Add upper row (both layers)',
                desc10: 'Add lower row (both layers)',
                desc11: 'Master the 9 most common sounds in English',
                desc12: 'Navigate through English vowel sounds',
                desc13: 'Build confidence with base layer consonants',
                desc14: 'Harness the efficiency of compound letters',
                desc15: 'Unlock the full potential of the shift layer',
                desc16: 'Command every key with confidence',
                desc17: 'Build your foundation with essential sounds',
                desc18: 'Master the comfort of the home row',
                desc19: 'Journey to the upper reaches of your keyboard',
                desc20: 'Explore the depths below home position',
                desc21: 'Discover new dimensions with the shift key',
                desc22: 'Achieve mastery over the complete keyboard',
                desc23: 'All fingers, home row (unshifted)',
                desc24: 'Complete keyboard including number row',
                // Burger menu items
                menuAbout: 'About',
                menuKeyboards: 'Keyboards',
                menuResources: 'Resources',
                menuSettings: 'Settings',
                // Content modal titles
                titleAbout: 'About',
                titleKeyboards: 'Keyboards',
                titleResources: 'Resources',
                // Settings dialog labels
                dialectLabel: 'Choose spelling',
                dialectBritish: 'British',
                dialectAmerican: 'American',
                hideWelcome: 'Hide welcome screen when page opens',
                // Layout names
                layoutImperial: 'Shaw Imperial',
                layoutNewImperial: 'New Shaw Imperial',
                layoutQwerty: 'Shaw QWERTY',
                layout2layer: 'Shaw 2-layer (shift)',
                layoutJafl: 'Shaw-JAFL'
            },
            shavian: {
                title: '¬∑êëñêë∑ êëëêë≤êëê',
                subtitle: '¬∑êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï',
                practice: 'êëêêëÆêë®êëíêëëêë¶êëï',
                play: 'êëêêë§êë±',
                settings: 'êëïêëßêëëêë¶êëôêëü',
                keyboardLayout: 'êëíêë∞êëöêëπêëõ êë§êë±êë¨êëë',
                ligatures: 'êë∑êëëêë©êë•êë®êëëêë¶êëí êë§êë¶êëúêë©êëóêëºêëü (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)',
                lesson: 'êë§êëßêëïêë©êëØ:',
                wordLength: 'êë¢êëªêëõ êë§êëßêëôêëî:',
                characters: 'êëíêë®êëÆêë©êëíêëëêëºêëü',
                // Word length options
                length1: '1 êëíêë®êëÆêë©êëíêëëêëº',
                length2: '2 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length3: '3 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length4: '4 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length5: '5 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length6: '6 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length7: '7 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length46: '4-6 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length57: '5-7 êëíêë®êëÆêë©êëíêëëêëºêëü',
                lesson_label: 'êë§êëßêëïêë©êëØ',
                level_label: 'êë§êëßêëùêë©êë§',
                words: 'êë¢êëªêëõêëü',
                accuracy: 'êë®êëíêëòêëºêë©êëïêë¶',
                gameInstructions: 'êëëêë≤êëê êëû êë¢êëªêëõêëü êëñêë¥êëØ - êë£êë¶êëë êëïêëêêë±êëï êëöêë¶êëëêë¢êë∞êëØ êë¢êëªêëõêëü.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'êë£êë¥êë• êëÆêë¥ êëïêëßêëØêëëêëº',
                lessonFullHomeRow: 'êëìêë´êë§ êë£êë¥êë• êëÆêë¥',
                lessonIndexFingerReach: 'êë¶êëØêëõêëßêëíêëï êëìêë¶êëôêëúêëº êëÆêë∞êëó',
                lessonUpperLowerRows: 'êë≥êëêêëº & êë§êë¥êëº êëÆêë¥êëü',
                lessonNumberRowFocus: 'êëØêë≥êë•êëöêëº êëÆêë¥ êëìêë¥êëíêë©êëï',
                lessonHardToReach: 'êë£êë≠êëÆêëõ êëë êëÆêë∞êëó',
                lessonAllKeys: 'êë∑êë§ êëíêë∞êëü',
                lessonCompoundLetters: 'êëíêë™êë•êëêêë¨êëØêëõ êë§êëßêëëêëºêëü',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'êë£êë¥êë• êëÆêë¥ + êëñêë¶êëìêëë',
                lessonAddUpperRow: 'êë®êëõ êë≥êëêêëº êëÆêë¥',
                lessonAddLowerRow: 'êë®êëõ êë§êë¥êëº êëÆêë¥',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'êë¶êëïêëßêëØêëñêë©êë§ êëìêë¥êëØêë∞êë•êëü',
                lessonVowelVoyage: 'êëùêë¨êë©êë§ êëùêë∂êë¶êë°',
                lessonConsonantCommand: 'êëíêë™êëØêëïêë©êëØêë©êëØêëë êëíêë©êë•êë≠êëØêëõ',
                lessonLigaturePower: 'êë§êë¶êëúêë©êëóêëº êëêêë¨êëº',
                lessonShiftMastery: 'êëñêë¶êëìêëë êë•êë≠êëïêëëêëºêë¶',
                lessonCompleteControl: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë©êëØêëëêëÆêë¥êë§',
                // Lesson names - JAFL
                lessonCoreFoundation: 'êëíêëπ êëìêë¨êëØêëõêë±êëñêë©êëØ',
                lessonHomeSweet: 'êë£êë¥êë• êëïêë¢êë∞êëë êë£êë¥êë•',
                lessonUpperExpedition: 'êë≥êëêêëº êëßêëíêëïêëêêë©êëõêë¶êëñêë©êëØ',
                lessonLowerExploration: 'êë§êë¥êëº êëßêëíêëïêëêêë§êëºêë±êëñêë©êëØ',
                lessonShiftIntroduction: 'êëñêë¶êëìêëë êë¶êëØêëëêëÆêë©êëõêë≥êëíêëñêë©êëØ',
                lessonMasterTypist: 'êë•êë≠êëïêëëêëº êëëêë≤êëêêë¶êëïêëë',
                congratulations: 'êëíêë©êëØêëúêëÆêë®êëóêë©êë§êë±êëñêë©êëØêëü!',
                completed30: 'êëø êëíêë©êë•êëêêë§êë∞êëëêë©êëõ 30 êë¢êëªêëõêëü!',
                wpm: 'WPM:',
                lettersPerMin: 'êë§êëßêëëêëºêëü/êë•êë∞êëØ:',
                accuracy_final: 'êë®êëíêëòêëºêë©êëïêë¶:',
                levelReached: 'êë§êëßêëùêë©êë§ êëÆêë∞êëóêëë:',
                practiceAgain: 'êëêêëÆêë®êëíêëëêë¶êëï êë©êëúêëßêëØ',
                settingsTitle: 'êëïêëßêëëêë¶êëôêëü',
                displayShavian: 'êëõêë¶êëïêëêêë§êë± UI êë¶êëØ ¬∑êëñêë±êëùêëæêëØ',
                displayShavianDesc: 'êëñêë¥ êë§êë±êëöêë©êë§êëü êëØ êëëêëßêëíêëïêëë êë¶êëØ ¬∑êëñêë±êëùêëæêëØ êë®êë§êëìêë©êëöêëßêëë êë¶êëØêëïêëëêëßêëõ êëù ¬∑êë§êë®êëëêë¶êëØ',
                close: 'êëíêë§êë¥êëü',
                lessonModalTitle: 'êëóêëµêëü êë© êë§êëßêëïêë©êëØ',
                lessonModalSubtitle: 'êëïêë¶êë§êëßêëíêëë êë© êë§êëßêëïêë©êëØ êëë êëêêëÆêë®êëíêëëêë¶êëï:',
                lessonModalCancel: 'êëíêë®êëØêëïêë©êë§',
                lessonPrefix: 'êë§êëßêëïêë©êëØ',
                // Lesson descriptions
                desc1: 'êë•êë¶êëõêë©êë§ êëìêë¶êëôêëúêëºêëü êë¥êëØêë§êë¶, êë£êë¥êë• êëÆêë¥',
                desc2: 'êë∑êë§ êëìêë¶êëôêëúêëºêëü, êë£êë¥êë• êëÆêë¥',
                desc3: 'êë®êëõ êë¶êëØêëõêëßêëíêëï êëìêë¶êëôêëúêëº êë≥êëêêëº/êë§êë¥êëº êëÆêë∞êëóêë©êëü',
                desc4: 'êë¶êëíêëïêëëêëßêëØêëõ êëë êë•êëπ êëíêë∞êëü êë©êëöêë≥êëù êëØ êëöêë¶êë§êë¥',
                desc5: 'êë®êëõ êë¨êëëêëº êëíêë™êë§êë©êë•êëü',
                desc6: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ (êë∑êë§ êë§êë±êëºêëü)',
                desc7: 'êëêêëÆêë®êëíêëëêë¶êëï êëëêë≤êëêêë¶êëô êë§êë¶êëúêë©êëóêëºêëü: êëº êë∏ êëπ êëø êëΩ',
                desc8: 'êë£êë¥êë• êëÆêë¥ êë¢êë¶êëû êëñêë¶êëìêëë êë§êë±êëº',
                desc9: 'êë®êëõ êë≥êëêêëº êëÆêë¥ (êëöêë¥êëî êë§êë±êëºêëü)',
                desc10: 'êë®êëõ êë§êë¥êëº êëÆêë¥ (êëöêë¥êëî êë§êë±êëºêëü)',
                desc11: 'êë•êë≠êëïêëëêëº êëû 9 êë•êë¥êëïêëë êëíêë™êë•êë©êëØ êëïêë¨êëØêëõêëü êë¶êëØ ¬∑êë¶êëôêëúêë§êë¶êëñ',
                desc12: 'êëØêë®êëùêë¶êëúêë±êëë êëîêëÆêëµ ¬∑êë¶êëôêëúêë§êë¶êëñ êëùêë¨êë©êë§ êëïêë¨êëØêëõêëü',
                desc13: 'êëöêë¶êë§êëõ êëíêë™êëØêëìêë¶êëõêë©êëØêëï êë¢êë¶êëû êëöêë±êëï êë§êë±êëº êëíêë™êëØêëïêë©êëØêë©êëØêëëêëï',
                desc14: 'êë£êë∏êëØêë©êëï êëû êë¶êëìêë¶êëñêë©êëØêëïêë¶ êëù êëíêë™êë•êëêêë¨êëØêëõ êë§êëßêëëêëºêëü',
                desc15: 'êë≥êëØêë§êë™êëí êëû êëìêë´êë§ êëêêë©êëëêëßêëØêëñêë©êë§ êëù êëû êëñêë¶êëìêëë êë§êë±êëº',
                desc16: 'êëíêë©êë•êë≠êëØêëõ êëßêëùêëÆêë¶ êëíêë∞ êë¢êë¶êëû êëíêë™êëØêëìêë¶êëõêë©êëØêëï',
                desc17: 'êëöêë¶êë§êëõ êëòêëπ êëìêë¨êëØêëõêë±êëñêë©êëØ êë¢êë¶êëû êë¶êëïêëßêëØêëñêë©êë§ êëïêë¨êëØêëõêëü',
                desc18: 'êë•êë≠êëïêëëêëº êëû êëíêë≥êë•êëìêëºêëë êëù êëû êë£êë¥êë• êëÆêë¥',
                desc19: 'êë°êëªêëØêë¶ êëë êëû êë≥êëêêëº êëÆêë∞êëóêë©êëü êëù êëòêëπ êëíêë∞êëöêëπêëõ',
                desc20: 'êë¶êëíêëïêëêêë§êëπ êëû êëõêëßêëêêëîêëï êëöêë¶êë§êë¥ êë£êë¥êë• êëêêë©êëüêë¶êëñêë©êëØ',
                desc21: 'êëõêë¶êëïêëíêë≥êëùêëº êëØêëø êëõêë¶êë•êëßêëØêëñêë©êëØêëü êë¢êë¶êëû êëû êëñêë¶êëìêëë êëíêë∞',
                desc22: 'êë©êëóêë∞êëù êë•êë≠êëïêëëêëºêë¶ êë¥êëùêëº êëû êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ',
                desc23: 'êë∑êë§ êëìêë¶êëôêëúêëºêëü, êë£êë¥êë• êëÆêë¥ (êë≥êëØêëñêë¶êëìêëëêë©êëõ)',
                desc24: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ êë¶êëØêëíêë§êëµêëõêë¶êëô êëØêë≥êë•êëöêëº êëÆêë¥',
                // Burger menu items
                menuAbout: 'êë©êëöêë¨êëë',
                menuKeyboards: 'êëíêë∞êëöêëπêëõêëü',
                menuResources: 'êëÆêë¶êëüêëπêëïêë©êëü',
                menuSettings: 'êëïêëßêëëêë¶êëôêëü',
                // Content modal titles
                titleAbout: 'êë©êëöêë¨êëë',
                titleKeyboards: 'êëíêë∞êëöêëπêëõêëü',
                titleResources: 'êëÆêë¶êëüêëπêëïêë©êëü',
                // Settings dialog labels
                dialectLabel: 'êëóêëµêëü êëïêëêêëßêë§êë¶êëô',
                dialectBritish: '¬∑êëöêëÆêë¶êëëêë¶êëñ',
                dialectAmerican: '¬∑êë©êë•êëßêëÆêë¶êëíêë©êëØ',
                hideWelcome: 'êë£êë≤êëõ êë¢êëßêë§êëíêë≥êë• êëïêëíêëÆêë∞êëØ êë¢êëßêëØ êëêêë±êë° êë¥êëêêë©êëØêëü',
                // Layout names
                layoutImperial: '¬∑êëñêë∑ êë¶êë•êëêêëΩêëæêë§',
                layoutNewImperial: '¬∑êëØêëø êëñêë∑ êë¶êë•êëêêëΩêëæêë§',
                layoutQwerty: '¬∑êëñêë∑ QWERTY',
                layout2layer: '¬∑êëñêë∑ 2-êë§êë±êëº (êëñêë¶êëìêëë)',
                layoutJafl: '¬∑êëñêë∑-JAFL'
            }
        };

        const wordSlots = [
            document.getElementById('wordSlot0'),
            document.getElementById('wordSlot1'),
            document.getElementById('wordSlot2'),
            document.getElementById('wordSlot3')
        ];
        const typingInput = document.getElementById('typingInput');
        const wordCountEl = document.getElementById('wordCount');
        const accuracyEl = document.getElementById('accuracy');
        const levelDisplayEl = document.getElementById('levelDisplay');

        // Get current level based on words completed (5 words per level)
        function getCurrentLevel() {
            if (currentMode === 'learn' && currentLayout === 'imperial' && useLigatures) {
                // Imperial with ligatures has 7 levels (compound letters at level 5)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5; // Compound letters lesson
                if (wordsCompleted < 30) return 6; // Almost Complete
                return 7; // All Keys
            } else {
                // Other modes use 6 levels (5 words per level = 30 words total)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5;
                return 6;
            }
        }

        // UI Navigation
        function goHome() {
            // Cancel any running countdown
            cancelCountdown();

            // Hide game content and countdown, show home screen
            document.getElementById('gameContent').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('hidden');

            // Reset subtitle to default
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            document.getElementById('mainSubtitle').textContent = t.subtitle;

            // Clear any modals
            closeLessonModal();
            document.getElementById('completionModal').classList.remove('show');
        }

        function showGameContent() {
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('gameContent').classList.remove('hidden');
            document.getElementById('backBtn').classList.remove('hidden');
        }

        function startPlay() {
            currentMode = 'play';
            localStorage.setItem('currentMode', currentMode);

            // Hide home screen, show back button
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('hidden');

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Update UI language
            updateUILanguage();

            // Show countdown, then start game
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function playAgain() {
            // Hide completion modal
            document.getElementById('completionModal').style.display = 'none';

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Show countdown, then start game
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function startPractice() {
            currentMode = 'learn';
            localStorage.setItem('currentMode', currentMode);

            // Open lesson selector first
            openLessonSelector();
        }

        function updateSubtitleForGame() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const subtitle = document.getElementById('mainSubtitle');

            if (currentMode === 'play') {
                subtitle.textContent = `${t.level_label} ${currentLevelNumber}`;
            } else if (currentMode === 'learn') {
                // Lesson name will be set when lesson is selected
                subtitle.textContent = '';
            }
        }

        // Mode switching (legacy - now mainly used internally)
        function setMode(mode) {
            currentMode = mode;
            localStorage.setItem('currentMode', currentMode);

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display =
                mode === 'learn' ? 'block' : 'none';

            // Update subtitle
            updateSubtitleForGame();

            // Open lesson selector when switching to practice mode
            if (mode === 'learn') {
                openLessonSelector();
            }

            // Update stat label based on mode
            updateUILanguage();

            // Reset and reload
            resetPractice();
        }

        function onDialectChangeSettings() {
            const selected = document.querySelector('input[name="dialectSettings"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    initializeGame();
                });
            }
        }

        function onLayoutChangeSettings() {
            currentLayout = document.getElementById('layoutSelectSettings').value;
            localStorage.setItem('keyboardLayout', currentLayout);
            // Show/hide ligature toggle based on layout
            // Only show for imperial, new-imperial, qwerty, and jafl
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'new-imperial' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';
            updateLevelSelector();
            initializeGame();
        }

        function onLigatureToggleSettings() {
            useLigatures = document.getElementById('ligatureToggleSettings').checked;
            localStorage.setItem('useLigatures', useLigatures);
            updateLevelSelector();
            initializeGame();
        }

        function onLevelChange() {
            selectedLevel = document.getElementById('levelSelect').value;
            initializeGame();
        }

        function getLearnWords() {
            // Get the appropriate word list for current layout and ligature settings
            if (currentLayout === 'imperial') {
                return useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'new-imperial') {
                return useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                return learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                return learnWords2layer;
            } else if (currentLayout === 'jafl') {
                return useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }
            return null;
        }

        function translateLessonName(name) {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Map English lesson names to translation keys
            const nameMap = {
                'Home Row Center': t.lessonHomeRowCenter,
                'Full Home Row': t.lessonFullHomeRow,
                'Index Finger Reach': t.lessonIndexFingerReach,
                'Upper & Lower Rows': t.lessonUpperLowerRows,
                'Number Row Focus': t.lessonNumberRowFocus,
                'Hard to Reach': t.lessonHardToReach,
                'All Keys': t.lessonAllKeys,
                'Compound Letters': t.lessonCompoundLetters,
                'Home Row + Shift': t.lessonHomeRowShift,
                'Add Upper Row': t.lessonAddUpperRow,
                'Add Lower Row': t.lessonAddLowerRow,
                'Essential Phonemes': t.lessonEssentialPhonemes,
                'Vowel Voyage': t.lessonVowelVoyage,
                'Consonant Command': t.lessonConsonantCommand,
                'Ligature Power': t.lessonLigaturePower,
                'Shift Mastery': t.lessonShiftMastery,
                'Complete Control': t.lessonCompleteControl,
                'Core Foundation': t.lessonCoreFoundation,
                'Home Sweet Home': t.lessonHomeSweet,
                'Upper Expedition': t.lessonUpperExpedition,
                'Lower Exploration': t.lessonLowerExploration,
                'Shift Introduction': t.lessonShiftIntroduction,
                'Master Typist': t.lessonMasterTypist
            };

            return nameMap[name] || name;
        }

        function translateLessonDescription(description) {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Map English descriptions to translation keys
            const descMap = {
                'Middle fingers only, home row': t.desc1,
                'All fingers, home row': t.desc2,
                'Add index finger upper/lower reaches': t.desc3,
                'Extend to more keys above and below': t.desc4,
                'Add outer columns': t.desc5,
                'Complete keyboard (all layers)': t.desc6,
                'Practice typing ligatures: êëº êë∏ êëπ êëø êëΩ': t.desc7,
                'Home row with shift layer': t.desc8,
                'Add upper row (both layers)': t.desc9,
                'Add lower row (both layers)': t.desc10,
                'Master the 9 most common sounds in English': t.desc11,
                'Navigate through English vowel sounds': t.desc12,
                'Build confidence with base layer consonants': t.desc13,
                'Harness the efficiency of compound letters': t.desc14,
                'Unlock the full potential of the shift layer': t.desc15,
                'Command every key with confidence': t.desc16,
                'Build your foundation with essential sounds': t.desc17,
                'Master the comfort of the home row': t.desc18,
                'Journey to the upper reaches of your keyboard': t.desc19,
                'Explore the depths below home position': t.desc20,
                'Discover new dimensions with the shift key': t.desc21,
                'Achieve mastery over the complete keyboard': t.desc22,
                'All fingers, home row (unshifted)': t.desc23,
                'Complete keyboard including number row': t.desc24
            };

            return descMap[description] || description;
        }

        function updateLevelSelector() {
            const levelSelect = document.getElementById('levelSelect');

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            // Clear existing options
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            levelSelect.innerHTML = ``;

            // Add lesson options with names
            if (learnWords) {
                const maxLevel = Object.keys(learnWords).length;

                for (let i = 1; i <= maxLevel; i++) {
                    const levelData = learnWords[i];
                    if (levelData) {
                        const option = document.createElement('option');
                        option.value = i;
                        const translatedName = translateLessonName(levelData.name);
                        option.textContent = `${i}. ${translatedName}`;
                        levelSelect.appendChild(option);
                    }
                }
            }

            // Reset to level 1 if selected level is now unavailable
            const maxLevel = (currentLayout === 'imperial' && useLigatures) ? 7 : 6;
            if (parseInt(selectedLevel) > maxLevel) {
                selectedLevel = 1;
            }

            // Restore selected value
            levelSelect.value = selectedLevel;
        }

        // Get word pool and metadata for a play level
        function getPlayLevelData(levelNum) {
            let pool = [];
            let title = '';

            if (levelNum === 1) {
                pool = [...wordsByLength[1], ...wordsByLength[2]];
                title = '1-2 Letters';
            } else if (levelNum === 2) {
                pool = [...wordsByLength[2], ...wordsByLength[3]];
                title = '2-3 Letters';
            } else if (levelNum === 3) {
                pool = [...wordsByLength[3], ...wordsByLength[4]];
                title = '3-4 Letters';
            } else if (levelNum === 4) {
                pool = [...wordsByLength[4], ...wordsByLength[5], ...wordsByLength[6]];
                title = '4-6 Letters';
            } else if (levelNum === 5) {
                pool = [...wordsByLength[5], ...wordsByLength[6], ...wordsByLength[7]];
                title = '5+ Letters';
            } else if (levelNum === 6) {
                pool = [...wordsByLength[6], ...wordsByLength[7]];
                title = '6+ Letters';
            }

            return {
                wordPool: pool,
                wordCount: 5,
                title: title
            };
        }

        // Get word pool and metadata for a learn lesson
        function getLearnLessonData(lessonIndex) {
            let learnWords;

            if (currentLayout === 'imperial') {
                learnWords = useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'new-imperial') {
                learnWords = useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                learnWords = learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                learnWords = learnWords2layer;
            } else if (currentLayout === 'jafl') {
                learnWords = useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }

            const levelData = learnWords[lessonIndex];
            if (levelData && levelData.words) {
                const translatedName = translateLessonName(levelData.name);
                return {
                    wordPool: levelData.words,
                    wordCount: 10,
                    title: translatedName
                };
            }

            return null;
        }

        // Load words from JSON
        async function loadWords() {
            try {
                // Load practice words
                const wordsResponse = await fetch(`words_${currentDialect}.json`);
                const wordsData = await wordsResponse.json();
                // Convert string keys to numbers
                Object.keys(wordsData).forEach(key => {
                    wordsByLength[parseInt(key)] = wordsData[key];
                });

                // Load learn mode words for Imperial
                const learnImperialResponse = await fetch(`learn_words_imperial_${currentDialect}.json`);
                const learnImperialData = await learnImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialData).forEach(key => {
                    learnWordsImperial[parseInt(key)] = learnImperialData[key];
                });

                // Load learn mode words for QWERTY
                const learnQwertyResponse = await fetch(`learn_words_qwerty_${currentDialect}.json`);
                const learnQwertyData = await learnQwertyResponse.json();
                // Convert string keys to numbers
                Object.keys(learnQwertyData).forEach(key => {
                    learnWordsQwerty[parseInt(key)] = learnQwertyData[key];
                });

                // Load learn mode words for Imperial (no ligatures)
                const learnImperialNoLigResponse = await fetch(`learn_words_imperial_${currentDialect}_no_lig.json`);
                const learnImperialNoLigData = await learnImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialNoLigData).forEach(key => {
                    learnWordsImperialNoLig[parseInt(key)] = learnImperialNoLigData[key];
                });

                // Load learn mode words for New Imperial
                const learnNewImperialResponse = await fetch(`learn_words_new-imperial_${currentDialect}.json`);
                const learnNewImperialData = await learnNewImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialData).forEach(key => {
                    learnWordsNewImperial[parseInt(key)] = learnNewImperialData[key];
                });

                // Load learn mode words for New Imperial (no ligatures)
                const learnNewImperialNoLigResponse = await fetch(`learn_words_new-imperial_${currentDialect}_no_lig.json`);
                const learnNewImperialNoLigData = await learnNewImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialNoLigData).forEach(key => {
                    learnWordsNewImperialNoLig[parseInt(key)] = learnNewImperialNoLigData[key];
                });

                // Load learn mode words for Shaw 2-layer
                const learn2layerResponse = await fetch(`learn_words_2layer_${currentDialect}.json`);
                const learn2layerData = await learn2layerResponse.json();
                // Convert string keys to numbers
                Object.keys(learn2layerData).forEach(key => {
                    learnWords2layer[parseInt(key)] = learn2layerData[key];
                });

                // Load learn mode words for Shaw-JAFL (with ligatures)
                const learnJaflResponse = await fetch(`learn_words_jafl_${currentDialect}.json`);
                const learnJaflData = await learnJaflResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflData).forEach(key => {
                    learnWordsJafl[parseInt(key)] = learnJaflData[key];
                });

                // Load learn mode words for Shaw-JAFL (no ligatures)
                const learnJaflNoLigResponse = await fetch(`learn_words_jafl_${currentDialect}_no_lig.json`);
                const learnJaflNoLigData = await learnJaflNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflNoLigData).forEach(key => {
                    learnWordsJaflNoLig[parseInt(key)] = learnJaflNoLigData[key];
                });

                wordsLoaded = true;
                return true;
            } catch (error) {
                console.error('Failed to load words:', error);
                alert('Failed to load word list. Please refresh the page.');
                return false;
            }
        }

        // Initialize
        async function init() {
            await loadWords();
            if (wordsLoaded) {
                // Check if we should show welcome screen
                const hideWelcome = localStorage.getItem('hideWelcome');
                if (hideWelcome !== 'true') {
                    showWelcomeIfNeeded();
                }
                // Start on home screen - don't auto-load game
                // User will click Play or Practice to start
            }
        }

        // Countdown state
        let countdownTimeouts = [];
        let countdownCancelled = false;

        // Countdown animation before starting level
        function showCountdown(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            console.log('[showCountdown] CALLED - this should NOT happen on page load!');
            console.trace(); // Show the call stack

            // Clear any existing countdown
            cancelCountdown();
            countdownCancelled = false;

            const countdownScreen = document.getElementById('countdownScreen');
            const gameContent = document.getElementById('gameContent');
            const text = document.getElementById('countdownText');

            // Set instructions in subtitle
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            // Show countdown, hide game content
            countdownScreen.classList.remove('hidden');
            gameContent.classList.add('hidden');

            let count = 3;
            function updateCountdown() {
                if (countdownCancelled) return; // Stop if cancelled

                if (count > 0) {
                    text.textContent = count;
                    // Reset animation
                    text.style.animation = 'none';
                    const animTimeout = setTimeout(() => {
                        if (countdownCancelled) return;
                        text.style.animation = 'countdown-pulse 0.5s ease-in-out';
                    }, 10);
                    countdownTimeouts.push(animTimeout);
                    count--;
                    const nextTimeout = setTimeout(updateCountdown, 800);
                    countdownTimeouts.push(nextTimeout);
                } else {
                    // Hide countdown, show game content
                    countdownScreen.classList.add('hidden');
                    gameContent.classList.remove('hidden');
                    // Call startLevel with the parameters
                    startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback);
                }
            }

            updateCountdown();
        }

        function cancelCountdown() {
            countdownCancelled = true;
            countdownTimeouts.forEach(timeout => clearTimeout(timeout));
            countdownTimeouts = [];
        }

        // Start a new level/lesson with given word pool, count, and metadata
        function startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            console.log(`[startLevel] Starting ${type}: "${title}" (${wordCount} words from pool of ${wordPool.length})`);

            // Set level state
            currentLevelWordPool = wordPool;
            currentLevelWordCount = wordCount;
            currentLevelType = type;
            currentLevelTitle = title;
            currentLevelTypeLabel = typeLabel;
            currentLevelCompletionCallback = completionCallback;
            wordsInCurrentLevel = 0;
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            recentWords = [];

            // Initialize game (loads words)
            initializeGame();

            // Clear input and shadow
            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;

            // Start timer only for play mode at level 1 (beginning of game)
            if (currentMode === 'play' && currentLevelNumber === 1 && wordsCompleted === 0) {
                startTime = Date.now();
            }

            // Focus input
            typingInput.focus();
        }

        function pickRandomWord() {
            const pool = currentLevelWordPool;
            if (!pool || pool.length === 0) {
                console.error('No word pool available!');
                return '';
            }

            const historySize = Math.min(10, Math.floor(pool.length / 2));
            let newWord;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                newWord = pool[Math.floor(Math.random() * pool.length)];
                attempts++;
            } while (recentWords.includes(newWord) && attempts < maxAttempts);

            // Update recent words history
            recentWords.push(newWord);
            if (recentWords.length > historySize) {
                recentWords.shift();
            }

            return newWord;
        }

        function loadNewWord() {
            // Check if this is the last word of the level
            const isLastWordOfLevel = (wordsInCurrentLevel === currentLevelWordCount - 1);

            console.log(`[loadNewWord] wordsInCurrentLevel=${wordsInCurrentLevel}, wordCount=${currentLevelWordCount}, isLastWord=${isLastWordOfLevel}`);

            // BEFORE advancing: update the slot that will become "next" after rotation
            // The slot at prev-prev position will rotate to next position
            const prevPrevSlot = (carouselOffset - 2 + 4) % 4;
            const slot = wordSlots[prevPrevSlot];

            // For the last word of a level, put an empty string in the next slot
            const newWord = isLastWordOfLevel ? '' : pickRandomWord();
            words[prevPrevSlot] = newWord;

            console.log(`[loadNewWord] newWord="${newWord}", slot=${prevPrevSlot}`);

            if (newWord) {
                // Load a new word normally
                // Disable transitions for the new slot so it appears instantly
                slot.style.transition = 'none';

                // Form ligatures in the word if enabled (for display purposes)
                const displayWord = useLigatures ? formLigaturesInWord(newWord) : newWord;

                // Update the slot's HTML content so offsetWidth is accurate
                let html = '';
                const wordChars = Array.from(displayWord);
                for (let j = 0; j < wordChars.length; j++) {
                    html += `<span class="char">${wordChars[j]}</span>`;
                }
                slot.innerHTML = html;

                // Position it at next-next location (after current next word) BEFORE advancing
                // Calculate where next-next should be
                const currentSlotIndex = carouselOffset;
                const nextSlotIndex = (carouselOffset + 1) % 4;
                const carouselWidth = wordSlots[0].parentElement.clientWidth;
                const currentWidth = wordSlots[currentSlotIndex].offsetWidth;
                const nextWidth = wordSlots[nextSlotIndex].offsetWidth;
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Position the new slot at next-next location and make it visible
                slot.classList.remove('pos-prev-prev', 'pos-prev', 'pos-current', 'pos-next');
                slot.classList.add('pos-next-next');
                slot.style.transform = `translateX(${nextNextX}px) translateY(-50%)`;

                // Force reflow to apply the next-next position
                slot.offsetHeight;

                // Re-enable transitions so it can animate when repositioned
                slot.style.transition = '';
            } else {
                // Empty slot for after last word
                console.log('[loadNewWord] Last word - empty next slot');
                slot.innerHTML = '';
            }

            // NOW advance carousel
            carouselOffset = (carouselOffset + 1) % 4;

            // Get current word from carousel
            currentWord = words[carouselOffset];

            // If ligatures are enabled, form them in the expected word
            if (useLigatures) {
                currentWord = formLigaturesInWord(currentWord);
            }

            // Append space to currentWord if it's not the last word of the level
            if (!isLastWordOfLevel) {
                currentWord = currentWord + ' ';
            }

            // Store the processed word back (with ligatures if enabled, and space if needed)
            words[carouselOffset] = currentWord;

            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;
            updateWordDisplay();

            updateLevel();
        }

        function initializeGame() {
            console.log(`[initializeGame] wordPool length: ${currentLevelWordPool.length}, wordCount: ${currentLevelWordCount}`);
            // Reset carousel completely
            words = ['', '', '', ''];
            carouselOffset = 2; // Will advance to 3, then 0
            // Run the cycle twice to load first two words
            loadNewWord(); // Loads first word, advances to offset 3
            loadNewWord(); // Loads second word, advances to offset 0 (current)
        }

        function advanceToNextWord() {
            // Just call loadNewWord - carousel positions will update via CSS transitions
            loadNewWord();
        }

        function updateLevel() {
            // Display the current level/lesson number
            levelDisplayEl.textContent = currentLevelNumber;
        }

        // Calculate appropriate font size based on max word length
        function getFontSizeForMaxLength(maxLength) {
            const baseFontSize = 48;
            // Reduce font size as max length increases: 48px for short words, down to 24px for very long
            if (maxLength <= 4) return baseFontSize;
            if (maxLength <= 6) return 42;
            if (maxLength <= 8) return 36;
            if (maxLength <= 10) return 30;
            return 24;
        }

        function updateWordDisplay() {
            const userInput = typingInput.value;

            // Calculate max word length in current pool for font sizing
            let maxWordLength = 4;
            if (currentLevelWordPool && currentLevelWordPool.length > 0) {
                maxWordLength = Math.max(...currentLevelWordPool.map(w => Array.from(w).length));
            }
            const fontSize = getFontSizeForMaxLength(maxWordLength);

            // Update each carousel slot
            for (let i = 0; i < 4; i++) {
                const slot = wordSlots[i];
                const word = words[i];

                // Calculate position relative to current
                const posOffset = (i - carouselOffset + 4) % 4;

                // Remove old position classes
                slot.className = 'word-slot slot-' + i;

                // Set font size based on max word length
                slot.style.fontSize = fontSize + 'px';

                // Add appropriate position class
                if (posOffset === 0) {
                    // Current word
                    slot.classList.add('pos-current');

                    // Build HTML with coloring for current word
                    let html = '';
                    const wordChars = Array.from(currentWord);
                    const inputChars = Array.from(userInput);
                    const isPending = isPendingLigatureStart(inputChars, wordChars);

                    for (let j = 0; j < wordChars.length; j++) {
                        const char = wordChars[j];
                        let className = '';

                        if (j < inputChars.length) {
                            // User has typed this position
                            if (inputChars[j] === char) {
                                className = 'correct';
                            } else if (isPending && j === inputChars.length - 1) {
                                // Waiting for ligature completion - don't mark as wrong yet
                                className = '';
                            } else {
                                className = 'incorrect';
                            }
                        }
                        // else: not typed yet, no className

                        html += `<span class="char ${className}">${char}</span>`;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 1) {
                    // Next word
                    slot.classList.add('pos-next');
                    const displayWord = (useLigatures && word) ? formLigaturesInWord(word) : (word || '');
                    let html = '';
                    const wordChars = Array.from(displayWord);
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 3) {
                    // Previous word (already has ligatures formed when it was current)
                    slot.classList.add('pos-prev');
                    let html = '';
                    const wordChars = Array.from(word || '');
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else {
                    // Previous-previous word (off screen)
                    slot.classList.add('pos-prev-prev');
                    slot.innerHTML = '';
                }
            }

            // Calculate positions based on actual widths
            // Wait for next frame to ensure content is rendered
            requestAnimationFrame(() => {
                const carouselWidth = wordSlots[0].parentElement.clientWidth;

                // Find which slot is at each position
                let currentSlot = -1, prevSlot = -1, nextSlot = -1, nextNextSlot = -1;
                for (let i = 0; i < 4; i++) {
                    const posOffset = (i - carouselOffset + 4) % 4;
                    if (posOffset === 0) currentSlot = i;
                    else if (posOffset === 1) nextSlot = i;
                    else if (posOffset === 2) nextNextSlot = i;
                    else if (posOffset === 3) prevSlot = i;
                }

                // Get widths
                const currentWidth = wordSlots[currentSlot].offsetWidth;
                const prevWidth = prevSlot >= 0 ? wordSlots[prevSlot].offsetWidth : 0;
                const nextWidth = nextSlot >= 0 ? wordSlots[nextSlot].offsetWidth : 0;

                // Calculate positions - center current word, position others relative to it
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const prevX = currentX - prevWidth;
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Apply transforms (include translateY for vertical centering)
                wordSlots[currentSlot].style.transform = `translateX(${currentX}px) translateY(-50%)`;
                if (prevSlot >= 0) wordSlots[prevSlot].style.transform = `translateX(${prevX}px) translateY(-50%)`;
                if (nextSlot >= 0) wordSlots[nextSlot].style.transform = `translateX(${nextX}px) translateY(-50%)`;
                if (nextNextSlot >= 0) wordSlots[nextNextSlot].style.transform = `translateX(${nextNextX}px) translateY(-50%)`;
            });
        }

        function updateStats() {
            wordCountEl.textContent = wordsCompleted;
            const accuracy = totalLettersTyped === 0 ? 100 : ((correctLetters / totalLettersTyped) * 100).toFixed(1);
            accuracyEl.textContent = accuracy + '%';
        }

        function checkCompletion() {
            const userInput = typingInput.value;

            // Check if user typed the complete word correctly
            if (userInput === currentWord) {
                // Word completed correctly
                wordsCompleted++;
                wordsInCurrentLevel++;
                console.log(`[checkCompletion] Word ${wordsInCurrentLevel} of level completed (total: ${wordsCompleted})`);
                updateStats();

                // After first word, update subtitle with level/lesson info
                if (wordsCompleted === 1) {
                    document.getElementById('mainSubtitle').textContent =
                        `${currentLevelTypeLabel} ${currentLevelNumber}: ${currentLevelTitle}`;
                }

                // Check if level is complete
                if (wordsInCurrentLevel === currentLevelWordCount) {
                    // Level completed - transition to next level
                    console.log(`[checkCompletion] ${currentLevelType.toUpperCase()} COMPLETED`);
                    transitionToNextLevel();
                } else {
                    // Advance to next word
                    advanceToNextWord();
                }
            }
        }

        function transitionToNextLevel() {
            console.log('[transitionToNextLevel] Starting transition');

            // Save stats for completed level
            const finalLevelAccuracy = currentLevelLettersTyped === 0 ? 100.0 :
                ((currentLevelCorrectLetters / currentLevelLettersTyped) * 100);
            levelStats.push({
                level: currentLevelNumber,
                accuracy: finalLevelAccuracy,
                lettersTyped: currentLevelLettersTyped,
                correctLetters: currentLevelCorrectLetters
            });

            // If there's a completion callback, use it
            if (currentLevelCompletionCallback) {
                console.log('[transitionToNextLevel] Calling completion callback');
                currentLevelCompletionCallback();
                return;
            }

            // Default behavior: try to advance to next level
            console.log(`[transitionToNextLevel] Mode: ${currentMode}, Current level: ${currentLevelNumber}`);
            let nextLevelData = null;
            if (currentMode === 'learn') {
                const nextLessonIndex = parseInt(selectedLevel) + 1;
                nextLevelData = getLearnLessonData(nextLessonIndex);
                if (nextLevelData) {
                    selectedLevel = nextLessonIndex.toString();
                    currentLevelNumber = nextLessonIndex;
                }
            } else {
                const nextLevelNum = currentLevelNumber + 1;
                console.log(`[transitionToNextLevel] Next level num: ${nextLevelNum}`);
                if (nextLevelNum <= 6) {
                    nextLevelData = getPlayLevelData(nextLevelNum);
                    currentLevelNumber = nextLevelNum;
                    console.log(`[transitionToNextLevel] Got next level data for level ${nextLevelNum}`);
                } else {
                    console.log(`[transitionToNextLevel] No more levels (${nextLevelNum} > 6)`);
                }
            }

            console.log(`[transitionToNextLevel] nextLevelData is ${nextLevelData ? 'not null' : 'null'}`);
            if (nextLevelData) {
                // Start new level with new words (no countdown between levels!)
                const lang = useShavianUI ? 'shavian' : 'latin';
                const t = translations[lang];
                const type = currentMode === 'learn' ? 'lesson' : 'level';
                const typeLabel = type === 'lesson' ? t.lesson_label : t.level_label;

                // Set instructions in subtitle for practice mode
                if (type === 'lesson') {
                    document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                }

                // Just start the level directly (both play and practice)
                startLevel(nextLevelData.wordPool, nextLevelData.wordCount, type, nextLevelData.title, typeLabel, currentLevelCompletionCallback);
            } else {
                // No more levels/lessons - show completion modal
                console.log('[transitionToNextLevel] Calling showCompletionModal');
                showCompletionModal();
            }
        }

        function showLessonCompletionDialog() {
            console.log('[showLessonCompletionDialog] Lesson completed');

            // Calculate stats for this lesson
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Set modal content for lesson completion
            document.getElementById('completionTitle').textContent = 'Lesson Complete!';
            document.getElementById('completionMessage').textContent = `You completed ${wordsCompleted} words!`;

            // Hide game-specific stats
            document.getElementById('finalScore').style.display = 'none';
            document.getElementById('finalWPM').parentElement.style.display = 'none';
            document.getElementById('finalLPM').parentElement.style.display = 'none';
            document.getElementById('bestTimeRow').style.display = 'none';
            document.getElementById('levelReachedRow').style.display = 'none';
            document.getElementById('levelStatsContainer').style.display = 'none';

            // Show accuracy
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';

            // Show lesson completion buttons
            const learnWords = getLearnWords();
            const maxLesson = learnWords ? Object.keys(learnWords).length : 6;
            const hasNextLesson = parseInt(selectedLevel) < maxLesson;

            document.getElementById('completionButtons').innerHTML = `
                <button onclick="continueLesson()">Keep practicing this lesson</button>
                ${hasNextLesson ? '<button onclick="nextLesson()" style="margin-left: 10px;">Next lesson</button>' : ''}
                <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
            `;

            document.getElementById('completionModal').classList.add('show');
        }

        function showCompletionModal() {
            console.log('[showCompletionModal] Called');
            // Stats already saved in transitionToNextLevel
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Calculate time-based metrics
            const endTime = Date.now();
            const elapsedSeconds = (endTime - startTime) / 1000;
            const elapsedMinutes = elapsedSeconds / 60;
            const wpm = wordsCompleted / elapsedMinutes;
            const lettersPerMinute = totalLettersTyped / elapsedMinutes;

            // Format time as MM:SS
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = Math.floor(elapsedSeconds % 60);
            const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update best time if current time is better (lower)
            const isNewBest = bestTime === null || elapsedSeconds < bestTime;
            if (isNewBest) {
                bestTime = elapsedSeconds;
                localStorage.setItem('bestTime', bestTime.toString());
            }

            // Customize modal based on mode
            if (currentMode === 'learn') {
                document.getElementById('completionTitle').textContent = 'Session Complete!';
                document.getElementById('completionMessage').textContent = 'You completed 10 words!';
                document.getElementById('levelReachedRow').style.display = 'none';
                document.getElementById('levelStatsContainer').style.display = 'none';

                // Show buttons for continue or choose lesson
                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="continueLesson()">Continue</button>
                    <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
                `;
            } else {
                document.getElementById('completionTitle').textContent = 'Congratulations!';
                document.getElementById('completionMessage').textContent = `You completed ${wordsCompleted} words!`;
                document.getElementById('levelReachedRow').style.display = 'block';
                document.getElementById('levelStatsContainer').style.display = 'block';

                document.getElementById('finalLevel').textContent = currentLevelNumber;

                // Generate per-level stats HTML
                const lang = useShavianUI ? 'shavian' : 'latin';
                const t = translations[lang];
                let levelStatsHTML = '';
                levelStats.forEach(stat => {
                    const levelAccuracyFormatted = stat.accuracy.toFixed(1);
                    const levelLabel = currentMode === 'learn' ? t.lesson_label : t.level_label;
                    levelStatsHTML += `<div class="level-stat">${levelLabel} ${stat.level}: ${levelAccuracyFormatted}%</div>`;
                });
                document.getElementById('levelStatsContainer').innerHTML = levelStatsHTML;

                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="playAgain()">Play Again</button>
                `;
            }

            // Update main display (time is the primary score)
            document.getElementById('finalScore').textContent = timeFormatted;
            document.getElementById('finalScore').style.display = 'block';

            // Update all stat rows and show them for play mode
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';
            document.getElementById('finalWPM').textContent = wpm.toFixed(1);
            document.getElementById('finalWPM').parentElement.style.display = 'block';
            document.getElementById('finalLPM').textContent = lettersPerMinute.toFixed(0);
            document.getElementById('finalLPM').parentElement.style.display = 'block';

            // Show/hide best time indicator and display best time
            if (isNewBest && bestTime !== null) {
                document.getElementById('bestTimeRow').innerHTML = `<span style="color: #28a745; font-weight: bold;">New Personal Best!</span>`;
            } else if (bestTime !== null) {
                const bestMinutes = Math.floor(bestTime / 60);
                const bestSeconds = Math.floor(bestTime % 60);
                const bestTimeFormatted = `${bestMinutes}:${bestSeconds.toString().padStart(2, '0')}`;
                document.getElementById('bestTimeRow').innerHTML = `Personal Best: ${bestTimeFormatted}`;
            } else {
                document.getElementById('bestTimeRow').innerHTML = '';
            }

            document.getElementById('completionModal').classList.add('show');
        }

        function resetPractice() {
            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();
            updateLevel();

            // Start first level
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            if (currentMode === 'play') {
                const levelData = getPlayLevelData(1);
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                startLevel(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
            } else {
                // In learn mode, use the selected lesson
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;

                const levelData = getLearnLessonData(parseInt(selectedLevel));
                if (levelData) {
                    currentLevelNumber = parseInt(selectedLevel);
                    startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
                }
            }
        }

        function continueLesson() {
            // Reset session stats but keep same lesson
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();

            // Restart current level/lesson with same word pool
            startLevel(currentLevelWordPool, currentLevelWordCount, currentLevelType, currentLevelTitle, currentLevelTypeLabel, currentLevelCompletionCallback);
            typingInput.focus();
        }

        function nextLesson() {
            // Advance to next lesson
            const nextLessonNum = parseInt(selectedLevel) + 1;
            const learnWords = getLearnWords();
            const maxLesson = learnWords ? Object.keys(learnWords).length : 6;

            if (nextLessonNum <= maxLesson) {
                selectedLevel = nextLessonNum.toString();

                // Hide modal
                document.getElementById('completionModal').classList.remove('show');

                // Reset session stats
                wordsCompleted = 0;
                totalLettersTyped = 0;
                correctLetters = 0;
                recentWords = [];
                currentLevelLettersTyped = 0;
                currentLevelCorrectLetters = 0;
                updateStats();

                // Start next lesson
                const lang = useShavianUI ? 'shavian' : 'latin';
                const t = translations[lang];
                const levelData = getLearnLessonData(nextLessonNum);
                if (levelData) {
                    currentLevelNumber = nextLessonNum;
                    startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
                    typingInput.focus();
                }
            }
        }

        function chooseDifferentLesson() {
            // Hide completion modal
            document.getElementById('completionModal').classList.remove('show');

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            recentWords = [];
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            updateStats();

            // Open lesson selector
            openLessonSelector();
        }

        // Debug flag - set in console for testing
        window.debugTyping = false;

        // Expose settings for console access (for quick testing)
        window.setWordCount = function(n) { currentLevelWordCount = n; };
        window.getWordCount = function() { return currentLevelWordCount; };
        window.setLevel = function(n) { currentLevelNumber = n; };
        window.getLevel = function() { return currentLevelNumber; };
        window.setNextWord = function(word) {
            // Set the next word (in slot after current)
            const nextSlot = (carouselOffset + 1) % 4;
            words[nextSlot] = word;

            // Temporarily modify word pool to include this word at max length for font sizing test
            const wordLength = Array.from(word).length;
            const tempPool = [...(currentLevelWordPool || []), word];
            currentLevelWordPool = tempPool;

            // Update display to show the word and apply font sizing
            updateWordDisplay();

            console.log(`Next word set to: "${word}" (length: ${wordLength})`);
            console.log(`Font size will be: ${getFontSizeForMaxLength(wordLength)}px`);
        };

        // Event listeners
        let previousInput = '';  // For error state reversion
        let maxEffectiveLength = 0;  // High water mark for counting (excludes pending ligature starts)
        let isInErrorState = false; // Track if last typed character was incorrect

        // Helper: Convert string to array of Unicode code points for debugging
        function toCodePoints(str) {
            return Array.from(str).map(c =>
                'U+' + c.codePointAt(0).toString(16).toUpperCase().padStart(4, '0')
            ).join(' ');
        }

        // Helper: Form ligatures in input string if enabled
        function formLigatures(input) {
            if (!useLigatures) return input;
            const chars = Array.from(input);

            // Check if last 2 characters form a ligature
            if (chars.length >= 2) {
                const lastTwo = chars[chars.length - 2] + chars[chars.length - 1];
                if (COMPONENT_TO_LIGATURE[lastTwo]) {
                    return chars.slice(0, -2).join('') + COMPONENT_TO_LIGATURE[lastTwo];
                }
            }

            return input;
        }

        // Helper: Check if last character is a pending ligature start
        function isPendingLigatureStart(inputChars, wordChars) {
            if (!useLigatures || inputChars.length === 0) return false;

            const lastIdx = inputChars.length - 1;
            if (lastIdx >= wordChars.length) return false;

            const expectedChar = wordChars[lastIdx];
            const lastChar = inputChars[lastIdx];

            // Check if the last character is the first of any pair that forms the expected ligature
            if (LIGATURES[expectedChar]) {
                return LIGATURES[expectedChar].some(pair => pair[0] === lastChar);
            }

            return false;
        }

        // Helper: Update shadow input based on InputEvent
        // Returns the updated shadow input string
        // browserValue is what the browser's input field currently shows (after the event)
        function updateShadowInput(inputType, eventData, currentShadow, browserValue) {
            switch (inputType) {
                case 'insertText':
                    // Normal typing - append what was actually typed (preserves VS1)
                    return currentShadow + (eventData || '');

                case 'deleteContentBackward':
                    // Backspace - remove last character
                    const chars = Array.from(currentShadow);
                    return chars.slice(0, -1).join('');

                case 'deleteContentForward':
                    // Delete key - remove first character (shouldn't happen in our UI)
                    const charsForward = Array.from(currentShadow);
                    return charsForward.slice(1).join('');

                case 'insertReplacementText':
                    // Safari uses this for ligature formation from virtual keyboard
                    // Use the replacement range captured from beforeinput event
                    if (pendingReplacementStart >= 0 && pendingReplacementEnd >= 0) {
                        const chars = Array.from(currentShadow);
                        const before = chars.slice(0, pendingReplacementStart).join('');
                        const after = chars.slice(pendingReplacementEnd).join('');
                        const result = before + (eventData || '') + after;
                        // Reset pending replacement
                        pendingReplacementStart = -1;
                        pendingReplacementEnd = -1;
                        return result;
                    }
                    // Fallback if we didn't capture the range
                    return browserValue;

                case 'insertFromPaste':
                case 'insertFromDrop':
                    // Paste or drop - replace entire content
                    return eventData || browserValue;

                case 'deleteWordBackward':
                case 'deleteWordForward':
                case 'deleteByCut':
                    // Word deletion or cut - use browser's resulting value
                    return browserValue;

                case 'insertCompositionText':
                    // IME composition - trust browser value
                    return browserValue;

                default:
                    // Unknown or null inputType - trust browser value
                    return browserValue;
            }
        }

        // Helper: Update statistics based on new input length
        function updateInputStatistics(effectiveLength, inputChars, wordChars) {
            if (effectiveLength < maxEffectiveLength) {
                // Backspace or deletion - clear error state
                isInErrorState = false;
                maxEffectiveLength = effectiveLength;
            } else if (isInErrorState && effectiveLength > maxEffectiveLength) {
                // Blocked - user is in error state, revert not handled here
                return 'blocked';
            } else if (effectiveLength > maxEffectiveLength) {
                // New characters to count
                const numNew = effectiveLength - maxEffectiveLength;
                totalLettersTyped += numNew;
                currentLevelLettersTyped += numNew;

                // Check correctness
                let allCorrect = true;
                for (let i = maxEffectiveLength; i < effectiveLength; i++) {
                    if (i >= wordChars.length || inputChars[i] !== wordChars[i]) {
                        allCorrect = false;
                        break;
                    }
                }

                if (allCorrect) {
                    correctLetters += numNew;
                    currentLevelCorrectLetters += numNew;
                    isInErrorState = false;
                } else {
                    isInErrorState = true;
                }

                maxEffectiveLength = effectiveLength;
            }
            return 'ok';
        }

        // Helper: Convert UTF-16 code unit position to character index
        function codeUnitPosToCharIndex(str, codeUnitPos) {
            let charIndex = 0;
            let codeUnitIndex = 0;
            for (const char of str) {
                if (codeUnitIndex >= codeUnitPos) break;
                codeUnitIndex += char.length; // Shavian chars are 2 code units
                charIndex++;
            }
            return charIndex;
        }

        // Capture target ranges before input is processed (for insertReplacementText)
        typingInput.addEventListener('beforeinput', (e) => {
            if (e.inputType === 'insertReplacementText') {
                // Get the selection/range being replaced (in UTF-16 code units)
                const startCodeUnit = typingInput.selectionStart;
                const endCodeUnit = typingInput.selectionEnd;

                // Convert to character positions for shadow input
                const currentValue = typingInput.value;
                pendingReplacementStart = codeUnitPosToCharIndex(currentValue, startCodeUnit);
                pendingReplacementEnd = codeUnitPosToCharIndex(currentValue, endCodeUnit);

                if (debugMode) {
                    console.log('üîç BEFOREINPUT: replacing code units ' + startCodeUnit + '-' + endCodeUnit +
                               ' (chars ' + pendingReplacementStart + '-' + pendingReplacementEnd + ')' +
                               ' with "' + (e.data || '') + '" [' + toCodePoints(e.data || '') + ']');
                }
            }
        });

        typingInput.addEventListener('input', (e) => {
            const browserInput = e.target.value;
            const eventData = e.data || '';

            // Update shadow input based on what was actually typed
            shadowInput = updateShadowInput(e.inputType, eventData, shadowInput, browserInput);

            // Debug: log raw input with Unicode code points
            if (debugMode) {
                console.log('üì• INPUT: browser="' + browserInput + '" [' + toCodePoints(browserInput) + ']' +
                           ' | inputType=' + e.inputType +
                           ' | event.data="' + eventData + '" [' + toCodePoints(eventData) + ']' +
                           ' | shadow="' + shadowInput + '" [' + toCodePoints(shadowInput) + ']' +
                           ' | expected="' + currentWord + '" [' + toCodePoints(currentWord) + ']');
            }

            // Use shadow input as source of truth
            let userInput = shadowInput;

            // Ignore leading spaces at the start of the level
            if (maxEffectiveLength === 0 && userInput.trim() === '') {
                shadowInput = '';
                typingInput.value = '';
                return;
            }

            // Form ligatures if enabled (for keyboards that don't do it themselves)
            userInput = formLigatures(userInput);

            // Update both shadow and display to match formed ligatures
            shadowInput = userInput;
            typingInput.value = userInput;

            // Get character arrays for comparison
            const inputChars = Array.from(userInput);
            const wordChars = Array.from(currentWord);

            // Calculate effective length (excludes pending ligature start)
            const pendingLigature = isPendingLigatureStart(inputChars, wordChars);
            const effectiveLength = pendingLigature ? inputChars.length - 1 : inputChars.length;

            // Update statistics and handle blocked input
            const result = updateInputStatistics(effectiveLength, inputChars, wordChars);
            if (result === 'blocked') {
                // Revert input and flash red
                typingInput.value = previousInput;
                typingInput.style.animation = 'none';
                setTimeout(() => {
                    typingInput.style.animation = 'error-flash 0.4s ease-out';
                }, 10);
            } else {
                previousInput = typingInput.value;
            }

            // Debug: log final state
            if (debugMode) {
                console.log('üìä POSTCONDITION: input=' + JSON.stringify(typingInput.value) +
                           ', correct=' + correctLetters + '/' + totalLettersTyped +
                           ', maxEffectiveLength=' + maxEffectiveLength +
                           ', isInErrorState=' + isInErrorState);
            }

            updateWordDisplay();
            updateStats();
            checkCompletion();
        });

        // No need for separate keydown handler - space is part of the word now
        // Auto-advance happens in checkCompletion when word+space is typed

        // Burger menu functions
        function toggleBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.toggle('show');
        }

        function closeBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.remove('show');
        }

        // Close burger menu if clicking outside
        window.addEventListener('click', function(e) {
            if (!e.target.matches('.burger-btn') && !e.target.closest('.burger-menu')) {
                closeBurgerMenu();
            }
        });

        // Content modal functions
        async function openContentModal(page) {
            closeBurgerMenu();

            const modal = document.getElementById('contentModal');
            const titleEl = document.getElementById('contentModalTitle');
            const bodyEl = document.getElementById('contentModalBody');

            // Set title using translations
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const titleKey = 'title' + page.charAt(0).toUpperCase() + page.slice(1);
            titleEl.textContent = t[titleKey] || page.charAt(0).toUpperCase() + page.slice(1);
            bodyEl.innerHTML = 'Loading...';

            // Show modal
            modal.classList.add('show');

            // Load content based on current language
            const filename = `${page}_${lang}.html`;

            try {
                const response = await fetch(filename);
                if (response.ok) {
                    const html = await response.text();
                    bodyEl.innerHTML = html;
                } else {
                    bodyEl.innerHTML = '<p>Content not found.</p>';
                }
            } catch (error) {
                bodyEl.innerHTML = '<p>Error loading content.</p>';
                console.error('Error loading content:', error);
            }
        }

        function closeContentModal() {
            document.getElementById('contentModal').classList.remove('show');
        }

        // Welcome modal functions
        function onDialectChangeWelcome() {
            const selected = document.querySelector('input[name="dialectWelcome"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    initializeGame();
                });
            }
        }

        function onLayoutChangeWelcome() {
            currentLayout = document.getElementById('layoutSelectWelcome').value;
            localStorage.setItem('keyboardLayout', currentLayout);

            // Show/hide ligature toggle
            const supportsLigatures = currentLayout === 'imperial' || currentLayout === 'new-imperial' || currentLayout === 'qwerty' || currentLayout === 'jafl';
            document.getElementById('ligatureWelcomeOption').style.display = supportsLigatures ? 'block' : 'none';
        }

        function onLigatureToggleWelcome() {
            useLigatures = document.getElementById('ligatureToggleWelcome').checked;
            localStorage.setItem('useLigatures', useLigatures);
        }

        function toggleShavianUIWelcome() {
            useShavianUI = document.getElementById('shavianUIToggleWelcome').checked;
            localStorage.setItem('useShavianUI', useShavianUI);
            updateWelcomeLanguage();
        }

        function updateWelcomeLanguage() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            // TODO: Add Shavian translations for welcome screen
            if (useShavianUI) {
                document.getElementById('welcomeTitle').textContent = 'êë¢êëßêë§êëíêë≥êë• êëë ¬∑êëñêë∑ êëëêë≤êëê!';
                document.getElementById('welcomeSubtitle').textContent = 'êëóêëµêëü êëòêëπ êëêêëÆêëßêëìêëºêë©êëØêëïêë©êëü êëë êëúêëßêëë êëïêëëêë∏êëëêë©êëõ:';
                document.getElementById('welcomeDialectLabel').textContent = 'êëóêëµêëü êëïêëêêëßêë§êë¶êëô';
                document.getElementById('welcomeDialectBritish').textContent = 'êëöêëÆêë¶êëëêë¶êëñ';
                document.getElementById('welcomeDialectAmerican').textContent = 'êë©êë•êëßêëÆêë¶êëíêë©êëØ';
                document.getElementById('welcomeLayoutLabel').textContent = 'êëíêë∞êëöêë™êëÆêëõ êë§êë±êë¨êëë';
                document.getElementById('welcomeLigatureLabel').textContent = 'êë∑êëëêë©êë•êë®êëëêë¶êëí êë§êë¶êëúêë©êëóêëºêëü (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)';
                document.getElementById('welcomeShavianUILabel').textContent = 'êëõêë¶êëïêëêêë§êë± UI êë¶êëØ ¬∑êëñêë±êëùêëæêëØ';
                document.getElementById('welcomeStartButton').textContent = 'êëïêëëêë∏êëë';
            } else {
                document.getElementById('welcomeTitle').textContent = 'Welcome to Shaw Type!';
                document.getElementById('welcomeSubtitle').textContent = 'Choose your preferences to get started:';
                document.getElementById('welcomeDialectLabel').textContent = 'Choose spelling';
                document.getElementById('welcomeDialectBritish').textContent = 'British';
                document.getElementById('welcomeDialectAmerican').textContent = 'American';
                document.getElementById('welcomeLayoutLabel').textContent = 'Keyboard Layout';
                document.getElementById('welcomeLigatureLabel').textContent = 'Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)';
                document.getElementById('welcomeShavianUILabel').textContent = 'Display UI in Shavian';
                document.getElementById('welcomeStartButton').textContent = 'Start';
            }
        }

        function closeWelcomeModal() {
            document.getElementById('welcomeModal').classList.remove('show');
            // Just set the mode preference, don't start a game
            currentMode = 'play';
            localStorage.setItem('currentMode', currentMode);
            // User will click Play or Practice button to actually start
        }

        function showWelcomeIfNeeded() {
            const hideWelcome = localStorage.getItem('hideWelcome');
            if (hideWelcome !== 'true') {
                // Sync welcome modal with current settings
                const dialectRadio = document.querySelector(`input[name="dialectWelcome"][value="${currentDialect}"]`);
                if (dialectRadio) dialectRadio.checked = true;

                document.getElementById('layoutSelectWelcome').value = currentLayout;
                document.getElementById('ligatureToggleWelcome').checked = useLigatures;
                document.getElementById('shavianUIToggleWelcome').checked = useShavianUI;

                // Show/hide ligature option
                const supportsLigatures = currentLayout === 'imperial' || currentLayout === 'new-imperial' || currentLayout === 'qwerty' || currentLayout === 'jafl';
                document.getElementById('ligatureWelcomeOption').style.display = supportsLigatures ? 'block' : 'none';

                // Update welcome language
                updateWelcomeLanguage();

                document.getElementById('welcomeModal').classList.add('show');
            }
        }

        function toggleHideWelcome() {
            const hideWelcome = document.getElementById('hideWelcomeToggle').checked;
            localStorage.setItem('hideWelcome', hideWelcome.toString());
        }

        // Settings functions
        function openSettings() {
            // Sync settings with current state
            const dialectRadio = document.querySelector(`input[name="dialectSettings"][value="${currentDialect}"]`);
            if (dialectRadio) dialectRadio.checked = true;

            document.getElementById('layoutSelectSettings').value = currentLayout;
            document.getElementById('ligatureToggleSettings').checked = useLigatures;

            // Sync hide welcome checkbox
            const hideWelcome = localStorage.getItem('hideWelcome');
            document.getElementById('hideWelcomeToggle').checked = (hideWelcome === 'true');

            // Show/hide ligature option based on current layout
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'new-imperial' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';

            document.getElementById('settingsModal').classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        // Lesson selector functions
        function openLessonSelector() {
            // Get current translations
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            const lessonList = document.getElementById('lessonList');
            lessonList.innerHTML = '';

            // Dynamically determine max level from actual data
            const maxLevel = learnWords ? Object.keys(learnWords).length : 6;

            // Add lesson options
            for (let i = 1; i <= maxLevel; i++) {
                const levelData = learnWords[i];

                if (levelData) {
                    const lessonBtn = document.createElement('div');
                    lessonBtn.className = 'lesson-option';
                    const translatedName = translateLessonName(levelData.name);
                    const translatedDescription = translateLessonDescription(levelData.description);
                    lessonBtn.innerHTML = `
                        <strong>${t.lessonPrefix} ${i}: ${translatedName}</strong>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #888;">${translatedDescription}</p>
                    `;
                    lessonBtn.onclick = () => selectLesson(i);
                    if (selectedLevel == i) {
                        lessonBtn.style.background = '#f0f0ff';
                    }
                    lessonList.appendChild(lessonBtn);
                }
            }

            document.getElementById('lessonModal').classList.add('show');
        }

        function selectLesson(level) {
            selectedLevel = level;
            closeLessonModal();

            // Show game content
            showGameContent();

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            levelStats = [];

            updateStats();

            // Start the selected lesson
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Set instructions in subtitle
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            const levelData = getLearnLessonData(parseInt(level));
            if (levelData) {
                currentLevelNumber = parseInt(level);
                startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
            }
        }

        function closeLessonModal() {
            document.getElementById('lessonModal').classList.remove('show');
        }

        function toggleShavianUI() {
            useShavianUI = document.getElementById('shavianUIToggle').checked;
            localStorage.setItem('useShavianUI', useShavianUI);
            updateUILanguage();
        }

        function updateUILanguage() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Update title
            document.getElementById('mainTitle').textContent = t.title;

            // Update subtitle based on current state
            const subtitle = document.getElementById('mainSubtitle');
            const homeScreen = document.getElementById('homeScreen');
            if (!homeScreen.classList.contains('hidden')) {
                // On home screen, show default subtitle
                subtitle.textContent = t.subtitle;
            } else {
                // In game, subtitle is managed by game logic
                updateSubtitleForGame();
            }

            // Update home screen buttons
            document.getElementById('homePlayBtn').textContent = t.play;
            document.getElementById('homePracticeBtn').textContent = t.practice;
            document.getElementById('homeSettingsBtn').textContent = t.settings;

            // Update stats labels
            document.querySelector('.stat-label').textContent =
                currentMode === 'learn' ? t.lesson_label : t.level_label;
            document.querySelectorAll('.stat-label')[1].textContent = t.words;
            document.querySelectorAll('.stat-label')[2].textContent = t.accuracy;

            // Update completion modal
            document.querySelector('#completionModal h2').textContent = t.congratulations;
            document.querySelector('#completionModal p').textContent = t.completed30;
            document.querySelectorAll('.stat-row')[0].childNodes[0].textContent = t.wpm + ' ';
            document.querySelectorAll('.stat-row')[1].childNodes[0].textContent = t.lettersPerMin + ' ';
            document.querySelectorAll('.stat-row')[2].childNodes[0].textContent = t.accuracy_final + ' ';
            document.querySelectorAll('.stat-row')[4].childNodes[0].textContent = t.levelReached + ' ';
            document.querySelector('#completionModal button').textContent = t.practiceAgain;

            // Update settings modal
            document.querySelector('#settingsModal h2').textContent = t.settingsTitle;
            document.querySelector('#shavianUIToggle + span').textContent = t.displayShavian;
            document.querySelector('.settings-option-desc').textContent = t.displayShavianDesc;

            // Update settings labels
            document.querySelector('.settings-option label').textContent = t.keyboardLayout;
            document.querySelector('#ligatureToggleSettings + span').textContent = t.ligatures;

            // Update lesson modal
            document.getElementById('lessonModalTitle').textContent = t.lessonModalTitle;
            document.getElementById('lessonModalSubtitle').textContent = t.lessonModalSubtitle;

            // Update burger menu items
            document.getElementById('menuAbout').textContent = t.menuAbout;
            document.getElementById('menuKeyboards').textContent = t.menuKeyboards;
            document.getElementById('menuResources').textContent = t.menuResources;
            document.getElementById('menuSettings').textContent = t.menuSettings;

            // Update settings dialog labels
            document.getElementById('settingsDialectLabel').textContent = t.dialectLabel;
            document.getElementById('settingsDialectBritish').textContent = t.dialectBritish;
            document.getElementById('settingsDialectAmerican').textContent = t.dialectAmerican;
            document.getElementById('settingsHideWelcome').textContent = t.hideWelcome;

            // Update layout select options
            updateLayoutSelectOptions();
        }

        function updateLayoutSelectOptions() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Update both layout selects (settings and welcome)
            const selects = [
                document.getElementById('layoutSelectSettings'),
                document.getElementById('layoutSelectWelcome')
            ];

            selects.forEach(select => {
                if (select) {
                    const currentValue = select.value;
                    const options = select.querySelectorAll('option');

                    options.forEach(option => {
                        const value = option.value;
                        switch(value) {
                            case 'imperial':
                                option.textContent = t.layoutImperial;
                                break;
                            case 'new-imperial':
                                option.textContent = t.layoutNewImperial;
                                break;
                            case 'qwerty':
                                option.textContent = t.layoutQwerty;
                                break;
                            case '2layer':
                                option.textContent = t.layout2layer;
                                break;
                            case 'jafl':
                                option.textContent = t.layoutJafl;
                                break;
                        }
                    });

                    // Restore selected value
                    select.value = currentValue;
                }
            });
        }

        // Load saved preferences
        // localStorage patch system - sorted list of patches to apply
        const PATCHES = [
            [1, function patch1_clearBestTime() {
                // Clear best time due to timer bug fix
                localStorage.removeItem('bestTime');
                console.log('Patch 1: Cleared bestTime from localStorage');
            }]
        ];

        function applyPatches() {
            const currentPatchLevel = parseInt(localStorage.getItem('patchLevel') || '0');
            console.log(`Current patch level: ${currentPatchLevel}`);

            // Apply all patches greater than current level
            PATCHES.forEach(([patchNumber, patchFunction]) => {
                if (patchNumber > currentPatchLevel) {
                    console.log(`Applying patch ${patchNumber}...`);
                    patchFunction();
                }
            });

            // Update patch level to highest patch number
            if (PATCHES.length > 0) {
                const latestPatch = PATCHES[PATCHES.length - 1][0];
                if (latestPatch > currentPatchLevel) {
                    localStorage.setItem('patchLevel', latestPatch.toString());
                    console.log(`Updated patch level to ${latestPatch}`);
                }
            }
        }

        function loadPreferences() {
            // Load Shavian UI preference
            const savedShavianUI = localStorage.getItem('useShavianUI');
            if (savedShavianUI !== null) {
                useShavianUI = savedShavianUI === 'true';
                document.getElementById('shavianUIToggle').checked = useShavianUI;
            }

            // Load dialect preference
            const savedDialect = localStorage.getItem('dialect');
            if (savedDialect !== null && (savedDialect === 'gb' || savedDialect === 'us')) {
                currentDialect = savedDialect;
            }

            // Load keyboard layout
            const savedLayout = localStorage.getItem('keyboardLayout');
            if (savedLayout !== null) {
                currentLayout = savedLayout;
            }

            // Load ligature preference
            const savedLigatures = localStorage.getItem('useLigatures');
            if (savedLigatures !== null) {
                useLigatures = savedLigatures === 'true';
            }

            // Load current mode (just restore the value, no UI updates needed on home screen)
            const savedMode = localStorage.getItem('currentMode');
            if (savedMode !== null && (savedMode === 'learn' || savedMode === 'play')) {
                currentMode = savedMode;
            }

            // Load best time
            const savedBestTime = localStorage.getItem('bestTime');
            if (savedBestTime !== null) {
                bestTime = parseFloat(savedBestTime);
            }

            // Load debug mode preference
            const savedDebugMode = localStorage.getItem('debugMode');
            if (savedDebugMode !== null) {
                debugMode = savedDebugMode === 'true';
            }
        }

        // Keyboard support for dialogs
        document.addEventListener('keydown', (e) => {
            // Check which modal is open
            const completionModal = document.getElementById('completionModal');
            const settingsModal = document.getElementById('settingsModal');
            const lessonModal = document.getElementById('lessonModal');
            const contentModal = document.getElementById('contentModal');

            const isModalOpen = completionModal.classList.contains('show') ||
                               settingsModal.classList.contains('show') ||
                               lessonModal.classList.contains('show') ||
                               contentModal.classList.contains('show');

            if (!isModalOpen) return;

            // Handle Escape key - close/back action
            if (e.key === 'Escape') {
                e.preventDefault();
                if (completionModal.classList.contains('show')) {
                    goHome();
                } else if (settingsModal.classList.contains('show')) {
                    closeSettings();
                } else if (lessonModal.classList.contains('show')) {
                    closeLessonModal();
                } else if (contentModal.classList.contains('show')) {
                    closeContentModal();
                }
                return;
            }

            // Handle Enter key - activate first/default button
            if (e.key === 'Enter') {
                e.preventDefault();
                if (completionModal.classList.contains('show')) {
                    const firstButton = completionModal.querySelector('button');
                    if (firstButton) firstButton.click();
                } else if (lessonModal.classList.contains('show')) {
                    // In lesson selector, no default button action
                }
                return;
            }

            // Handle Tab key - cycle between buttons
            if (e.key === 'Tab') {
                const activeModal = completionModal.classList.contains('show') ? completionModal :
                                  settingsModal.classList.contains('show') ? settingsModal :
                                  lessonModal.classList.contains('show') ? lessonModal :
                                  contentModal;

                const buttons = Array.from(activeModal.querySelectorAll('button'));
                if (buttons.length > 1) {
                    e.preventDefault();
                    const currentFocus = document.activeElement;
                    const currentIndex = buttons.indexOf(currentFocus);

                    let nextIndex;
                    if (e.shiftKey) {
                        // Shift+Tab - go backwards
                        nextIndex = currentIndex <= 0 ? buttons.length - 1 : currentIndex - 1;
                    } else {
                        // Tab - go forwards
                        nextIndex = currentIndex >= buttons.length - 1 ? 0 : currentIndex + 1;
                    }

                    buttons[nextIndex].focus();
                }
            }
        });

        // Start the app
        applyPatches();
        loadPreferences();
        init();
        updateUILanguage();
    </script>
</body>
</html>
