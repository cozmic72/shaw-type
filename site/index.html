<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaw Type - Shavian Typing Practice</title>
    <style>
        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Medium.otf') format('opentype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Bold.otf') format('opentype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Ormin';
            src: url('fonts/Ormin-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter-Alia', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        p {
            margin-bottom: 1em;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .back-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
            min-width: 40px;
        }

        .back-btn:hover {
            color: #5568d3;
        }

        .back-btn.hidden {
            visibility: hidden;
        }

        h1 {
            text-align: center;
            color: #333;
            margin: 0;
            font-size: 36px;
            font-weight: bold;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            flex: 1;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 18px;
            font-weight: normal;
        }

        .home-screen {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 50px;
        }

        .home-screen.hidden {
            display: none;
        }

        .countdown-screen {
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            padding: 40px;
            margin-top: 50px;
        }

        .countdown-screen.hidden {
            display: none !important;
        }

        .countdown-screen:not(.hidden) {
            display: flex;
        }

        .home-btn {
            padding: 20px;
            font-size: 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .home-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .game-content {
            display: block;
        }

        .game-content.hidden {
            display: none;
        }

        .word-display {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            min-height: 100px;
            position: relative;
            overflow: hidden;
        }

        .word-carousel {
            position: relative;
            height: 60px;
            overflow: hidden;
        }

        .word-slot {
            position: absolute;
            top: 50%;
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
            white-space: nowrap;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Position classes for the carousel - transform will be set dynamically */
        .word-slot.pos-prev-prev {
            opacity: 0;
        }

        .word-slot.pos-prev {
            opacity: 0.2;
        }

        .word-slot.pos-current {
            opacity: 1;
        }

        .word-slot.pos-next {
            opacity: 0.3;
        }

        .word-slot.pos-next-next {
            opacity: 0;
        }

        .word-display .word {
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
        }

        .word-display .char {
            display: inline-block;
            transition: all 0.2s ease;
            white-space: pre; /* Preserve spaces */
        }

        .word-display .char.correct {
            opacity: 0.4;
            color: #28a745;
        }

        .word-display .char.incorrect {
            color: #dc3545;
            font-weight: bold;
        }

        .input-container {
            margin-bottom: 20px;
        }

        #typingInput {
            width: 100%;
            padding: 15px;
            font-size: 32px;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            text-align: center;
            letter-spacing: 4px;
            transition: border-color 0.3s;
        }

        #typingInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #333;
            font-size: 24px;
            font-weight: bold;
        }

        .countdown-text {
            font-size: 72px;
            font-weight: bold;
            color: #667eea;
            animation: countdown-pulse 0.5s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes error-flash {
            0% {
                background-color: #e74c3c;
            }
            100% {
                background-color: white;
            }
        }

        .completion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .completion-modal.show {
            display: flex;
        }

        .completion-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .completion-content h2 {
            color: #667eea;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .completion-content .final-score {
            font-size: 48px;
            font-weight: bold;
            color: #333;
            margin: 20px 0;
        }

        .completion-content .stat-row {
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }

        .level-stats-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .level-stat {
            padding: 5px 0;
            font-size: 14px;
            color: #555;
            border-bottom: 1px solid #e0e0e0;
        }

        .level-stat:last-child {
            border-bottom: none;
        }

        .completion-content button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .completion-content button:hover {
            background: #5568d3;
        }

        .mode-btn {
            padding: 10px 30px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #f0f0ff;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .settings-btn {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s;
        }

        .settings-btn:hover {
            background: #f0f0ff;
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            animation: slideIn 0.3s ease;
        }

        .settings-content h2 {
            color: #667eea;
            font-size: 28px;
            margin-bottom: 25px;
        }

        .settings-option {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option label {
            display: flex;
            align-items: center;
            font-size: 16px;
            color: #333;
            cursor: pointer;
        }

        .settings-option input[type="checkbox"] {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .settings-option-desc {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
            margin-left: 32px;
        }

        .settings-close-btn {
            margin-top: 25px;
            padding: 12px 30px;
            font-size: 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .settings-close-btn:hover {
            background: #5568d3;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 32px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #333;
        }

        .completion-content,
        .settings-content {
            position: relative;
        }

        #lengthSelect {
            padding: 8px 15px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .burger-menu {
            position: relative;
            display: inline-block;
            min-width: 40px;
        }

        .burger-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
        }

        .burger-btn:hover {
            color: #5568d3;
        }

        .burger-dropdown {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 1000;
            overflow: hidden;
        }

        .burger-dropdown.show {
            display: block;
        }

        .burger-dropdown a {
            color: #333;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: background 0.3s;
        }

        .burger-dropdown a:hover {
            background: #f0f0ff;
        }

        .copyright {
            text-align: center;
            color: #000000;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
        }

        .lesson-option {
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .lesson-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .lesson-option strong {
            color: #333;
            font-size: 16px;
        }

        /* Mobile-friendly compact layout */
        @media (max-width: 768px) {
            h1 {
                font-size: 32px;
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 16px;
                margin-bottom: 20px;
            }

            .word-display {
                padding: 20px;
                margin-bottom: 20px;
                min-height: 60px;
            }

            .word-display .word {
                font-size: 36px;
                letter-spacing: 2px;
            }

            #typingInput {
                padding: 12px;
                font-size: 24px;
            }

            .input-container {
                margin-bottom: 15px;
            }

            .stats {
                gap: 15px;
                margin-bottom: 15px;
            }

            .countdown-text {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <button class="back-btn hidden" id="backBtn" onclick="goHome()">‚Üê</button>
            <h1 id="mainTitle">Shaw Type</h1>
            <div class="burger-menu">
                <button class="burger-btn" onclick="toggleBurgerMenu()">‚ò∞</button>
                <div class="burger-dropdown" id="burgerDropdown">
                    <a id="menuAbout" href="#" onclick="openContentModal('about'); return false;">About</a>
                    <a id="menuKeyboards" href="#" onclick="openContentModal('keyboards'); return false;">Keyboards</a>
                    <a id="menuResources" href="#" onclick="openContentModal('resources'); return false;">Resources</a>
                    <a id="menuSettings" href="#" onclick="openSettings(); closeBurgerMenu(); return false;">Settings</a>
                </div>
            </div>
        </div>

        <div class="subtitle" id="mainSubtitle">êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï</div>

        <!-- Home Screen -->
        <div class="home-screen" id="homeScreen">
            <button class="home-btn" id="homePlayBtn" onclick="startPlay()">Play</button>
            <button class="home-btn" id="homePracticeBtn" onclick="startPractice()">Practice</button>
            <button class="home-btn" id="homeSettingsBtn" onclick="openSettings()">Settings</button>
        </div>

        <!-- Countdown Screen -->
        <div class="countdown-screen hidden" id="countdownScreen">
            <div class="countdown-text" id="countdownText"></div>
        </div>

        <!-- Game Content -->
        <div class="game-content hidden" id="gameContent">
        <div class="word-display">
            <div class="word-carousel">
                <div class="word-slot slot-0" id="wordSlot0"></div>
                <div class="word-slot slot-1" id="wordSlot1"></div>
                <div class="word-slot slot-2" id="wordSlot2"></div>
                <div class="word-slot slot-3" id="wordSlot3"></div>
            </div>
        </div>

        <div class="input-container">
            <input type="text" id="typingInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label" id="levelLabel">Level</div>
                <div class="stat-value" id="levelDisplay">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Words</div>
                <div class="stat-value" id="wordCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">100%</div>
            </div>
        </div>

        <div id="currentLessonInfo" style="display: none; text-align: left; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 13px; color: #666;">
            <strong id="currentLessonName"></strong>
        </div>

        </div> <!-- End game-content -->
    </div> <!-- End container -->

    <div class="copyright">
        @2025 joro.io
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="completion-content">
            <span class="modal-close" onclick="resetPractice()">&times;</span>
            <h2 id="completionTitle">Congratulations!</h2>
            <p id="completionMessage">You completed 30 words!</p>
            <div class="final-score" id="finalScore">--</div>
            <div class="stat-row">WPM: <span id="finalWPM">--</span></div>
            <div class="stat-row">Letters/min: <span id="finalLPM">--</span></div>
            <div class="stat-row">Accuracy: <span id="finalAccuracy">--</span></div>
            <div class="stat-row" id="bestTimeRow"></div>
            <div class="stat-row" id="levelReachedRow">Level Reached: <span id="finalLevel">--</span></div>
            <div id="levelStatsContainer" class="level-stats-container"></div>
            <div id="completionButtons">
                <button onclick="resetPractice()">Practice Again</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <span class="modal-close" onclick="closeSettings()">&times;</span>
            <h2>Settings</h2>

            <div class="settings-option">
                <label id="settingsDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="gb" checked onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="us" onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <div class="settings-option">
                <label style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Keyboard Layout
                </label>
                <select id="layoutSelectSettings" onchange="onLayoutChangeSettings()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="new-imperial">New Shaw Imperial</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option" id="ligatureSettingOption">
                <label>
                    <input type="checkbox" id="ligatureToggleSettings" onchange="onLigatureToggleSettings()">
                    <span>My keyboard auto-converts ligatures (e.g., êë©+êëÆ ‚Üí êëº)</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="shavianUIToggle" onchange="toggleShavianUI()">
                    <span>Display UI in Shavian</span>
                </label>
                <div class="settings-option-desc">Show labels and text in Shavian alphabet instead of Latin</div>
            </div>

            <div class="settings-option" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                <label>
                    <input type="checkbox" id="hideWelcomeToggle" onchange="toggleHideWelcome()">
                    <span id="settingsHideWelcome">Hide welcome screen when page opens</span>
                </label>
            </div>
        </div>
    </div>

    <!-- Content Modal -->
    <div class="settings-modal" id="contentModal">
        <div class="settings-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <span class="modal-close" onclick="closeContentModal()">&times;</span>
            <h2 id="contentModalTitle">Content</h2>
            <div id="contentModalBody" style="margin-top: 20px;">
                Loading...
            </div>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div class="settings-modal" id="welcomeModal">
        <div class="settings-content" style="max-width: 600px;">
            <h2 id="welcomeTitle">Welcome to Shaw Type!</h2>
            <p id="welcomeSubtitle" style="margin: 15px 0; color: #666;">Choose your preferences to get started:</p>

            <div class="settings-option">
                <label id="welcomeDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectWelcome" value="gb" checked onchange="onDialectChangeWelcome()" style="margin-right: 8px;">
                        <span id="welcomeDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectWelcome" value="us" onchange="onDialectChangeWelcome()" style="margin-right: 8px;">
                        <span id="welcomeDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <div class="settings-option">
                <label id="welcomeLayoutLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Keyboard Layout
                </label>
                <select id="layoutSelectWelcome" onchange="onLayoutChangeWelcome()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="new-imperial">New Shaw Imperial</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option" id="ligatureWelcomeOption">
                <label>
                    <input type="checkbox" id="ligatureToggleWelcome" onchange="onLigatureToggleWelcome()">
                    <span id="welcomeLigatureLabel">Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="shavianUIToggleWelcome" onchange="toggleShavianUIWelcome()">
                    <span id="welcomeShavianUILabel">Display UI in Shavian</span>
                </label>
            </div>

            <button id="welcomeStartButton" class="settings-close-btn" onclick="closeWelcomeModal()" style="margin-top: 25px; width: 100%;">Start</button>
        </div>
    </div>

    <!-- Lesson Selector Modal -->
    <div class="settings-modal" id="lessonModal">
        <div class="settings-content" style="max-width: 500px;">
            <span class="modal-close" onclick="closeLessonModal()">&times;</span>
            <h2 id="lessonModalTitle">Choose a Lesson</h2>
            <p id="lessonModalSubtitle" style="margin: 15px 0; color: #666;">Select a lesson to practice:</p>

            <div id="lessonList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Lessons will be populated dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Words will be loaded from JSON file
        let wordsByLength = {};
        let learnWordsImperial = {};
        let learnWordsImperialNoLig = {};
        let learnWordsNewImperial = {};
        let learnWordsNewImperialNoLig = {};
        let learnWordsQwerty = {};
        let learnWords2layer = {};
        let learnWordsJafl = {};
        let learnWordsJaflNoLig = {};
        let wordsLoaded = false;

        // Current level/lesson state
        let currentLevelWordPool = []; // Source pool of words for current level/lesson
        let currentLevelWordCount = 5; // Number of words to complete this level/lesson
        let currentLevelTitle = ''; // Display title for current level/lesson
        let currentLevelType = 'level'; // 'level' or 'lesson' for UI labels
        let currentLevelTypeLabel = 'Level'; // Display label for UI
        let currentLevelNumber = 1;
        let currentLevelCompletionCallback = null; // Function to call when level completes

        // Carousel: 4 slots, we track which slot index maps to which position
        let carouselOffset = 0; // Current slot index for "current" word
        let words = ['', '', '', '']; // Words in slots [0, 1, 2, 3]
        let currentWord = ''; // The actual current word being typed
        let wordsCompleted = 0;
        let wordsInCurrentLevel = 0; // Words completed in current level
        let totalLettersTyped = 0;
        let correctLetters = 0;
        let recentWords = []; // Track recent words to avoid repeats
        let startTime = null; // Session start time
        let bestTime = null; // Best completion time from localStorage (in seconds)
        let levelStats = []; // Per-level statistics
        let currentLevelLettersTyped = 0; // Letters typed in current level
        let currentLevelCorrectLetters = 0; // Correct letters in current level

        // Ligature mappings
        const LIGATURES = {
            'êëº': ['êë©', 'êëÆ'], // ER
            'êë∏': ['êë≠', 'êëÆ'], // AR
            'êëπ': ['êë∑', 'êëÆ'], // OR
            'êëø': ['êëò', 'êëµ'], // YEW
            'êëΩ': ['êëæ', 'êëÆ']  // AIR
        };

        // Reverse mapping: component pairs to compound
        const COMPONENT_TO_LIGATURE = {};
        Object.keys(LIGATURES).forEach(compound => {
            const [first, second] = LIGATURES[compound];
            const key = first + second;
            COMPONENT_TO_LIGATURE[key] = compound;
        });

        // Expand a string, replacing compound ligatures with their components
        function expandLigatures(str) {
            const chars = Array.from(str);
            const expanded = [];
            chars.forEach(char => {
                if (LIGATURES[char]) {
                    expanded.push(...LIGATURES[char]);
                } else {
                    expanded.push(char);
                }
            });
            return expanded;
        }

        // Check if input matches expected, considering ligature equivalence
        function matchesWithLigatures(inputChars, expectedChars, index) {
            // Get the expanded forms for comparison
            const expectedExpanded = expandLigatures(expectedChars.join(''));
            const inputExpanded = expandLigatures(inputChars.join(''));

            // Check if input (up to index) matches expected
            for (let i = 0; i <= index && i < inputExpanded.length; i++) {
                if (i >= expectedExpanded.length) return false;
                if (inputExpanded[i] !== expectedExpanded[i]) return false;
            }
            return true;
        }

        // Check if the current input could be a partial ligature match
        function isPartialLigatureMatch(inputChars, expectedChars, inputIndex) {
            const inputExpanded = expandLigatures(inputChars.join(''));
            const expectedExpanded = expandLigatures(expectedChars.join(''));

            // If we're in the middle of potentially typing a ligature, don't mark as error yet
            if (inputIndex < inputExpanded.length && inputIndex < expectedExpanded.length) {
                return inputExpanded[inputIndex] === expectedExpanded[inputIndex];
            }
            return true;
        }

        // Mode management
        let currentMode = 'play'; // 'learn' or 'play'
        let currentLayout = 'imperial'; // 'imperial' or 'qwerty'
        let useLigatures = false; // Toggle for ligatures - OFF by default
        let selectedLevel = 1; // Level selection: 1-7
        let useShavianUI = false; // Toggle for Shavian UI
        let currentDialect = 'gb'; // 'gb' or 'us' - English dialect for word lists

        // UI text translations
        const translations = {
            latin: {
                title: 'Shaw Type',
                subtitle: 'êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï',
                practice: 'Practice',
                play: 'Play',
                settings: 'Settings',
                keyboardLayout: 'Keyboard Layout',
                ligatures: 'Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)',
                lesson: 'Lesson:',
                wordLength: 'Word Length:',
                characters: 'characters',
                // Word length options
                length1: '1 character',
                length2: '2 characters',
                length3: '3 characters',
                length4: '4 characters',
                length5: '5 characters',
                length6: '6 characters',
                length7: '7 characters',
                length46: '4-6 characters',
                length57: '5-7 characters',
                lesson_label: 'Lesson',
                level_label: 'Level',
                words: 'Words',
                accuracy: 'Accuracy',
                gameInstructions: 'Type the words shown - hit space between words.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'Home Row Center',
                lessonFullHomeRow: 'Full Home Row',
                lessonIndexFingerReach: 'Index Finger Reach',
                lessonUpperLowerRows: 'Upper & Lower Rows',
                lessonNumberRowFocus: 'Number Row Focus',
                lessonHardToReach: 'Hard to Reach',
                lessonAllKeys: 'All Keys',
                lessonCompoundLetters: 'Compound Letters',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'Home Row + Shift',
                lessonAddUpperRow: 'Add Upper Row',
                lessonAddLowerRow: 'Add Lower Row',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'Essential Phonemes',
                lessonVowelVoyage: 'Vowel Voyage',
                lessonConsonantCommand: 'Consonant Command',
                lessonLigaturePower: 'Ligature Power',
                lessonShiftMastery: 'Shift Mastery',
                lessonCompleteControl: 'Complete Control',
                // Lesson names - JAFL
                lessonCoreFoundation: 'Core Foundation',
                lessonHomeSweet: 'Home Sweet Home',
                lessonUpperExpedition: 'Upper Expedition',
                lessonLowerExploration: 'Lower Exploration',
                lessonShiftIntroduction: 'Shift Introduction',
                lessonMasterTypist: 'Master Typist',
                congratulations: 'Congratulations!',
                completed30: 'You completed 30 words!',
                wpm: 'WPM:',
                lettersPerMin: 'Letters/min:',
                accuracy_final: 'Accuracy:',
                levelReached: 'Level Reached:',
                practiceAgain: 'Practice Again',
                settingsTitle: 'Settings',
                displayShavian: 'Display UI in Shavian',
                displayShavianDesc: 'Show labels and text in Shavian alphabet instead of Latin',
                close: 'Close',
                lessonModalTitle: 'Choose a Lesson',
                lessonModalSubtitle: 'Select a lesson to practice:',
                lessonModalCancel: 'Cancel',
                lessonPrefix: 'Lesson',
                // Lesson descriptions
                desc1: 'Middle fingers only, home row',
                desc2: 'All fingers, home row',
                desc3: 'Add index finger upper/lower reaches',
                desc4: 'Extend to more keys above and below',
                desc5: 'Add outer columns',
                desc6: 'Complete keyboard (all layers)',
                desc7: 'Practice typing ligatures: êëº êë∏ êëπ êëø êëΩ',
                desc8: 'Home row with shift layer',
                desc9: 'Add upper row (both layers)',
                desc10: 'Add lower row (both layers)',
                desc11: 'Master the 9 most common sounds in English',
                desc12: 'Navigate through English vowel sounds',
                desc13: 'Build confidence with base layer consonants',
                desc14: 'Harness the efficiency of compound letters',
                desc15: 'Unlock the full potential of the shift layer',
                desc16: 'Command every key with confidence',
                desc17: 'Build your foundation with essential sounds',
                desc18: 'Master the comfort of the home row',
                desc19: 'Journey to the upper reaches of your keyboard',
                desc20: 'Explore the depths below home position',
                desc21: 'Discover new dimensions with the shift key',
                desc22: 'Achieve mastery over the complete keyboard',
                desc23: 'All fingers, home row (unshifted)',
                desc24: 'Complete keyboard including number row',
                // Burger menu items
                menuAbout: 'About',
                menuKeyboards: 'Keyboards',
                menuResources: 'Resources',
                menuSettings: 'Settings',
                // Content modal titles
                titleAbout: 'About',
                titleKeyboards: 'Keyboards',
                titleResources: 'Resources',
                // Settings dialog labels
                dialectLabel: 'Choose spelling',
                dialectBritish: 'British',
                dialectAmerican: 'American',
                hideWelcome: 'Hide welcome screen when page opens',
                // Layout names
                layoutImperial: 'Shaw Imperial',
                layoutNewImperial: 'New Shaw Imperial',
                layoutQwerty: 'Shaw QWERTY',
                layout2layer: 'Shaw 2-layer (shift)',
                layoutJafl: 'Shaw-JAFL'
            },
            shavian: {
                title: '¬∑êëñêë∑ êëëêë≤êëê',
                subtitle: '¬∑êëñêë±êëùêëæêëØ êëëêë≤êëêêë¶êëô êëêêëÆêë®êëíêëëêë¶êëï',
                practice: 'êëêêëÆêë®êëíêëëêë¶êëï',
                play: 'êëêêë§êë±',
                settings: 'êëïêëßêëëêë¶êëôêëü',
                keyboardLayout: 'êëíêë∞êëöêëπêëõ êë§êë±êë¨êëë',
                ligatures: 'êë∑êëëêë©êë•êë®êëëêë¶êëí êë§êë¶êëúêë©êëóêëºêëü (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)',
                lesson: 'êë§êëßêëïêë©êëØ:',
                wordLength: 'êë¢êëªêëõ êë§êëßêëôêëî:',
                characters: 'êëíêë®êëÆêë©êëíêëëêëºêëü',
                // Word length options
                length1: '1 êëíêë®êëÆêë©êëíêëëêëº',
                length2: '2 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length3: '3 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length4: '4 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length5: '5 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length6: '6 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length7: '7 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length46: '4-6 êëíêë®êëÆêë©êëíêëëêëºêëü',
                length57: '5-7 êëíêë®êëÆêë©êëíêëëêëºêëü',
                lesson_label: 'êë§êëßêëïêë©êëØ',
                level_label: 'êë§êëßêëùêë©êë§',
                words: 'êë¢êëªêëõêëü',
                accuracy: 'êë®êëíêëòêëºêë©êëïêë¶',
                gameInstructions: 'êëëêë≤êëê êëû êë¢êëªêëõêëü êëñêë¥êëØ - êë£êë¶êëë êëïêëêêë±êëï êëöêë¶êëëêë¢êë∞êëØ êë¢êëªêëõêëü.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'êë£êë¥êë• êëÆêë¥ êëïêëßêëØêëëêëº',
                lessonFullHomeRow: 'êëìêë´êë§ êë£êë¥êë• êëÆêë¥',
                lessonIndexFingerReach: 'êë¶êëØêëõêëßêëíêëï êëìêë¶êëôêëúêëº êëÆêë∞êëó',
                lessonUpperLowerRows: 'êë≥êëêêëº & êë§êë¥êëº êëÆêë¥êëü',
                lessonNumberRowFocus: 'êëØêë≥êë•êëöêëº êëÆêë¥ êëìêë¥êëíêë©êëï',
                lessonHardToReach: 'êë£êë≠êëÆêëõ êëë êëÆêë∞êëó',
                lessonAllKeys: 'êë∑êë§ êëíêë∞êëü',
                lessonCompoundLetters: 'êëíêë™êë•êëêêë¨êëØêëõ êë§êëßêëëêëºêëü',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'êë£êë¥êë• êëÆêë¥ + êëñêë¶êëìêëë',
                lessonAddUpperRow: 'êë®êëõ êë≥êëêêëº êëÆêë¥',
                lessonAddLowerRow: 'êë®êëõ êë§êë¥êëº êëÆêë¥',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'êë¶êëïêëßêëØêëñêë©êë§ êëìêë¥êëØêë∞êë•êëü',
                lessonVowelVoyage: 'êëùêë¨êë©êë§ êëùêë∂êë¶êë°',
                lessonConsonantCommand: 'êëíêë™êëØêëïêë©êëØêë©êëØêëë êëíêë©êë•êë≠êëØêëõ',
                lessonLigaturePower: 'êë§êë¶êëúêë©êëóêëº êëêêë¨êëº',
                lessonShiftMastery: 'êëñêë¶êëìêëë êë•êë≠êëïêëëêëºêë¶',
                lessonCompleteControl: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë©êëØêëëêëÆêë¥êë§',
                // Lesson names - JAFL
                lessonCoreFoundation: 'êëíêëπ êëìêë¨êëØêëõêë±êëñêë©êëØ',
                lessonHomeSweet: 'êë£êë¥êë• êëïêë¢êë∞êëë êë£êë¥êë•',
                lessonUpperExpedition: 'êë≥êëêêëº êëßêëíêëïêëêêë©êëõêë¶êëñêë©êëØ',
                lessonLowerExploration: 'êë§êë¥êëº êëßêëíêëïêëêêë§êëºêë±êëñêë©êëØ',
                lessonShiftIntroduction: 'êëñêë¶êëìêëë êë¶êëØêëëêëÆêë©êëõêë≥êëíêëñêë©êëØ',
                lessonMasterTypist: 'êë•êë≠êëïêëëêëº êëëêë≤êëêêë¶êëïêëë',
                congratulations: 'êëíêë©êëØêëúêëÆêë®êëóêë©êë§êë±êëñêë©êëØêëü!',
                completed30: 'êëø êëíêë©êë•êëêêë§êë∞êëëêë©êëõ 30 êë¢êëªêëõêëü!',
                wpm: 'WPM:',
                lettersPerMin: 'êë§êëßêëëêëºêëü/êë•êë∞êëØ:',
                accuracy_final: 'êë®êëíêëòêëºêë©êëïêë¶:',
                levelReached: 'êë§êëßêëùêë©êë§ êëÆêë∞êëóêëë:',
                practiceAgain: 'êëêêëÆêë®êëíêëëêë¶êëï êë©êëúêëßêëØ',
                settingsTitle: 'êëïêëßêëëêë¶êëôêëü',
                displayShavian: 'êëõêë¶êëïêëêêë§êë± UI êë¶êëØ ¬∑êëñêë±êëùêëæêëØ',
                displayShavianDesc: 'êëñêë¥ êë§êë±êëöêë©êë§êëü êëØ êëëêëßêëíêëïêëë êë¶êëØ ¬∑êëñêë±êëùêëæêëØ êë®êë§êëìêë©êëöêëßêëë êë¶êëØêëïêëëêëßêëõ êëù ¬∑êë§êë®êëëêë¶êëØ',
                close: 'êëíêë§êë¥êëü',
                lessonModalTitle: 'êëóêëµêëü êë© êë§êëßêëïêë©êëØ',
                lessonModalSubtitle: 'êëïêë¶êë§êëßêëíêëë êë© êë§êëßêëïêë©êëØ êëë êëêêëÆêë®êëíêëëêë¶êëï:',
                lessonModalCancel: 'êëíêë®êëØêëïêë©êë§',
                lessonPrefix: 'êë§êëßêëïêë©êëØ',
                // Lesson descriptions
                desc1: 'êë•êë¶êëõêë©êë§ êëìêë¶êëôêëúêëºêëü êë¥êëØêë§êë¶, êë£êë¥êë• êëÆêë¥',
                desc2: 'êë∑êë§ êëìêë¶êëôêëúêëºêëü, êë£êë¥êë• êëÆêë¥',
                desc3: 'êë®êëõ êë¶êëØêëõêëßêëíêëï êëìêë¶êëôêëúêëº êë≥êëêêëº/êë§êë¥êëº êëÆêë∞êëóêë©êëü',
                desc4: 'êë¶êëíêëïêëëêëßêëØêëõ êëë êë•êëπ êëíêë∞êëü êë©êëöêë≥êëù êëØ êëöêë¶êë§êë¥',
                desc5: 'êë®êëõ êë¨êëëêëº êëíêë™êë§êë©êë•êëü',
                desc6: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ (êë∑êë§ êë§êë±êëºêëü)',
                desc7: 'êëêêëÆêë®êëíêëëêë¶êëï êëëêë≤êëêêë¶êëô êë§êë¶êëúêë©êëóêëºêëü: êëº êë∏ êëπ êëø êëΩ',
                desc8: 'êë£êë¥êë• êëÆêë¥ êë¢êë¶êëû êëñêë¶êëìêëë êë§êë±êëº',
                desc9: 'êë®êëõ êë≥êëêêëº êëÆêë¥ (êëöêë¥êëî êë§êë±êëºêëü)',
                desc10: 'êë®êëõ êë§êë¥êëº êëÆêë¥ (êëöêë¥êëî êë§êë±êëºêëü)',
                desc11: 'êë•êë≠êëïêëëêëº êëû 9 êë•êë¥êëïêëë êëíêë™êë•êë©êëØ êëïêë¨êëØêëõêëü êë¶êëØ ¬∑êë¶êëôêëúêë§êë¶êëñ',
                desc12: 'êëØêë®êëùêë¶êëúêë±êëë êëîêëÆêëµ ¬∑êë¶êëôêëúêë§êë¶êëñ êëùêë¨êë©êë§ êëïêë¨êëØêëõêëü',
                desc13: 'êëöêë¶êë§êëõ êëíêë™êëØêëìêë¶êëõêë©êëØêëï êë¢êë¶êëû êëöêë±êëï êë§êë±êëº êëíêë™êëØêëïêë©êëØêë©êëØêëëêëï',
                desc14: 'êë£êë∏êëØêë©êëï êëû êë¶êëìêë¶êëñêë©êëØêëïêë¶ êëù êëíêë™êë•êëêêë¨êëØêëõ êë§êëßêëëêëºêëü',
                desc15: 'êë≥êëØêë§êë™êëí êëû êëìêë´êë§ êëêêë©êëëêëßêëØêëñêë©êë§ êëù êëû êëñêë¶êëìêëë êë§êë±êëº',
                desc16: 'êëíêë©êë•êë≠êëØêëõ êëßêëùêëÆêë¶ êëíêë∞ êë¢êë¶êëû êëíêë™êëØêëìêë¶êëõêë©êëØêëï',
                desc17: 'êëöêë¶êë§êëõ êëòêëπ êëìêë¨êëØêëõêë±êëñêë©êëØ êë¢êë¶êëû êë¶êëïêëßêëØêëñêë©êë§ êëïêë¨êëØêëõêëü',
                desc18: 'êë•êë≠êëïêëëêëº êëû êëíêë≥êë•êëìêëºêëë êëù êëû êë£êë¥êë• êëÆêë¥',
                desc19: 'êë°êëªêëØêë¶ êëë êëû êë≥êëêêëº êëÆêë∞êëóêë©êëü êëù êëòêëπ êëíêë∞êëöêëπêëõ',
                desc20: 'êë¶êëíêëïêëêêë§êëπ êëû êëõêëßêëêêëîêëï êëöêë¶êë§êë¥ êë£êë¥êë• êëêêë©êëüêë¶êëñêë©êëØ',
                desc21: 'êëõêë¶êëïêëíêë≥êëùêëº êëØêëø êëõêë¶êë•êëßêëØêëñêë©êëØêëü êë¢êë¶êëû êëû êëñêë¶êëìêëë êëíêë∞',
                desc22: 'êë©êëóêë∞êëù êë•êë≠êëïêëëêëºêë¶ êë¥êëùêëº êëû êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ',
                desc23: 'êë∑êë§ êëìêë¶êëôêëúêëºêëü, êë£êë¥êë• êëÆêë¥ (êë≥êëØêëñêë¶êëìêëëêë©êëõ)',
                desc24: 'êëíêë©êë•êëêêë§êë∞êëë êëíêë∞êëöêëπêëõ êë¶êëØêëíêë§êëµêëõêë¶êëô êëØêë≥êë•êëöêëº êëÆêë¥',
                // Burger menu items
                menuAbout: 'êë©êëöêë¨êëë',
                menuKeyboards: 'êëíêë∞êëöêëπêëõêëü',
                menuResources: 'êëÆêë¶êëüêëπêëïêë©êëü',
                menuSettings: 'êëïêëßêëëêë¶êëôêëü',
                // Content modal titles
                titleAbout: 'êë©êëöêë¨êëë',
                titleKeyboards: 'êëíêë∞êëöêëπêëõêëü',
                titleResources: 'êëÆêë¶êëüêëπêëïêë©êëü',
                // Settings dialog labels
                dialectLabel: 'êëóêëµêëü êëïêëêêëßêë§êë¶êëô',
                dialectBritish: '¬∑êëöêëÆêë¶êëëêë¶êëñ',
                dialectAmerican: '¬∑êë©êë•êëßêëÆêë¶êëíêë©êëØ',
                hideWelcome: 'êë£êë≤êëõ êë¢êëßêë§êëíêë≥êë• êëïêëíêëÆêë∞êëØ êë¢êëßêëØ êëêêë±êë° êë¥êëêêë©êëØêëü',
                // Layout names
                layoutImperial: '¬∑êëñêë∑ êë¶êë•êëêêëΩêëæêë§',
                layoutNewImperial: '¬∑êëØêëø êëñêë∑ êë¶êë•êëêêëΩêëæêë§',
                layoutQwerty: '¬∑êëñêë∑ QWERTY',
                layout2layer: '¬∑êëñêë∑ 2-êë§êë±êëº (êëñêë¶êëìêëë)',
                layoutJafl: '¬∑êëñêë∑-JAFL'
            }
        };

        const wordSlots = [
            document.getElementById('wordSlot0'),
            document.getElementById('wordSlot1'),
            document.getElementById('wordSlot2'),
            document.getElementById('wordSlot3')
        ];
        const typingInput = document.getElementById('typingInput');
        const wordCountEl = document.getElementById('wordCount');
        const accuracyEl = document.getElementById('accuracy');
        const levelDisplayEl = document.getElementById('levelDisplay');

        // Get current level based on words completed (5 words per level)
        function getCurrentLevel() {
            if (currentMode === 'learn' && currentLayout === 'imperial' && useLigatures) {
                // Imperial with ligatures has 7 levels (compound letters at level 5)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5; // Compound letters lesson
                if (wordsCompleted < 30) return 6; // Almost Complete
                return 7; // All Keys
            } else {
                // Other modes use 6 levels (5 words per level = 30 words total)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5;
                return 6;
            }
        }

        // UI Navigation
        function goHome() {
            // Hide game content and countdown, show home screen
            document.getElementById('gameContent').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('hidden');

            // Reset subtitle to default
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            document.getElementById('mainSubtitle').textContent = t.subtitle;

            // Clear any modals
            closeLessonModal();
            document.getElementById('completionModal').classList.remove('show');
        }

        function showGameContent() {
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('gameContent').classList.remove('hidden');
            document.getElementById('backBtn').classList.remove('hidden');
        }

        function startPlay() {
            currentMode = 'play';
            localStorage.setItem('currentMode', currentMode);

            // Hide home screen, show back button
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('hidden');

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];
            hasPendingLigature = false;

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Update UI language
            updateUILanguage();

            // Show countdown, then start game
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function playAgain() {
            // Hide completion modal
            document.getElementById('completionModal').style.display = 'none';

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];
            hasPendingLigature = false;

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Show countdown, then start game
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function startPractice() {
            currentMode = 'learn';
            localStorage.setItem('currentMode', currentMode);

            // Open lesson selector first
            openLessonSelector();
        }

        function updateSubtitleForGame() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const subtitle = document.getElementById('mainSubtitle');

            if (currentMode === 'play') {
                subtitle.textContent = `${t.level_label} ${currentLevelNumber}`;
            } else if (currentMode === 'learn') {
                // Lesson name will be set when lesson is selected
                subtitle.textContent = '';
            }
        }

        // Mode switching (legacy - now mainly used internally)
        function setMode(mode) {
            currentMode = mode;
            localStorage.setItem('currentMode', currentMode);

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display =
                mode === 'learn' ? 'block' : 'none';

            // Update subtitle
            updateSubtitleForGame();

            // Open lesson selector when switching to practice mode
            if (mode === 'learn') {
                openLessonSelector();
            }

            // Update stat label based on mode
            updateUILanguage();

            // Reset and reload
            resetPractice();
        }

        function onDialectChangeSettings() {
            const selected = document.querySelector('input[name="dialectSettings"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    initializeGame();
                });
            }
        }

        function onLayoutChangeSettings() {
            currentLayout = document.getElementById('layoutSelectSettings').value;
            localStorage.setItem('keyboardLayout', currentLayout);
            // Show/hide ligature toggle based on layout
            // Only show for imperial, new-imperial, qwerty, and jafl
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'new-imperial' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';
            updateLevelSelector();
            initializeGame();
        }

        function onLigatureToggleSettings() {
            useLigatures = document.getElementById('ligatureToggleSettings').checked;
            localStorage.setItem('useLigatures', useLigatures);
            updateLevelSelector();
            initializeGame();
        }

        function onLevelChange() {
            selectedLevel = document.getElementById('levelSelect').value;
            initializeGame();
        }

        function getLearnWords() {
            // Get the appropriate word list for current layout and ligature settings
            if (currentLayout === 'imperial') {
                return useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'new-imperial') {
                return useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                return learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                return learnWords2layer;
            } else if (currentLayout === 'jafl') {
                return useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }
            return null;
        }

        function translateLessonName(name) {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Map English lesson names to translation keys
            const nameMap = {
                'Home Row Center': t.lessonHomeRowCenter,
                'Full Home Row': t.lessonFullHomeRow,
                'Index Finger Reach': t.lessonIndexFingerReach,
                'Upper & Lower Rows': t.lessonUpperLowerRows,
                'Number Row Focus': t.lessonNumberRowFocus,
                'Hard to Reach': t.lessonHardToReach,
                'All Keys': t.lessonAllKeys,
                'Compound Letters': t.lessonCompoundLetters,
                'Home Row + Shift': t.lessonHomeRowShift,
                'Add Upper Row': t.lessonAddUpperRow,
                'Add Lower Row': t.lessonAddLowerRow,
                'Essential Phonemes': t.lessonEssentialPhonemes,
                'Vowel Voyage': t.lessonVowelVoyage,
                'Consonant Command': t.lessonConsonantCommand,
                'Ligature Power': t.lessonLigaturePower,
                'Shift Mastery': t.lessonShiftMastery,
                'Complete Control': t.lessonCompleteControl,
                'Core Foundation': t.lessonCoreFoundation,
                'Home Sweet Home': t.lessonHomeSweet,
                'Upper Expedition': t.lessonUpperExpedition,
                'Lower Exploration': t.lessonLowerExploration,
                'Shift Introduction': t.lessonShiftIntroduction,
                'Master Typist': t.lessonMasterTypist
            };

            return nameMap[name] || name;
        }

        function translateLessonDescription(description) {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Map English descriptions to translation keys
            const descMap = {
                'Middle fingers only, home row': t.desc1,
                'All fingers, home row': t.desc2,
                'Add index finger upper/lower reaches': t.desc3,
                'Extend to more keys above and below': t.desc4,
                'Add outer columns': t.desc5,
                'Complete keyboard (all layers)': t.desc6,
                'Practice typing ligatures: êëº êë∏ êëπ êëø êëΩ': t.desc7,
                'Home row with shift layer': t.desc8,
                'Add upper row (both layers)': t.desc9,
                'Add lower row (both layers)': t.desc10,
                'Master the 9 most common sounds in English': t.desc11,
                'Navigate through English vowel sounds': t.desc12,
                'Build confidence with base layer consonants': t.desc13,
                'Harness the efficiency of compound letters': t.desc14,
                'Unlock the full potential of the shift layer': t.desc15,
                'Command every key with confidence': t.desc16,
                'Build your foundation with essential sounds': t.desc17,
                'Master the comfort of the home row': t.desc18,
                'Journey to the upper reaches of your keyboard': t.desc19,
                'Explore the depths below home position': t.desc20,
                'Discover new dimensions with the shift key': t.desc21,
                'Achieve mastery over the complete keyboard': t.desc22,
                'All fingers, home row (unshifted)': t.desc23,
                'Complete keyboard including number row': t.desc24
            };

            return descMap[description] || description;
        }

        function updateLevelSelector() {
            const levelSelect = document.getElementById('levelSelect');

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            // Clear existing options
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            levelSelect.innerHTML = ``;

            // Add lesson options with names
            if (learnWords) {
                const maxLevel = Object.keys(learnWords).length;

                for (let i = 1; i <= maxLevel; i++) {
                    const levelData = learnWords[i];
                    if (levelData) {
                        const option = document.createElement('option');
                        option.value = i;
                        const translatedName = translateLessonName(levelData.name);
                        option.textContent = `${i}. ${translatedName}`;
                        levelSelect.appendChild(option);
                    }
                }
            }

            // Reset to level 1 if selected level is now unavailable
            const maxLevel = (currentLayout === 'imperial' && useLigatures) ? 7 : 6;
            if (parseInt(selectedLevel) > maxLevel) {
                selectedLevel = 1;
            }

            // Restore selected value
            levelSelect.value = selectedLevel;
        }

        // Get word pool and metadata for a play level
        function getPlayLevelData(levelNum) {
            let pool = [];
            let title = '';

            if (levelNum === 1) {
                pool = [...wordsByLength[1], ...wordsByLength[2]];
                title = '1-2 Letters';
            } else if (levelNum === 2) {
                pool = [...wordsByLength[2], ...wordsByLength[3]];
                title = '2-3 Letters';
            } else if (levelNum === 3) {
                pool = [...wordsByLength[3], ...wordsByLength[4]];
                title = '3-4 Letters';
            } else if (levelNum === 4) {
                pool = [...wordsByLength[4], ...wordsByLength[5], ...wordsByLength[6]];
                title = '4-6 Letters';
            } else if (levelNum === 5) {
                pool = [...wordsByLength[5], ...wordsByLength[6], ...wordsByLength[7]];
                title = '5+ Letters';
            } else if (levelNum === 6) {
                pool = [...wordsByLength[6], ...wordsByLength[7]];
                title = '6+ Letters';
            }

            return {
                wordPool: pool,
                wordCount: 5,
                title: title
            };
        }

        // Get word pool and metadata for a learn lesson
        function getLearnLessonData(lessonIndex) {
            let learnWords;

            if (currentLayout === 'imperial') {
                learnWords = useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'new-imperial') {
                learnWords = useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                learnWords = learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                learnWords = learnWords2layer;
            } else if (currentLayout === 'jafl') {
                learnWords = useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }

            const levelData = learnWords[lessonIndex];
            if (levelData && levelData.words) {
                const translatedName = translateLessonName(levelData.name);
                return {
                    wordPool: levelData.words,
                    wordCount: 10,
                    title: translatedName
                };
            }

            return null;
        }

        // Load words from JSON
        async function loadWords() {
            try {
                // Load practice words
                const wordsResponse = await fetch(`words_${currentDialect}.json`);
                const wordsData = await wordsResponse.json();
                // Convert string keys to numbers
                Object.keys(wordsData).forEach(key => {
                    wordsByLength[parseInt(key)] = wordsData[key];
                });

                // Load learn mode words for Imperial
                const learnImperialResponse = await fetch(`learn_words_imperial_${currentDialect}.json`);
                const learnImperialData = await learnImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialData).forEach(key => {
                    learnWordsImperial[parseInt(key)] = learnImperialData[key];
                });

                // Load learn mode words for QWERTY
                const learnQwertyResponse = await fetch(`learn_words_qwerty_${currentDialect}.json`);
                const learnQwertyData = await learnQwertyResponse.json();
                // Convert string keys to numbers
                Object.keys(learnQwertyData).forEach(key => {
                    learnWordsQwerty[parseInt(key)] = learnQwertyData[key];
                });

                // Load learn mode words for Imperial (no ligatures)
                const learnImperialNoLigResponse = await fetch(`learn_words_imperial_${currentDialect}_no_lig.json`);
                const learnImperialNoLigData = await learnImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialNoLigData).forEach(key => {
                    learnWordsImperialNoLig[parseInt(key)] = learnImperialNoLigData[key];
                });

                // Load learn mode words for New Imperial
                const learnNewImperialResponse = await fetch(`learn_words_new-imperial_${currentDialect}.json`);
                const learnNewImperialData = await learnNewImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialData).forEach(key => {
                    learnWordsNewImperial[parseInt(key)] = learnNewImperialData[key];
                });

                // Load learn mode words for New Imperial (no ligatures)
                const learnNewImperialNoLigResponse = await fetch(`learn_words_new-imperial_${currentDialect}_no_lig.json`);
                const learnNewImperialNoLigData = await learnNewImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialNoLigData).forEach(key => {
                    learnWordsNewImperialNoLig[parseInt(key)] = learnNewImperialNoLigData[key];
                });

                // Load learn mode words for Shaw 2-layer
                const learn2layerResponse = await fetch(`learn_words_2layer_${currentDialect}.json`);
                const learn2layerData = await learn2layerResponse.json();
                // Convert string keys to numbers
                Object.keys(learn2layerData).forEach(key => {
                    learnWords2layer[parseInt(key)] = learn2layerData[key];
                });

                // Load learn mode words for Shaw-JAFL (with ligatures)
                const learnJaflResponse = await fetch(`learn_words_jafl_${currentDialect}.json`);
                const learnJaflData = await learnJaflResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflData).forEach(key => {
                    learnWordsJafl[parseInt(key)] = learnJaflData[key];
                });

                // Load learn mode words for Shaw-JAFL (no ligatures)
                const learnJaflNoLigResponse = await fetch(`learn_words_jafl_${currentDialect}_no_lig.json`);
                const learnJaflNoLigData = await learnJaflNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflNoLigData).forEach(key => {
                    learnWordsJaflNoLig[parseInt(key)] = learnJaflNoLigData[key];
                });

                wordsLoaded = true;
                return true;
            } catch (error) {
                console.error('Failed to load words:', error);
                alert('Failed to load word list. Please refresh the page.');
                return false;
            }
        }

        // Initialize
        async function init() {
            await loadWords();
            if (wordsLoaded) {
                // Check if we should show welcome screen
                const hideWelcome = localStorage.getItem('hideWelcome');
                if (hideWelcome !== 'true') {
                    showWelcomeIfNeeded();
                }
                // Start on home screen - don't auto-load game
                // User will click Play or Practice to start
            }
        }

        // Countdown animation before starting level
        function showCountdown(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            console.log('[showCountdown] CALLED - this should NOT happen on page load!');
            console.trace(); // Show the call stack
            const countdownScreen = document.getElementById('countdownScreen');
            const gameContent = document.getElementById('gameContent');
            const text = document.getElementById('countdownText');

            // Set instructions in subtitle
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            // Show countdown, hide game content
            countdownScreen.classList.remove('hidden');
            gameContent.classList.add('hidden');

            let count = 3;
            function updateCountdown() {
                if (count > 0) {
                    text.textContent = count;
                    // Reset animation
                    text.style.animation = 'none';
                    setTimeout(() => {
                        text.style.animation = 'countdown-pulse 0.5s ease-in-out';
                    }, 10);
                    count--;
                    setTimeout(updateCountdown, 800);
                } else {
                    // Hide countdown, show game content
                    countdownScreen.classList.add('hidden');
                    gameContent.classList.remove('hidden');
                    // Call startLevel with the parameters
                    startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback);
                }
            }

            updateCountdown();
        }

        // Start a new level/lesson with given word pool, count, and metadata
        function startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            console.log(`[startLevel] Starting ${type}: "${title}" (${wordCount} words from pool of ${wordPool.length})`);

            // Set level state
            currentLevelWordPool = wordPool;
            currentLevelWordCount = wordCount;
            currentLevelType = type;
            currentLevelTitle = title;
            currentLevelTypeLabel = typeLabel;
            currentLevelCompletionCallback = completionCallback;
            wordsInCurrentLevel = 0;
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            recentWords = [];

            // Initialize game (loads words)
            initializeGame();

            // Start timer
            startTime = Date.now();

            // Focus input
            typingInput.focus();
        }

        function pickRandomWord() {
            const pool = currentLevelWordPool;
            if (!pool || pool.length === 0) {
                console.error('No word pool available!');
                return '';
            }

            const historySize = Math.min(10, Math.floor(pool.length / 2));
            let newWord;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                newWord = pool[Math.floor(Math.random() * pool.length)];
                attempts++;
            } while (recentWords.includes(newWord) && attempts < maxAttempts);

            // Update recent words history
            recentWords.push(newWord);
            if (recentWords.length > historySize) {
                recentWords.shift();
            }

            return newWord;
        }

        function loadNewWord() {
            // Check if this is the last word of the level
            const isLastWordOfLevel = (wordsInCurrentLevel === currentLevelWordCount - 1);

            console.log(`[loadNewWord] wordsInCurrentLevel=${wordsInCurrentLevel}, wordCount=${currentLevelWordCount}, isLastWord=${isLastWordOfLevel}`);

            // BEFORE advancing: update the slot that will become "next" after rotation
            // The slot at prev-prev position will rotate to next position
            const prevPrevSlot = (carouselOffset - 2 + 4) % 4;
            const slot = wordSlots[prevPrevSlot];

            // For the last word of a level, put an empty string in the next slot
            const newWord = isLastWordOfLevel ? '' : pickRandomWord();
            words[prevPrevSlot] = newWord;

            console.log(`[loadNewWord] newWord="${newWord}", slot=${prevPrevSlot}`);

            if (newWord) {
                // Load a new word normally
                // Disable transitions for the new slot so it appears instantly
                slot.style.transition = 'none';

                // Update the slot's HTML content so offsetWidth is accurate
                let html = '';
                const wordChars = Array.from(newWord);
                for (let j = 0; j < wordChars.length; j++) {
                    html += `<span class="char">${wordChars[j]}</span>`;
                }
                slot.innerHTML = html;

                // Position it at next-next location (after current next word) BEFORE advancing
                // Calculate where next-next should be
                const currentSlotIndex = carouselOffset;
                const nextSlotIndex = (carouselOffset + 1) % 4;
                const carouselWidth = wordSlots[0].parentElement.clientWidth;
                const currentWidth = wordSlots[currentSlotIndex].offsetWidth;
                const nextWidth = wordSlots[nextSlotIndex].offsetWidth;
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Position the new slot at next-next location and make it visible
                slot.classList.remove('pos-prev-prev', 'pos-prev', 'pos-current', 'pos-next');
                slot.classList.add('pos-next-next');
                slot.style.transform = `translateX(${nextNextX}px) translateY(-50%)`;

                // Force reflow to apply the next-next position
                slot.offsetHeight;

                // Re-enable transitions so it can animate when repositioned
                slot.style.transition = '';
            } else {
                // Empty slot for after last word
                console.log('[loadNewWord] Last word - empty next slot');
                slot.innerHTML = '';
            }

            // NOW advance carousel
            carouselOffset = (carouselOffset + 1) % 4;

            // Get current word from carousel
            currentWord = words[carouselOffset];

            // Append space to currentWord if it's not the last word of the level
            if (!isLastWordOfLevel) {
                currentWord = currentWord + ' ';
                // Store it back in the array so prev word will have the space
                words[carouselOffset] = currentWord;
            }

            typingInput.value = '';
            previousInput = '';
            hasPendingLigature = false;
            isInErrorState = false;
            updateWordDisplay();

            updateLevel();
        }

        function initializeGame() {
            console.log(`[initializeGame] wordPool length: ${currentLevelWordPool.length}, wordCount: ${currentLevelWordCount}`);
            // Reset carousel completely
            words = ['', '', '', ''];
            carouselOffset = 2; // Will advance to 3, then 0
            // Run the cycle twice to load first two words
            loadNewWord(); // Loads first word, advances to offset 3
            loadNewWord(); // Loads second word, advances to offset 0 (current)
        }

        function advanceToNextWord() {
            // Just call loadNewWord - carousel positions will update via CSS transitions
            loadNewWord();
        }

        function updateLevel() {
            // Display the current level/lesson number
            levelDisplayEl.textContent = currentLevelNumber;
        }

        function updateWordDisplay() {
            const userInput = typingInput.value;

            // Update each carousel slot
            for (let i = 0; i < 4; i++) {
                const slot = wordSlots[i];
                const word = words[i];

                // Calculate position relative to current
                const posOffset = (i - carouselOffset + 4) % 4;

                // Remove old position classes
                slot.className = 'word-slot slot-' + i;

                // Add appropriate position class
                if (posOffset === 0) {
                    // Current word
                    slot.classList.add('pos-current');

                    // Build HTML with coloring for current word
                    let html = '';
                    const wordChars = Array.from(currentWord);
                    const wordExpanded = expandLigatures(currentWord);
                    const inputExpanded = expandLigatures(userInput);
                    let expandedPos = 0;

                    for (let j = 0; j < wordChars.length; j++) {
                        const char = wordChars[j];
                        let className = '';
                        const isLigature = LIGATURES[char];
                        const expandedLen = isLigature ? 2 : 1;

                        let allCorrect = true;
                        let anyTyped = false;
                        let anyIncorrect = false;

                        for (let k = 0; k < expandedLen; k++) {
                            const expIdx = expandedPos + k;
                            if (expIdx < inputExpanded.length) {
                                anyTyped = true;
                                if (inputExpanded[expIdx] !== wordExpanded[expIdx]) {
                                    anyIncorrect = true;
                                    allCorrect = false;
                                }
                            } else {
                                allCorrect = false;
                            }
                        }

                        if (anyIncorrect) {
                            className = 'incorrect';
                        } else if (anyTyped && allCorrect) {
                            className = 'correct';
                        }

                        html += `<span class="char ${className}">${char}</span>`;
                        expandedPos += expandedLen;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 1) {
                    // Next word
                    slot.classList.add('pos-next');
                    let html = '';
                    const wordChars = Array.from(word || '');
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 3) {
                    // Previous word
                    slot.classList.add('pos-prev');
                    let html = '';
                    const wordChars = Array.from(word || '');
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else {
                    // Previous-previous word (off screen)
                    slot.classList.add('pos-prev-prev');
                    slot.innerHTML = '';
                }
            }

            // Calculate positions based on actual widths
            // Wait for next frame to ensure content is rendered
            requestAnimationFrame(() => {
                const carouselWidth = wordSlots[0].parentElement.clientWidth;

                // Find which slot is at each position
                let currentSlot = -1, prevSlot = -1, nextSlot = -1, nextNextSlot = -1;
                for (let i = 0; i < 4; i++) {
                    const posOffset = (i - carouselOffset + 4) % 4;
                    if (posOffset === 0) currentSlot = i;
                    else if (posOffset === 1) nextSlot = i;
                    else if (posOffset === 2) nextNextSlot = i;
                    else if (posOffset === 3) prevSlot = i;
                }

                // Get widths
                const currentWidth = wordSlots[currentSlot].offsetWidth;
                const prevWidth = prevSlot >= 0 ? wordSlots[prevSlot].offsetWidth : 0;
                const nextWidth = nextSlot >= 0 ? wordSlots[nextSlot].offsetWidth : 0;

                // Calculate positions - center current word, position others relative to it
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const prevX = currentX - prevWidth;
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Apply transforms (include translateY for vertical centering)
                wordSlots[currentSlot].style.transform = `translateX(${currentX}px) translateY(-50%)`;
                if (prevSlot >= 0) wordSlots[prevSlot].style.transform = `translateX(${prevX}px) translateY(-50%)`;
                if (nextSlot >= 0) wordSlots[nextSlot].style.transform = `translateX(${nextX}px) translateY(-50%)`;
                if (nextNextSlot >= 0) wordSlots[nextNextSlot].style.transform = `translateX(${nextNextX}px) translateY(-50%)`;
            });
        }

        function updateStats() {
            wordCountEl.textContent = wordsCompleted;
            const accuracy = totalLettersTyped === 0 ? 100 : ((correctLetters / totalLettersTyped) * 100).toFixed(1);
            accuracyEl.textContent = accuracy + '%';
        }

        function checkCompletion() {
            const userInput = typingInput.value;

            // Compare expanded forms to handle ligature equivalence
            const inputExpanded = expandLigatures(userInput);
            const wordExpanded = expandLigatures(currentWord);

            // Check if expanded forms match (word completed including space if present)
            if (inputExpanded.length === wordExpanded.length &&
                inputExpanded.every((char, i) => char === wordExpanded[i])) {
                // Word completed correctly
                wordsCompleted++;
                wordsInCurrentLevel++;
                console.log(`[checkCompletion] Word ${wordsInCurrentLevel} of level completed (total: ${wordsCompleted})`);
                updateStats();

                // After first word, update subtitle with level/lesson info
                if (wordsCompleted === 1) {
                    document.getElementById('mainSubtitle').textContent =
                        `${currentLevelTypeLabel} ${currentLevelNumber}: ${currentLevelTitle}`;
                }

                // Check if level is complete
                if (wordsInCurrentLevel === currentLevelWordCount) {
                    // Level completed - transition to next level
                    console.log(`[checkCompletion] ${currentLevelType.toUpperCase()} COMPLETED`);
                    transitionToNextLevel();
                } else {
                    // Advance to next word
                    advanceToNextWord();
                }
            }
        }

        function transitionToNextLevel() {
            console.log('[transitionToNextLevel] Starting transition');

            // Save stats for completed level
            const finalLevelAccuracy = currentLevelLettersTyped === 0 ? 100.0 :
                ((currentLevelCorrectLetters / currentLevelLettersTyped) * 100);
            levelStats.push({
                level: currentLevelNumber,
                accuracy: finalLevelAccuracy,
                lettersTyped: currentLevelLettersTyped,
                correctLetters: currentLevelCorrectLetters
            });

            // If there's a completion callback, use it
            if (currentLevelCompletionCallback) {
                console.log('[transitionToNextLevel] Calling completion callback');
                currentLevelCompletionCallback();
                return;
            }

            // Default behavior: try to advance to next level
            console.log(`[transitionToNextLevel] Mode: ${currentMode}, Current level: ${currentLevelNumber}`);
            let nextLevelData = null;
            if (currentMode === 'learn') {
                const nextLessonIndex = parseInt(selectedLevel) + 1;
                nextLevelData = getLearnLessonData(nextLessonIndex);
                if (nextLevelData) {
                    selectedLevel = nextLessonIndex.toString();
                    currentLevelNumber = nextLessonIndex;
                }
            } else {
                const nextLevelNum = currentLevelNumber + 1;
                console.log(`[transitionToNextLevel] Next level num: ${nextLevelNum}`);
                if (nextLevelNum <= 6) {
                    nextLevelData = getPlayLevelData(nextLevelNum);
                    currentLevelNumber = nextLevelNum;
                    console.log(`[transitionToNextLevel] Got next level data for level ${nextLevelNum}`);
                } else {
                    console.log(`[transitionToNextLevel] No more levels (${nextLevelNum} > 6)`);
                }
            }

            console.log(`[transitionToNextLevel] nextLevelData is ${nextLevelData ? 'not null' : 'null'}`);
            if (nextLevelData) {
                // Start new level with new words (no countdown between levels!)
                const lang = useShavianUI ? 'shavian' : 'latin';
                const t = translations[lang];
                const type = currentMode === 'learn' ? 'lesson' : 'level';
                const typeLabel = type === 'lesson' ? t.lesson_label : t.level_label;

                // Set instructions in subtitle for practice mode
                if (type === 'lesson') {
                    document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                }

                // Just start the level directly (both play and practice)
                startLevel(nextLevelData.wordPool, nextLevelData.wordCount, type, nextLevelData.title, typeLabel, currentLevelCompletionCallback);
            } else {
                // No more levels/lessons - show completion modal
                console.log('[transitionToNextLevel] Calling showCompletionModal');
                showCompletionModal();
            }
        }

        function showLessonCompletionDialog() {
            console.log('[showLessonCompletionDialog] Lesson completed');

            // Calculate stats for this lesson
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Set modal content for lesson completion
            document.getElementById('completionTitle').textContent = 'Lesson Complete!';
            document.getElementById('completionMessage').textContent = `You completed ${wordsCompleted} words!`;

            // Hide game-specific stats
            document.getElementById('finalScore').style.display = 'none';
            document.getElementById('finalWPM').parentElement.style.display = 'none';
            document.getElementById('finalLPM').parentElement.style.display = 'none';
            document.getElementById('bestTimeRow').style.display = 'none';
            document.getElementById('levelReachedRow').style.display = 'none';
            document.getElementById('levelStatsContainer').style.display = 'none';

            // Show accuracy
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';

            // Show "Continue" and "Choose Different Lesson" buttons
            document.getElementById('completionButtons').innerHTML = `
                <button onclick="continueLesson()">Continue</button>
                <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
            `;

            document.getElementById('completionModal').classList.add('show');
        }

        function showCompletionModal() {
            console.log('[showCompletionModal] Called');
            // Stats already saved in transitionToNextLevel
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Calculate time-based metrics
            const endTime = Date.now();
            const elapsedSeconds = (endTime - startTime) / 1000;
            const elapsedMinutes = elapsedSeconds / 60;
            const wpm = wordsCompleted / elapsedMinutes;
            const lettersPerMinute = totalLettersTyped / elapsedMinutes;

            // Format time as MM:SS
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = Math.floor(elapsedSeconds % 60);
            const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Update best time if current time is better (lower)
            const isNewBest = bestTime === null || elapsedSeconds < bestTime;
            if (isNewBest) {
                bestTime = elapsedSeconds;
                localStorage.setItem('bestTime', bestTime.toString());
            }

            // Customize modal based on mode
            if (currentMode === 'learn') {
                document.getElementById('completionTitle').textContent = 'Session Complete!';
                document.getElementById('completionMessage').textContent = 'You completed 10 words!';
                document.getElementById('levelReachedRow').style.display = 'none';
                document.getElementById('levelStatsContainer').style.display = 'none';

                // Show buttons for continue or choose lesson
                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="continueLesson()">Continue</button>
                    <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
                `;
            } else {
                document.getElementById('completionTitle').textContent = 'Congratulations!';
                document.getElementById('completionMessage').textContent = `You completed ${wordsCompleted} words!`;
                document.getElementById('levelReachedRow').style.display = 'block';
                document.getElementById('levelStatsContainer').style.display = 'block';

                document.getElementById('finalLevel').textContent = currentLevelNumber;

                // Generate per-level stats HTML
                const lang = useShavianUI ? 'shavian' : 'latin';
                const t = translations[lang];
                let levelStatsHTML = '';
                levelStats.forEach(stat => {
                    const levelAccuracyFormatted = stat.accuracy.toFixed(1);
                    const levelLabel = currentMode === 'learn' ? t.lesson_label : t.level_label;
                    levelStatsHTML += `<div class="level-stat">${levelLabel} ${stat.level}: ${levelAccuracyFormatted}%</div>`;
                });
                document.getElementById('levelStatsContainer').innerHTML = levelStatsHTML;

                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="playAgain()">Play Again</button>
                `;
            }

            // Update main display (time is the primary score)
            document.getElementById('finalScore').textContent = timeFormatted;
            document.getElementById('finalScore').style.display = 'block';

            // Update all stat rows and show them for play mode
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';
            document.getElementById('finalWPM').textContent = wpm.toFixed(1);
            document.getElementById('finalWPM').parentElement.style.display = 'block';
            document.getElementById('finalLPM').textContent = lettersPerMinute.toFixed(0);
            document.getElementById('finalLPM').parentElement.style.display = 'block';

            // Show/hide best time indicator and display best time
            if (isNewBest && bestTime !== null) {
                document.getElementById('bestTimeRow').innerHTML = `<span style="color: #28a745; font-weight: bold;">New Personal Best!</span>`;
            } else if (bestTime !== null) {
                const bestMinutes = Math.floor(bestTime / 60);
                const bestSeconds = Math.floor(bestTime % 60);
                const bestTimeFormatted = `${bestMinutes}:${bestSeconds.toString().padStart(2, '0')}`;
                document.getElementById('bestTimeRow').innerHTML = `Personal Best: ${bestTimeFormatted}`;
            } else {
                document.getElementById('bestTimeRow').innerHTML = '';
            }

            document.getElementById('completionModal').classList.add('show');
        }

        function resetPractice() {
            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];
            hasPendingLigature = false;

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();
            updateLevel();

            // Start first level
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            if (currentMode === 'play') {
                const levelData = getPlayLevelData(1);
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                startLevel(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
            } else {
                // In learn mode, use the selected lesson
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;

                const levelData = getLearnLessonData(parseInt(selectedLevel));
                if (levelData) {
                    currentLevelNumber = parseInt(selectedLevel);
                    startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
                }
            }
        }

        function continueLesson() {
            // Reset session stats but keep same lesson
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            hasPendingLigature = false;

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();

            // Restart current level/lesson with same word pool
            startLevel(currentLevelWordPool, currentLevelWordCount, currentLevelType, currentLevelTitle, currentLevelTypeLabel, currentLevelCompletionCallback);
            typingInput.focus();
        }

        function chooseDifferentLesson() {
            // Hide completion modal
            document.getElementById('completionModal').classList.remove('show');

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            recentWords = [];
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            hasPendingLigature = false;
            updateStats();

            // Open lesson selector
            openLessonSelector();
        }

        // Event listeners
        let previousInput = '';
        let hasPendingLigature = false; // Track if last character was a ligature candidate
        let isInErrorState = false; // Track if last typed character was incorrect

        typingInput.addEventListener('input', (e) => {
            let userInput = e.target.value;

            // Ignore leading spaces at the start of the level
            if (previousInput === '' && userInput.trim() === '') {
                typingInput.value = '';
                return;
            }

            // Check if we can form a ligature from the last two characters (if enabled)
            if (useLigatures) {
                const inputChars = Array.from(userInput);
                if (inputChars.length >= 2) {
                    const lastTwo = inputChars[inputChars.length - 2] + inputChars[inputChars.length - 1];
                    if (COMPONENT_TO_LIGATURE[lastTwo]) {
                        // Form the ligature
                        const beforeLigature = inputChars.slice(0, -2).join('');
                        const compound = COMPONENT_TO_LIGATURE[lastTwo];
                        userInput = beforeLigature + compound;
                        typingInput.value = userInput;
                        console.log('Ligature formed:', lastTwo, '‚Üí', compound);
                    }
                }
            }

            // Expand to component characters for checking
            const inputExpanded = expandLigatures(userInput);
            const prevInputExpanded = expandLigatures(previousInput);
            const wordExpanded = expandLigatures(currentWord);

            // If in error state and user is trying to type more (not backspace), block it
            if (isInErrorState && inputExpanded.length > prevInputExpanded.length) {
                // Revert to previous input
                typingInput.value = previousInput;

                // Flash the input text red as visual feedback
                typingInput.style.animation = 'none';
                setTimeout(() => {
                    typingInput.style.animation = 'error-flash 0.4s ease-out';
                }, 10);

                return;
            }

            // If user backspaced, clear error state
            if (inputExpanded.length < prevInputExpanded.length) {
                isInErrorState = false;
            }

            // Re-expand after potential ligature formation
            const inputExpandedFinal = expandLigatures(userInput);
            const wordExpandedFinal = expandLigatures(currentWord);

            // Handle backspace - resolve pending ligature as incorrect
            if (inputExpandedFinal.length < prevInputExpanded.length && hasPendingLigature) {
                // User backspaced while a ligature candidate was pending - count it as wrong
                totalLettersTyped++;
                currentLevelLettersTyped++;
                hasPendingLigature = false;
            }

            // Track letter-level accuracy at the expanded character level
            // Only count new expanded characters typed (not backspaces)
            if (inputExpandedFinal.length > prevInputExpanded.length) {
                const expandedIndex = prevInputExpanded.length;

                // Check if we're resolving a pending ligature
                if (hasPendingLigature) {
                    // A ligature represents 2 characters being typed
                    totalLettersTyped += 2;
                    currentLevelLettersTyped += 2;

                    // Check if this completes the ligature correctly
                    if (expandedIndex < wordExpandedFinal.length &&
                        inputExpandedFinal[expandedIndex] === wordExpandedFinal[expandedIndex]) {
                        // Ligature completed correctly - count both characters as correct
                        correctLetters += 2;
                        currentLevelCorrectLetters += 2;
                    } else {
                        // Wrong continuation - the pending character was wrong
                        // Already counted 2 letters above, no additional increment needed
                        isInErrorState = true;
                    }
                    hasPendingLigature = false;
                } else {
                    // Check if this could be the start of a ligature candidate (if ligatures enabled)
                    // Look ahead to see if the next two characters form a known ligature
                    let isLigatureCandidate = false;
                    if (useLigatures && expandedIndex < wordExpandedFinal.length - 1) {
                        const twoChars = wordExpandedFinal[expandedIndex] + wordExpandedFinal[expandedIndex + 1];
                        isLigatureCandidate = COMPONENT_TO_LIGATURE[twoChars] !== undefined;
                    }

                    if (expandedIndex < wordExpandedFinal.length &&
                        inputExpandedFinal[expandedIndex] === wordExpandedFinal[expandedIndex] &&
                        isLigatureCandidate) {
                        // This is a potential ligature start - mark as pending, don't count yet
                        hasPendingLigature = true;
                    } else {
                        // Normal character - count it now
                        totalLettersTyped++;
                        currentLevelLettersTyped++;

                        if (expandedIndex < wordExpandedFinal.length &&
                            inputExpandedFinal[expandedIndex] === wordExpandedFinal[expandedIndex]) {
                            correctLetters++;
                            currentLevelCorrectLetters++;
                        } else {
                            // Wrong character typed - enter error state
                            isInErrorState = true;
                        }
                    }
                }
            }

            // Use typingInput.value in case we replaced a ligature
            previousInput = typingInput.value;
            updateWordDisplay();
            updateStats();
            checkCompletion();
        });

        // No need for separate keydown handler - space is part of the word now
        // Auto-advance happens in checkCompletion when word+space is typed

        // Burger menu functions
        function toggleBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.toggle('show');
        }

        function closeBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.remove('show');
        }

        // Close burger menu if clicking outside
        window.addEventListener('click', function(e) {
            if (!e.target.matches('.burger-btn') && !e.target.closest('.burger-menu')) {
                closeBurgerMenu();
            }
        });

        // Content modal functions
        async function openContentModal(page) {
            closeBurgerMenu();

            const modal = document.getElementById('contentModal');
            const titleEl = document.getElementById('contentModalTitle');
            const bodyEl = document.getElementById('contentModalBody');

            // Set title using translations
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];
            const titleKey = 'title' + page.charAt(0).toUpperCase() + page.slice(1);
            titleEl.textContent = t[titleKey] || page.charAt(0).toUpperCase() + page.slice(1);
            bodyEl.innerHTML = 'Loading...';

            // Show modal
            modal.classList.add('show');

            // Load content based on current language
            const filename = `${page}_${lang}.html`;

            try {
                const response = await fetch(filename);
                if (response.ok) {
                    const html = await response.text();
                    bodyEl.innerHTML = html;
                } else {
                    bodyEl.innerHTML = '<p>Content not found.</p>';
                }
            } catch (error) {
                bodyEl.innerHTML = '<p>Error loading content.</p>';
                console.error('Error loading content:', error);
            }
        }

        function closeContentModal() {
            document.getElementById('contentModal').classList.remove('show');
        }

        // Welcome modal functions
        function onDialectChangeWelcome() {
            const selected = document.querySelector('input[name="dialectWelcome"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    initializeGame();
                });
            }
        }

        function onLayoutChangeWelcome() {
            currentLayout = document.getElementById('layoutSelectWelcome').value;
            localStorage.setItem('keyboardLayout', currentLayout);

            // Show/hide ligature toggle
            const supportsLigatures = currentLayout === 'imperial' || currentLayout === 'new-imperial' || currentLayout === 'qwerty' || currentLayout === 'jafl';
            document.getElementById('ligatureWelcomeOption').style.display = supportsLigatures ? 'block' : 'none';
        }

        function onLigatureToggleWelcome() {
            useLigatures = document.getElementById('ligatureToggleWelcome').checked;
            localStorage.setItem('useLigatures', useLigatures);
        }

        function toggleShavianUIWelcome() {
            useShavianUI = document.getElementById('shavianUIToggleWelcome').checked;
            localStorage.setItem('useShavianUI', useShavianUI);
            updateWelcomeLanguage();
        }

        function updateWelcomeLanguage() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            // TODO: Add Shavian translations for welcome screen
            if (useShavianUI) {
                document.getElementById('welcomeTitle').textContent = 'êë¢êëßêë§êëíêë≥êë• êëë ¬∑êëñêë∑ êëëêë≤êëê!';
                document.getElementById('welcomeSubtitle').textContent = 'êëóêëµêëü êëòêëπ êëêêëÆêëßêëìêëºêë©êëØêëïêë©êëü êëë êëúêëßêëë êëïêëëêë∏êëëêë©êëõ:';
                document.getElementById('welcomeDialectLabel').textContent = 'êëóêëµêëü êëïêëêêëßêë§êë¶êëô';
                document.getElementById('welcomeDialectBritish').textContent = 'êëöêëÆêë¶êëëêë¶êëñ';
                document.getElementById('welcomeDialectAmerican').textContent = 'êë©êë•êëßêëÆêë¶êëíêë©êëØ';
                document.getElementById('welcomeLayoutLabel').textContent = 'êëíêë∞êëöêë™êëÆêëõ êë§êë±êë¨êëë';
                document.getElementById('welcomeLigatureLabel').textContent = 'êë∑êëëêë©êë•êëßêëëêë¶êëí êë§êë¶êëúêë©êëóêëºêëü (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)';
                document.getElementById('welcomeShavianUILabel').textContent = 'êëõêë¶êëïêëêêë§êë± UI êë¶êëØ ¬∑êëñêë±êëùêëæêëØ';
                document.getElementById('welcomeStartButton').textContent = 'êëïêëëêë∏êëë';
            } else {
                document.getElementById('welcomeTitle').textContent = 'Welcome to Shaw Type!';
                document.getElementById('welcomeSubtitle').textContent = 'Choose your preferences to get started:';
                document.getElementById('welcomeDialectLabel').textContent = 'Choose spelling';
                document.getElementById('welcomeDialectBritish').textContent = 'British';
                document.getElementById('welcomeDialectAmerican').textContent = 'American';
                document.getElementById('welcomeLayoutLabel').textContent = 'Keyboard Layout';
                document.getElementById('welcomeLigatureLabel').textContent = 'Automatic ligatures (êë©+êëÆ‚Üíêëº, êëò+êëµ‚Üíêëø)';
                document.getElementById('welcomeShavianUILabel').textContent = 'Display UI in Shavian';
                document.getElementById('welcomeStartButton').textContent = 'Start';
            }
        }

        function closeWelcomeModal() {
            document.getElementById('welcomeModal').classList.remove('show');
            // Ensure Play mode is active when starting fresh
            setMode('play');
            initializeGame();
            // Don't auto-focus on mobile - let user tap when ready
        }

        function showWelcomeIfNeeded() {
            const hideWelcome = localStorage.getItem('hideWelcome');
            if (hideWelcome !== 'true') {
                // Sync welcome modal with current settings
                const dialectRadio = document.querySelector(`input[name="dialectWelcome"][value="${currentDialect}"]`);
                if (dialectRadio) dialectRadio.checked = true;

                document.getElementById('layoutSelectWelcome').value = currentLayout;
                document.getElementById('ligatureToggleWelcome').checked = useLigatures;
                document.getElementById('shavianUIToggleWelcome').checked = useShavianUI;

                // Show/hide ligature option
                const supportsLigatures = currentLayout === 'imperial' || currentLayout === 'new-imperial' || currentLayout === 'qwerty' || currentLayout === 'jafl';
                document.getElementById('ligatureWelcomeOption').style.display = supportsLigatures ? 'block' : 'none';

                // Update welcome language
                updateWelcomeLanguage();

                document.getElementById('welcomeModal').classList.add('show');
            }
        }

        function toggleHideWelcome() {
            const hideWelcome = document.getElementById('hideWelcomeToggle').checked;
            localStorage.setItem('hideWelcome', hideWelcome.toString());
        }

        // Settings functions
        function openSettings() {
            // Sync settings with current state
            const dialectRadio = document.querySelector(`input[name="dialectSettings"][value="${currentDialect}"]`);
            if (dialectRadio) dialectRadio.checked = true;

            document.getElementById('layoutSelectSettings').value = currentLayout;
            document.getElementById('ligatureToggleSettings').checked = useLigatures;

            // Sync hide welcome checkbox
            const hideWelcome = localStorage.getItem('hideWelcome');
            document.getElementById('hideWelcomeToggle').checked = (hideWelcome === 'true');

            // Show/hide ligature option based on current layout
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'new-imperial' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';

            document.getElementById('settingsModal').classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        // Lesson selector functions
        function openLessonSelector() {
            // Get current translations
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            const lessonList = document.getElementById('lessonList');
            lessonList.innerHTML = '';

            // Dynamically determine max level from actual data
            const maxLevel = learnWords ? Object.keys(learnWords).length : 6;

            // Add lesson options
            for (let i = 1; i <= maxLevel; i++) {
                const levelData = learnWords[i];

                if (levelData) {
                    const lessonBtn = document.createElement('div');
                    lessonBtn.className = 'lesson-option';
                    const translatedName = translateLessonName(levelData.name);
                    const translatedDescription = translateLessonDescription(levelData.description);
                    lessonBtn.innerHTML = `
                        <strong>${t.lessonPrefix} ${i}: ${translatedName}</strong>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #888;">${translatedDescription}</p>
                    `;
                    lessonBtn.onclick = () => selectLesson(i);
                    if (selectedLevel == i) {
                        lessonBtn.style.background = '#f0f0ff';
                    }
                    lessonList.appendChild(lessonBtn);
                }
            }

            document.getElementById('lessonModal').classList.add('show');
        }

        function selectLesson(level) {
            selectedLevel = level;
            closeLessonModal();

            // Show game content
            showGameContent();

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            levelStats = [];
            hasPendingLigature = false;

            updateStats();

            // Start the selected lesson
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Set instructions in subtitle
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            const levelData = getLearnLessonData(parseInt(level));
            if (levelData) {
                currentLevelNumber = parseInt(level);
                startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
            }
        }

        function closeLessonModal() {
            document.getElementById('lessonModal').classList.remove('show');
        }

        function toggleShavianUI() {
            useShavianUI = document.getElementById('shavianUIToggle').checked;
            localStorage.setItem('useShavianUI', useShavianUI);
            updateUILanguage();
        }

        function updateUILanguage() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Update title
            document.getElementById('mainTitle').textContent = t.title;

            // Update subtitle based on current state
            const subtitle = document.getElementById('mainSubtitle');
            const homeScreen = document.getElementById('homeScreen');
            if (!homeScreen.classList.contains('hidden')) {
                // On home screen, show default subtitle
                subtitle.textContent = t.subtitle;
            } else {
                // In game, subtitle is managed by game logic
                updateSubtitleForGame();
            }

            // Update home screen buttons
            document.getElementById('homePlayBtn').textContent = t.play;
            document.getElementById('homePracticeBtn').textContent = t.practice;
            document.getElementById('homeSettingsBtn').textContent = t.settings;

            // Update stats labels
            document.querySelector('.stat-label').textContent =
                currentMode === 'learn' ? t.lesson_label : t.level_label;
            document.querySelectorAll('.stat-label')[1].textContent = t.words;
            document.querySelectorAll('.stat-label')[2].textContent = t.accuracy;

            // Update completion modal
            document.querySelector('#completionModal h2').textContent = t.congratulations;
            document.querySelector('#completionModal p').textContent = t.completed30;
            document.querySelectorAll('.stat-row')[0].childNodes[0].textContent = t.wpm + ' ';
            document.querySelectorAll('.stat-row')[1].childNodes[0].textContent = t.lettersPerMin + ' ';
            document.querySelectorAll('.stat-row')[2].childNodes[0].textContent = t.accuracy_final + ' ';
            document.querySelectorAll('.stat-row')[4].childNodes[0].textContent = t.levelReached + ' ';
            document.querySelector('#completionModal button').textContent = t.practiceAgain;

            // Update settings modal
            document.querySelector('#settingsModal h2').textContent = t.settingsTitle;
            document.querySelector('#shavianUIToggle + span').textContent = t.displayShavian;
            document.querySelector('.settings-option-desc').textContent = t.displayShavianDesc;

            // Update settings labels
            document.querySelector('.settings-option label').textContent = t.keyboardLayout;
            document.querySelector('#ligatureToggleSettings + span').textContent = t.ligatures;

            // Update lesson modal
            document.getElementById('lessonModalTitle').textContent = t.lessonModalTitle;
            document.getElementById('lessonModalSubtitle').textContent = t.lessonModalSubtitle;

            // Update burger menu items
            document.getElementById('menuAbout').textContent = t.menuAbout;
            document.getElementById('menuKeyboards').textContent = t.menuKeyboards;
            document.getElementById('menuResources').textContent = t.menuResources;
            document.getElementById('menuSettings').textContent = t.menuSettings;

            // Update settings dialog labels
            document.getElementById('settingsDialectLabel').textContent = t.dialectLabel;
            document.getElementById('settingsDialectBritish').textContent = t.dialectBritish;
            document.getElementById('settingsDialectAmerican').textContent = t.dialectAmerican;
            document.getElementById('settingsHideWelcome').textContent = t.hideWelcome;

            // Update layout select options
            updateLayoutSelectOptions();
        }

        function updateLayoutSelectOptions() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            const t = translations[lang];

            // Update both layout selects (settings and welcome)
            const selects = [
                document.getElementById('layoutSelectSettings'),
                document.getElementById('layoutSelectWelcome')
            ];

            selects.forEach(select => {
                if (select) {
                    const currentValue = select.value;
                    const options = select.querySelectorAll('option');

                    options.forEach(option => {
                        const value = option.value;
                        switch(value) {
                            case 'imperial':
                                option.textContent = t.layoutImperial;
                                break;
                            case 'new-imperial':
                                option.textContent = t.layoutNewImperial;
                                break;
                            case 'qwerty':
                                option.textContent = t.layoutQwerty;
                                break;
                            case '2layer':
                                option.textContent = t.layout2layer;
                                break;
                            case 'jafl':
                                option.textContent = t.layoutJafl;
                                break;
                        }
                    });

                    // Restore selected value
                    select.value = currentValue;
                }
            });
        }

        // Load saved preferences
        function loadPreferences() {
            // Load Shavian UI preference
            const savedShavianUI = localStorage.getItem('useShavianUI');
            if (savedShavianUI !== null) {
                useShavianUI = savedShavianUI === 'true';
                document.getElementById('shavianUIToggle').checked = useShavianUI;
            }

            // Load dialect preference
            const savedDialect = localStorage.getItem('dialect');
            if (savedDialect !== null && (savedDialect === 'gb' || savedDialect === 'us')) {
                currentDialect = savedDialect;
            }

            // Load keyboard layout
            const savedLayout = localStorage.getItem('keyboardLayout');
            if (savedLayout !== null) {
                currentLayout = savedLayout;
            }

            // Load ligature preference
            const savedLigatures = localStorage.getItem('useLigatures');
            if (savedLigatures !== null) {
                useLigatures = savedLigatures === 'true';
            }

            // Load current mode (just restore the value, no UI updates needed on home screen)
            const savedMode = localStorage.getItem('currentMode');
            if (savedMode !== null && (savedMode === 'learn' || savedMode === 'play')) {
                currentMode = savedMode;
            }

            // Load best time
            const savedBestTime = localStorage.getItem('bestTime');
            if (savedBestTime !== null) {
                bestTime = parseFloat(savedBestTime);
            }
        }

        // Start the app
        loadPreferences();
        init();
        updateUILanguage();
    </script>
</body>
</html>
