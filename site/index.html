<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaw Type - Shavian Typing Practice</title>
    <link rel="icon" type="image/png" sizes="64x64" href="favicon-64x64.png">
    <link rel="icon" type="image/png" sizes="128x128" href="favicon-128x128.png">
    <link rel="icon" type="image/png" sizes="180x180" href="favicon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="favicon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="favicon-512x512.png">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="virtual-keyboard.css">

    <!-- Load translations synchronously before anything else -->
    <script>
        // Global translations object - loaded synchronously
        window.translations = {
            latin: null,
            shavian_british: null,
            shavian_american: null
        };

        // Load translations synchronously using XMLHttpRequest (blocking)
        function loadTranslationsSync() {
            const files = [
                { key: 'latin', url: 'translations_latin.json' },
                { key: 'shavian_british', url: 'translations_british.json' },
                { key: 'shavian_american', url: 'translations_american.json' }
            ];

            files.forEach(file => {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', file.url, false); // false = synchronous
                xhr.send();
                if (xhr.status === 200) {
                    window.translations[file.key] = JSON.parse(xhr.responseText);
                } else {
                    console.error(`Failed to load ${file.url} - status: ${xhr.status}`);
                }
            });
        }

        loadTranslationsSync();
    </script>

    <style>
        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Medium.otf') format('opentype');
            font-weight: 500;
            font-style: normal;
        }

        @font-face {
            font-family: 'Inter-Alia';
            src: url('fonts/InterAlia-Bold.otf') format('opentype');
            font-weight: 700;
            font-style: normal;
        }

        @font-face {
            font-family: 'Ormin';
            src: url('fonts/Ormin-Regular.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter-Alia', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        p {
            margin-bottom: 1em;
        }

        h3 {
            color: #333;
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-size: 1.2em;
            font-weight: 600;
        }

        details {
            margin-bottom: 0.75em;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 0.5em;
        }

        summary {
            font-weight: 600;
            color: #667eea;
            cursor: pointer;
            padding: 0.5em;
            border-radius: 4px;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary:hover {
            background-color: #f0f0ff;
        }

        summary::marker {
            color: #667eea;
        }

        details[open] summary {
            margin-bottom: 0.5em;
        }

        details > ul {
            margin-left: 2em;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        ul {
            margin-left: 1.5em;
            margin-bottom: 0.5em;
        }

        li {
            margin-bottom: 0.25em;
            line-height: 1.5;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .back-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
            min-width: 40px;
        }

        .back-btn:hover {
            color: #5568d3;
        }

        .back-btn.hidden {
            visibility: hidden;
        }

        h1 {
            text-align: center;
            color: #333;
            margin: 0;
            font-size: 36px;
            font-weight: bold;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            flex: 1;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 18px;
            font-weight: normal;
        }

        .home-screen {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 50px;
        }

        .home-screen.hidden {
            display: none;
        }

        .countdown-screen {
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            padding: 40px;
            margin-top: 50px;
        }

        .countdown-screen.hidden {
            display: none !important;
        }

        .countdown-screen:not(.hidden) {
            display: flex;
        }

        .home-btn {
            padding: 20px;
            font-size: 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .home-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .game-content {
            display: block;
        }

        .game-content.hidden {
            display: none;
        }

        .word-display {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            min-height: 100px;
            position: relative;
            overflow: hidden;
        }

        .word-carousel {
            position: relative;
            height: 60px;
            overflow: hidden;
        }

        .word-slot {
            position: absolute;
            top: 50%;
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
            white-space: nowrap;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Position classes for the carousel - transform will be set dynamically */
        .word-slot.pos-prev-prev {
            opacity: 0;
        }

        .word-slot.pos-prev {
            opacity: 0.2;
        }

        .word-slot.pos-current {
            opacity: 1;
        }

        .word-slot.pos-next {
            opacity: 0.3;
        }

        .word-slot.pos-next-next {
            opacity: 0;
        }

        .word-display .word {
            font-size: 48px;
            font-family: 'Ormin', 'Inter-Alia', sans-serif;
            letter-spacing: 4px;
        }

        .word-display .char {
            display: inline-block;
            transition: all 0.2s ease;
            white-space: pre; /* Preserve spaces */
        }

        .word-display .char.correct {
            opacity: 0.4;
            color: #28a745;
        }

        .word-display .char.incorrect {
            color: #dc3545;
            font-weight: bold;
        }

        .input-container {
            margin-bottom: 20px;
        }

        #typingInput {
            width: 100%;
            padding: 15px;
            font-size: 32px;
            font-family: 'Inter-Alia', sans-serif;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            text-align: center;
            letter-spacing: 4px;
            transition: border-color 0.3s;
        }

        #typingInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #333;
            font-size: 24px;
            font-weight: bold;
        }

        .countdown-text {
            font-size: 72px;
            font-weight: bold;
            color: #667eea;
            animation: countdown-pulse 0.5s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes error-flash {
            0% {
                background-color: #e74c3c;
            }
            100% {
                background-color: white;
            }
        }

        .completion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .completion-modal.show {
            display: flex;
        }

        .completion-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .completion-content h2 {
            color: #667eea;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .completion-content .final-score {
            font-size: 48px;
            font-weight: bold;
            color: #333;
            margin: 20px 0;
        }

        .completion-content .stat-row {
            margin: 10px 0;
            font-size: 18px;
            color: #666;
        }

        .level-stats-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .level-stat {
            padding: 5px 0;
            font-size: 14px;
            color: #555;
            border-bottom: 1px solid #e0e0e0;
        }

        .level-stat:last-child {
            border-bottom: none;
        }

        .completion-content button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .completion-content button:hover {
            background: #5568d3;
        }

        .mode-btn {
            padding: 10px 30px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #f0f0ff;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .settings-btn {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s;
        }

        .settings-btn:hover {
            background: #f0f0ff;
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
        }

        .settings-content h2 {
            color: #667eea;
            font-size: 28px;
            margin-bottom: 25px;
        }

        .settings-option {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .settings-option:last-child {
            border-bottom: none;
        }

        .settings-option label {
            display: flex;
            align-items: center;
            font-size: 16px;
            color: #333;
            cursor: pointer;
        }

        .settings-option input[type="checkbox"] {
            margin-right: 12px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .settings-option-desc {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
            margin-left: 32px;
        }

        .settings-close-btn {
            margin-top: 25px;
            padding: 12px 30px;
            font-size: 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .settings-close-btn:hover {
            background: #5568d3;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 32px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: #333;
        }

        .completion-content,
        .settings-content {
            position: relative;
        }

        #lengthSelect {
            padding: 8px 15px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .burger-menu {
            position: relative;
            display: inline-block;
            min-width: 40px;
        }

        .burger-btn {
            font-size: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            color: #667eea;
            transition: color 0.3s;
        }

        .burger-btn:hover {
            color: #5568d3;
        }

        .burger-dropdown {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 8px;
            z-index: 1000;
            overflow: hidden;
        }

        .burger-dropdown.show {
            display: block;
        }

        .burger-dropdown a {
            color: #333;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: background 0.3s;
        }

        .burger-dropdown a:hover {
            background: #f0f0ff;
        }

        .copyright {
            text-align: center;
            color: #000000;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px;
        }

        .lesson-option {
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .lesson-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .lesson-option strong {
            color: #333;
            font-size: 16px;
        }

        /* Mobile-friendly compact layout */
        @media (max-width: 768px) {
            h1 {
                font-size: 32px;
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 16px;
                margin-bottom: 20px;
            }

            .word-display {
                padding: 20px;
                margin-bottom: 20px;
                min-height: 60px;
            }

            .word-display .word {
                font-size: 36px;
                letter-spacing: 2px;
            }

            #typingInput {
                padding: 12px;
                font-size: 24px;
            }

            .input-container {
                margin-bottom: 15px;
            }

            .stats {
                gap: 15px;
                margin-bottom: 15px;
            }

            .countdown-text {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-bar">
            <button class="back-btn hidden" id="backBtn" onclick="goHome()">â†</button>
            <h1 id="mainTitle">Shaw Type</h1>
            <div class="burger-menu">
                <button class="burger-btn" onclick="toggleBurgerMenu()">â˜°</button>
                <div class="burger-dropdown" id="burgerDropdown">
                    <a id="menuAbout" href="#" onclick="openContentModal('about'); return false;">About</a>
                    <a id="menuKeyboards" href="#" onclick="openContentModal('keyboards'); return false;">Keyboards</a>
                    <a id="menuResources" href="#" onclick="openContentModal('resources'); return false;">Resources</a>
                    <a id="menuHighScores" href="#" onclick="openHighScores(); closeBurgerMenu(); return false;">Scores</a>
                    <a id="menuSettings" href="#" onclick="openSettings(); closeBurgerMenu(); return false;">Settings</a>
                </div>
            </div>
        </div>

        <div class="subtitle" id="mainSubtitle">ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯ ğ‘‘ğ‘²ğ‘ğ‘¦ğ‘™ ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•</div>

        <!-- Home Screen -->
        <div class="home-screen" id="homeScreen">
            <button class="home-btn" id="homePlayBtn" onclick="startPlay()">Play</button>
            <button class="home-btn" id="homePracticeBtn" onclick="startPractice()">Practice</button>
            <button class="home-btn" id="homeSettingsBtn" onclick="openSettings()">Settings</button>
        </div>

        <!-- Countdown Screen -->
        <div class="countdown-screen hidden" id="countdownScreen">
            <div class="countdown-text" id="countdownText"></div>
        </div>

        <!-- Game Content -->
        <div class="game-content hidden" id="gameContent">
        <div class="word-display">
            <div class="word-carousel">
                <div class="word-slot slot-0" id="wordSlot0"></div>
                <div class="word-slot slot-1" id="wordSlot1"></div>
                <div class="word-slot slot-2" id="wordSlot2"></div>
                <div class="word-slot slot-3" id="wordSlot3"></div>
            </div>
        </div>

        <div class="input-container">
            <input type="text" id="typingInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label" id="levelLabel">Level</div>
                <div class="stat-value" id="levelDisplay">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Words</div>
                <div class="stat-value" id="wordCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">100%</div>
            </div>
        </div>

        <div id="currentLessonInfo" style="display: none; text-align: left; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 13px; color: #666;">
            <strong id="currentLessonName"></strong>
        </div>

        </div> <!-- End game-content -->
    </div> <!-- End container -->

    <div class="copyright">
        @2025 joro.io
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="completion-content">
            <span class="modal-close" onclick="goHome()">&times;</span>
            <h2 id="completionTitle">Congratulations!</h2>
            <p id="completionMessage">You completed 30 words!</p>
            <div class="final-score" id="finalScore">--</div>
            <div class="stat-row">WPM: <span id="finalWPM">--</span></div>
            <div class="stat-row">Letters/min: <span id="finalLPM">--</span></div>
            <div class="stat-row">Accuracy: <span id="finalAccuracy">--</span></div>
            <div class="stat-row" id="bestTimeRow"></div>
            <div class="stat-row" id="levelReachedRow">Level Reached: <span id="finalLevel">--</span></div>
            <div id="levelStatsContainer" class="level-stats-container"></div>
            <div id="completionButtons">
                <button onclick="resetPractice()">Practice Again</button>
            </div>
        </div>
    </div>

    <!-- High Scores Modal -->
    <div class="settings-modal" id="highScoresModal">
        <div class="settings-content">
            <span class="modal-close" onclick="closeHighScores()">&times;</span>
            <h2 id="highScoresTitle">Scores</h2>
            <div id="highScoresContent" style="margin-top: 20px;">
                <!-- High scores will be populated here -->
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="home-btn" id="highScoresCloseBtn" onclick="closeHighScores()" style="padding: 12px 40px; font-size: 16px;">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <span class="modal-close" onclick="closeSettings()">&times;</span>
            <h2>Settings</h2>

            <div class="settings-option">
                <label id="settingsDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="gb" checked onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSettings" value="us" onchange="onDialectChangeSettings()" style="margin-right: 8px;">
                        <span id="settingsDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <div class="settings-option">
                <label style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;" id="settingsKeyboardLayoutLabel">
                    Keyboard Layout
                </label>
                <select id="layoutSelectSettings" onchange="onLayoutChangeSettings()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="igc">Imperial Good Companion</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option" id="ligatureSettingOption">
                <label>
                    <input type="checkbox" id="ligatureToggleSettings" onchange="onLigatureToggleSettings()">
                    <span>Automatic ligatures (ğ‘©+ğ‘®â†’ğ‘¼, ğ‘˜+ğ‘µâ†’ğ‘¿)</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="virtualKeyboardToggle" onchange="toggleVirtualKeyboard()">
                    <span id="settingsVirtualKeyboard">Show virtual keyboard</span>
                </label>
            </div>

            <div class="settings-option">
                <label>
                    <input type="checkbox" id="shavianUIToggle" onchange="toggleShavianUI()">
                    <span>Display UI in Shavian</span>
                </label>
            </div>

            <div class="settings-option">
                <label style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;" id="settingsLevelCountLabel">
                    Play Mode Level Count
                </label>
                <select id="levelCountSelect" onchange="onLevelCountChange()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="3">3 levels (15 words)</option>
                    <option value="6" selected>6 levels (30 words)</option>
                    <option value="10">10 levels (50 words)</option>
                </select>
            </div>

        </div>
    </div>

    <!-- Content Modal -->
    <div class="settings-modal" id="contentModal">
        <div class="settings-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <span class="modal-close" onclick="closeContentModal()">&times;</span>
            <div id="contentModalBody" style="margin-top: 20px;">
                Loading...
            </div>
        </div>
    </div>

    <!-- Welcome Modal -->
    <!-- Splash Screen (What's New) -->
    <div class="settings-modal" id="splashModal">
        <div class="settings-content" style="max-width: 600px;">
            <h2 id="splashTitle">Welcome to Shaw Type!</h2>
            <div id="splashContent" style="margin: 20px 0;">
                Loading...
            </div>

            <button id="splashContinueBtn" class="settings-close-btn" onclick="closeSplashModal()" style="margin-top: 15px; width: 100%;">Continue</button>

            <div style="margin: 15px 0; text-align: center;">
                <label style="display: inline-flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="dontShowSplash" style="cursor: pointer;">
                    <span id="splashDontShowAgain" style="color: #666; font-size: 14px;">Don't show this again</span>
                </label>
            </div>
        </div>
    </div>

    <!-- First-Time Setup Dialog -->
    <div class="settings-modal" id="setupModal">
        <div class="settings-content" style="max-width: 500px;">
            <h2 id="setupTitle">Get Started</h2>
            <p id="setupSubtitle" style="margin: 15px 0; color: #666;">Choose your keyboard layout and spelling preference:</p>

            <div class="settings-option">
                <label id="setupKeyboardLayoutLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Keyboard Layout
                </label>
                <select id="layoutSelectSetup" onchange="onLayoutChangeSetup()" style="width: 100%; padding: 8px; font-size: 16px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="imperial">Shaw Imperial</option>
                    <option value="igc">Imperial Good Companion</option>
                    <option value="qwerty">Shaw QWERTY</option>
                    <option value="2layer">Shaw 2-layer (shift)</option>
                    <option value="jafl">Shaw-JAFL</option>
                </select>
            </div>

            <div class="settings-option">
                <label id="setupDialectLabel" style="display: block; margin-bottom: 10px; color: #666; font-weight: normal;">
                    Choose spelling
                </label>
                <div style="display: flex; gap: 20px;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSetup" value="gb" checked onchange="onDialectChangeSetup()" style="margin-right: 8px;">
                        <span id="setupDialectBritish">British</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="dialectSetup" value="us" onchange="onDialectChangeSetup()" style="margin-right: 8px;">
                        <span id="setupDialectAmerican">American</span>
                    </label>
                </div>
            </div>

            <p id="setupNote" style="margin: 20px 0; color: #999; font-size: 14px; font-style: italic;">
                Don't worry too much. This choice, and more besides, can be changed later in settings.
            </p>

            <button id="setupStartBtn" class="settings-close-btn" onclick="closeSetupModal()" style="margin-top: 15px; width: 100%;">Start Practicing!</button>
        </div>
    </div>

    <!-- Lesson Selector Modal -->
    <div class="settings-modal" id="lessonModal">
        <div class="settings-content" style="max-width: 500px;">
            <span class="modal-close" onclick="closeLessonModal()">&times;</span>
            <h2 id="lessonModalTitle">Choose a Lesson</h2>
            <p id="lessonModalSubtitle" style="margin: 15px 0; color: #666;">Select a lesson to practice:</p>

            <div id="lessonList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Lessons will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Virtual Keyboard Window -->
    <div id="virtualKeyboard" class="virtual-keyboard" style="display: none;">
        <div class="keyboard-header">
            <span class="keyboard-title">Virtual Keyboard</span>
            <span class="keyboard-close" onclick="toggleVirtualKeyboard()">&times;</span>
        </div>
        <div class="keyboard-body">
            <!-- Number row -->
            <div class="keyboard-row">
                <div class="key" data-key="`"></div>
                <div class="key" data-key="1"></div>
                <div class="key" data-key="2"></div>
                <div class="key" data-key="3"></div>
                <div class="key" data-key="4"></div>
                <div class="key" data-key="5"></div>
                <div class="key" data-key="6"></div>
                <div class="key" data-key="7"></div>
                <div class="key" data-key="8"></div>
                <div class="key" data-key="9"></div>
                <div class="key" data-key="0"></div>
                <div class="key" data-key="-"></div>
                <div class="key" data-key="="></div>
                <div class="key key-wide" data-key="Backspace">âŒ«</div>
            </div>
            <!-- QWERTY row -->
            <div class="keyboard-row">
                <div class="key key-wide" data-key="Tab">â‡¥</div>
                <div class="key" data-key="q"></div>
                <div class="key" data-key="w"></div>
                <div class="key" data-key="e"></div>
                <div class="key" data-key="r"></div>
                <div class="key" data-key="t"></div>
                <div class="key" data-key="y"></div>
                <div class="key" data-key="u"></div>
                <div class="key" data-key="i"></div>
                <div class="key" data-key="o"></div>
                <div class="key" data-key="p"></div>
                <div class="key" data-key="["></div>
                <div class="key" data-key="]"></div>
                <div class="key" data-key="\"></div>
            </div>
            <!-- Home row -->
            <div class="keyboard-row">
                <div class="key key-wider" data-key="CapsLock">â‡ª</div>
                <div class="key" data-key="a"></div>
                <div class="key" data-key="s"></div>
                <div class="key" data-key="d"></div>
                <div class="key" data-key="f"></div>
                <div class="key" data-key="g"></div>
                <div class="key" data-key="h"></div>
                <div class="key" data-key="j"></div>
                <div class="key" data-key="k"></div>
                <div class="key" data-key="l"></div>
                <div class="key" data-key=";"></div>
                <div class="key" data-key="'"></div>
                <div class="key key-wider" data-key="Enter">â</div>
            </div>
            <!-- Bottom row -->
            <div class="keyboard-row">
                <div class="key key-widest" data-key="Shift" data-code="ShiftLeft">â‡§</div>
                <div class="key" data-key="z"></div>
                <div class="key" data-key="x"></div>
                <div class="key" data-key="c"></div>
                <div class="key" data-key="v"></div>
                <div class="key" data-key="b"></div>
                <div class="key" data-key="n"></div>
                <div class="key" data-key="m"></div>
                <div class="key" data-key=","></div>
                <div class="key" data-key="."></div>
                <div class="key" data-key="/"></div>
                <div class="key key-widest" data-key="Shift" data-code="ShiftRight">â‡§</div>
            </div>
            <!-- Space row -->
            <div class="keyboard-row">
                <div class="key key-space" data-key=" ">Space</div>
            </div>
        </div>
    </div>

    <script>
        // Words will be loaded from JSON file
        let wordsByLength = {};
        let learnWordsImperial = {};
        let learnWordsImperialNoLig = {};
        let learnWordsNewImperial = {};
        let learnWordsNewImperialNoLig = {};
        let learnWordsQwerty = {};
        let learnWords2layer = {};
        let learnWordsJafl = {};
        let learnWordsJaflNoLig = {};
        let wordsLoaded = false;

        // Current level/lesson state
        let currentLevelWordPool = []; // Source pool of words for current level/lesson
        let currentLevelWordCount = 5; // Number of words to complete this level/lesson
        let currentLevelTitle = ''; // Display title for current level/lesson
        let currentLevelType = 'level'; // 'level' or 'lesson' for UI labels
        let currentLevelTypeLabel = 'Level'; // Display label for UI
        let currentLevelNumber = 1;
        let currentLevelCompletionCallback = null; // Function to call when level completes

        // Carousel: 4 slots, we track which slot index maps to which position
        let carouselOffset = 0; // Current slot index for "current" word
        let words = ['', '', '', '']; // Words in slots [0, 1, 2, 3]
        let currentWord = ''; // The actual current word being typed
        let wordsCompleted = 0;
        let wordsInCurrentLevel = 0; // Words completed in current level
        let totalLettersTyped = 0;
        let correctLetters = 0;
        let recentWords = []; // Track recent words to avoid repeats
        let startTime = null; // Session start time
        let pauseStartTime = null; // When timer was paused
        let totalPausedTime = 0; // Cumulative paused time in milliseconds
        let bestTime = null; // Legacy - migrated to highScores
        let highScores = {}; // High scores keyed by level count: { '3': {time, wpm, accuracy}, '6': {...}, '10': {...} }
        let levelStats = []; // Per-level statistics
        let currentLevelLettersTyped = 0; // Letters typed in current level
        let currentLevelCorrectLetters = 0; // Correct letters in current level

        // Shadow input: faithful representation of what user typed (browsers may strip combining chars)
        let shadowInput = '';

        // Track replacement info from beforeinput event (for insertReplacementText)
        let pendingReplacementStart = -1;
        let pendingReplacementEnd = -1;

        // Ligature mappings - each ligature can have multiple 2-character input sequences
        const VS1 = '\uFE00';
        const LIGATURES = {
            'ğ‘¼': [['ğ‘©', 'ğ‘®']],                      // ER: one way
            'ğ‘¸': [['ğ‘­', 'ğ‘®']],                      // AR: one way
            'ğ‘¹': [['ğ‘·', 'ğ‘®']],                      // OR: one way
            'ğ‘¿': [['ğ‘˜', 'ğ‘µ']],                      // YEW: one way
            'ğ‘½': [['ğ‘¾', 'ğ‘®']],                      // AIR (compound): one way
            'ğ‘»': [['ğ‘»', 'ğ‘®'], ['ğ‘»' + VS1, 'ğ‘®'], ['ğ‘³', 'ğ‘®']],  // ERR: three ways (err+roar, err+VS1+roar, up+roar JAFL)
            'ğ‘º': [['ğ‘º', 'ğ‘®'], ['ğ‘º' + VS1, 'ğ‘®']]                // AIR (simple): two ways (air+roar, air+VS1+roar)
        };

        // Reverse mapping: all component sequences to their compound ligature
        const COMPONENT_TO_LIGATURE = {};
        Object.keys(LIGATURES).forEach(compound => {
            LIGATURES[compound].forEach(sequence => {
                const key = sequence.join('');
                COMPONENT_TO_LIGATURE[key] = compound;
            });
        });

        // QWERTY to Shavian keyboard mappings for virtual keyboard mode
        const KEYBOARD_MAPS = {
            'imperial': {
                // Number row (1-0)
                '1': 'ğ‘¶', '2': 'ğ‘¬', '3': 'ğ‘«', '4': 'ğ‘œ', '5': 'ğ‘–',
                '6': 'ğ‘—', '7': 'ğ‘™', '8': 'ğ‘˜', '9': 'ğ‘¡', '0': 'ğ‘”',
                '`': '`', '-': '-', '=': '=',
                // QWERTY row (q-])
                'q': 'ğ‘­', 'w': 'ğ‘·', 'e': 'ğ‘µ', 'r': 'ğ‘±', 't': 'ğ‘³',
                'y': 'ğ‘“', 'u': 'ğ‘', 'i': 'ğ‘¤', 'o': 'ğ‘¥', 'p': 'ğ‘’',
                '[': 'ğ‘¢', ']': 'ğ‘£', '\\': 'ğ‘ ',
                // Home row (a-;)
                'a': 'ğ‘ª', 's': 'ğ‘¨', 'd': 'ğ‘¦', 'f': 'ğ‘©', 'g': 'ğ‘§',
                'h': 'ğ‘', 'j': 'ğ‘¯', 'k': 'ğ‘‘', 'l': 'ğ‘®', ';': 'ğ‘•', '\'': 'ğ‘›',
                // Bottom row (z-/)
                'z': 'ğ‘¾', 'x': 'ğ‘²', 'c': 'ğ‘´', 'v': 'ğ‘°', 'b': 'ğ‘š',
                'n': 'ğ‘', 'm': 'ğ‘Ÿ', ',': ',', '.': '.', '/': '/',
                // Shift layer - only compound letters
                'Q': 'ğ‘¸', 'W': 'ğ‘¹', 'E': 'ğ‘¿', 'R': 'ğ‘º', 'T': 'ğ‘»',
                'F': 'ğ‘¼',
                // Space
                ' ': ' '
            },
            'igc': {
                // Number row (1-0 plus - =)
                '1': 'ğ‘¶', '2': 'ğ‘¬', '3': 'ğ‘»' + VS1, '4': 'ğ‘«', '5': 'ğ‘º' + VS1,
                '6': 'ğ‘œ', '7': 'ğ‘–', '8': 'ğ‘—', '9': 'ğ‘™', '0': 'ğ‘˜',
                '-': 'ğ‘¡', '=': 'ğ‘”', '`': '`',
                // QWERTY row (q-])
                'q': 'ğ‘­', 'w': 'ğ‘·', 'e': 'ğ‘µ', 'r': 'ğ‘±', 't': 'ğ‘³',
                'y': 'ğ‘“', 'u': 'ğ‘', 'i': 'ğ‘¤', 'o': 'ğ‘¥', 'p': 'ğ‘’',
                '[': 'ğ‘¢', ']': 'ğ‘£', '\\': 'ğ‘ ',
                // Home row (a-;)
                'a': 'ğ‘ª', 's': 'ğ‘¨', 'd': 'ğ‘¦', 'f': 'ğ‘©', 'g': 'ğ‘§',
                'h': 'ğ‘', 'j': 'ğ‘¯', 'k': 'ğ‘‘', 'l': 'ğ‘®', ';': 'ğ‘•', '\'': 'ğ‘›',
                // Bottom row (z-/)
                'z': 'ğ‘¾', 'x': 'ğ‘²', 'c': 'ğ‘´', 'v': 'ğ‘°', 'b': 'ğ‘š',
                'n': 'ğ‘', 'm': 'ğ‘Ÿ', ',': ',', '.': '.', '/': '/',
                // Space
                ' ': ' '
            },
            'qwerty': {
                // Shaw QWERTY layout - base layer (unshifted)
                // Number row
                '1': '1', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '0': '0',
                '`': '`', '-': '-', '=': '=',
                // QWERTY row (q-p)
                'q': 'ğ‘¶', 'w': 'ğ‘¢', 'e': 'ğ‘§', 'r': 'ğ‘®', 't': 'ğ‘‘',
                'y': 'ğ‘­', 'u': 'ğ‘³', 'i': 'ğ‘¦', 'o': 'ğ‘ª', 'p': 'ğ‘',
                '[': '[', ']': ']', '\\': '\\',
                // Home row (a-l)
                'a': 'ğ‘©', 's': 'ğ‘•', 'd': 'ğ‘›', 'f': 'ğ‘“', 'g': 'ğ‘œ',
                'h': 'ğ‘£', 'j': 'ğ‘˜', 'k': 'ğ‘’', 'l': 'ğ‘¤',
                ';': ';', '\'': '\'',
                // Bottom row (z-m)
                'z': 'ğ‘Ÿ', 'x': 'ğ‘»', 'c': 'ğ‘—', 'v': 'ğ‘', 'b': 'ğ‘š',
                'n': 'ğ‘¯', 'm': 'ğ‘¥',
                ',': ',', '.': '.', '/': '/',
                // Shift layer
                'Q': 'ğ‘¬', 'W': 'ğ‘¾', 'E': 'ğ‘±', 'R': 'ğ‘¸', 'T': 'ğ‘”',
                'Y': 'ğ‘·', 'U': 'ğ‘«', 'I': 'ğ‘°', 'O': 'ğ‘´', 'P': 'ğ‘¹',
                'A': 'ğ‘¨', 'S': 'ğ‘–', 'D': 'ğ‘¼', 'F': 'ğ‘²', 'G': 'Â·',
                'H': 'ğ‘', 'J': 'ğ‘¡',
                'Z': 'ğ‘ ', 'X': 'ğ‘º', 'C': 'ğ‘½', 'V': 'ğ‘¿', 'B': 'â¸°',
                'N': 'ğ‘™', 'M': 'ğ‘µ',
                // Space
                ' ': ' '
            },
            '2layer': {
                // Shaw 2-layer layout - base layer (unshifted)
                // QWERTY row (q to i only - no o, p)
                'q': 'ğ‘µ', 'w': 'ğ‘§', 'e': 'ğ‘¨', 'r': 'ğ‘­', 't': 'ğ‘¬',
                'y': 'ğ‘', 'u': 'ğ‘¢', 'i': 'ğ‘', 'o': 'o', 'p': 'p',
                '[': '[', ']': ']', '\\': '\\',
                // Home row (a to semicolon)
                'a': 'ğ‘¤', 's': 'ğ‘¦', 'd': 'ğ‘©', 'f': 'ğ‘¯', 'g': 'ğ‘·',
                'h': 'ğ‘–', 'j': 'ğ‘‘', 'k': 'ğ‘•', 'l': 'ğ‘’', ';': 'ğ‘',
                '\'': '\'',
                // Bottom row (z to c only - no v, b, n, m)
                'z': 'ğ‘ª', 'x': 'ğ‘³', 'c': 'ğ‘¼', 'v': 'ğ‘´', 'b': 'b',
                'n': 'n', 'm': 'ğ‘—',
                ',': ',', '.': '.', '/': '/',
                // Shift layer
                'Q': 'ğ‘¿', 'W': 'ğ‘±', 'E': 'ğ‘²', 'R': 'ğ‘¸', 'T': 'ğ‘¶',
                'U': 'ğ‘“', 'I': 'ğ‘˜', 'O': 'ğ‘”', 'P': 'ğ‘™',
                'A': 'ğ‘®', 'S': 'ğ‘°', 'D': 'ğ‘¾', 'F': 'ğ‘¥', 'G': 'ğ‘¹',
                'H': 'ğ‘ ', 'J': 'ğ‘›', 'K': 'ğ‘Ÿ', 'L': 'ğ‘œ', ':': 'ğ‘š',
                'Z': 'ğ‘º', 'X': 'ğ‘»', 'C': 'ğ‘½', 'V': 'ğ‘«',
                'M': 'ğ‘¡',
                // Numbers and punctuation
                '1': '1', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '0': '0',
                '`': '`', '-': '-', '=': '=',
                // Space
                ' ': ' '
            },
            'jafl': {
                // Shaw-JAFL layout - base layer (unshifted)
                // QWERTY row (q to i only)
                'q': 'ğ‘±', 'w': 'ğ‘§', 'e': 'ğ‘°', 'r': 'ğ‘¥', 't': 'ğ‘’',
                'y': 'ğ‘', 'u': 'ğ‘‘', 'i': 'ğ‘›', 'o': 'o', 'p': 'ğ‘“',
                '[': '[', ']': ']', '\\': '\\',
                // Home row
                'a': 'ğ‘ª', 's': 'ğ‘¨', 'd': 'ğ‘©', 'f': 'ğ‘¦', 'g': 'ğ‘³',
                'h': 'ğ‘¤', 'j': 'ğ‘®', 'k': 'ğ‘•', 'l': 'ğ‘¯', ';': 'ğ‘¢',
                '\'': '\'',
                // Bottom row (z to c only)
                'z': 'ğ‘²', 'x': 'ğ‘´', 'c': 'ğ‘', 'v': 'ğ‘Ÿ', 'b': 'ğ‘£',
                'n': 'ğ‘', 'm': 'ğ‘š',
                ',': ',', '.': '.', '/': '/',
                // Shift layer
                'Q': 'ğ‘¬', 'W': 'ğ‘¹', 'E': 'ğ‘¸', 'R': 'ğ‘¿', 'T': 'ğ‘œ',
                'U': 'ğ‘—', 'I': 'ğ‘¡',
                'A': 'ğ‘·', 'S': 'ğ‘­', 'D': 'ğ‘©', 'F': 'ğ‘µ', 'G': 'ğ‘«',
                'J': 'ğ‘®', 'K': 'ğ‘–', 'L': 'ğ‘™', ':': 'ğ‘˜',
                'Z': 'ğ‘¶', 'C': 'ğ‘”', 'V': 'ğ‘ ',
                // Numbers and punctuation
                '1': '1', '2': '2', '3': '3', '4': '4', '5': '5',
                '6': '6', '7': '7', '8': '8', '9': '9', '0': '0',
                '`': '`', '-': '-', '=': '=',
                // Space
                ' ': ' '
            }
        };

        // Virtual keyboard control functions
        function getLayoutName(layout) {
            const layoutNames = {
                'imperial': 'Shaw Imperial',
                'igc': 'Imperial Good Companion',
                'qwerty': 'Shaw QWERTY',
                '2layer': 'Shaw 2-layer',
                'jafl': 'Shaw-JAFL'
            };
            return layoutNames[layout] || 'Virtual Keyboard';
        }

        function updateVirtualKeyboardLabels(retryCount = 0) {
            if (typeof updateKeyboardLabels === 'function' && typeof makeKeysClickable === 'function') {
                const keyboardMap = KEYBOARD_MAPS[currentLayout];
                if (!keyboardMap) {
                    debug('No keyboard map available for layout:', currentLayout);
                    return; // Can't update labels if no map exists
                }
                const layoutName = getLayoutName(currentLayout);
                updateKeyboardLabels(keyboardMap, layoutName);
                makeKeysClickable(keyboardMap);
            } else if (retryCount < 20) {
                // Functions not loaded yet, try again soon
                setTimeout(() => updateVirtualKeyboardLabels(retryCount + 1), 50);
            } else {
                console.error('Virtual keyboard functions not available after retries');
            }
        }

        function toggleVirtualKeyboard() {
            const keyboard = document.getElementById('virtualKeyboard');
            const toggle = document.getElementById('virtualKeyboardToggle');

            if (keyboard.style.display === 'none') {
                // Show keyboard
                const typingInput = document.getElementById('typingInput');
                if (!typingInput || typingInput.style.display === 'none') {
                    // No active game, don't show keyboard
                    if (toggle) toggle.checked = false;
                    localStorage.setItem('showVirtualKeyboard', 'false');
                    return;
                }

                showVirtualKeyboard();
                updateVirtualKeyboardLabels();
                if (toggle) toggle.checked = true;
                localStorage.setItem('showVirtualKeyboard', 'true');
            } else {
                // Hide keyboard and reset position/scale
                hideVirtualKeyboard();
                if (typeof resetKeyboardState === 'function') {
                    resetKeyboardState();
                }
                if (toggle) toggle.checked = false;
                localStorage.setItem('showVirtualKeyboard', 'false');
            }
        }

        // Form ligatures in a word by replacing component pairs with ligatures
        function formLigaturesInWord(word) {
            let result = word;
            let changed = true;

            while (changed) {
                changed = false;
                const chars = Array.from(result);

                for (let i = 0; i < chars.length - 1; i++) {
                    const pair = chars[i] + chars[i + 1];
                    if (COMPONENT_TO_LIGATURE[pair]) {
                        result = chars.slice(0, i).join('') +
                                COMPONENT_TO_LIGATURE[pair] +
                                chars.slice(i + 2).join('');
                        changed = true;
                        break;
                    }
                }
            }

            return result;
        }


        // Mode management
        let currentMode = 'play'; // 'learn' or 'play'
        let currentLayout = 'imperial'; // 'imperial' or 'qwerty'
        let useLigatures = true; // Toggle for ligatures - ON by default
        let selectedLevel = 1; // Level selection: 1-7
        let levelCount = 6; // Number of levels in play mode (configurable: 3, 6, or 10)
        let useShavianUI = false; // Toggle for Shavian UI
        let currentDialect = 'gb'; // 'gb' or 'us' - English dialect for word lists
        let debugMode = false; // Toggle for debug logging
        let useVirtualKeyboard = true; // QWERTY virtual keyboard always enabled

        // Debug logging function - only logs when debugMode is true
        function debug(...args) {
            if (debugMode) {
                console.log(...args);
            }
        }

        // Helper function to toggle debug mode (can be called from console immediately)
        // Usage: setDebug(true) or setDebug(false) or window.debugMode = true
        window.setDebug = function(enabled) {
            debugMode = !!enabled;
            window.debugMode = debugMode; // Also expose on window for direct access
            localStorage.setItem('debugMode', debugMode);
            console.log('Debug mode ' + (debugMode ? 'enabled' : 'disabled') + ' and saved to localStorage');
            return debugMode;
        };

        // Expose debugMode on window and make it a getter/setter
        Object.defineProperty(window, 'debugMode', {
            get: function() { return debugMode; },
            set: function(value) {
                debugMode = !!value;
                localStorage.setItem('debugMode', debugMode);
                console.log('Debug mode ' + (debugMode ? 'enabled' : 'disabled'));
            }
        });

        // Get current translations based on settings
        // Note: translations are loaded synchronously in <head>
        function getCurrentTranslations() {
            if (!useShavianUI) {
                return window.translations.latin || {};
            }

            // Use dialect-specific Shavian translations
            const dialectKey = currentDialect === 'gb' ? 'shavian_british' : 'shavian_american';
            return window.translations[dialectKey] || {};
        }

        // Temporary: Keep old hardcoded translations as fallback until we finish migration
        const translationsOLD = {
            latin: {
                title: 'Shaw Type',
                subtitle: 'ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯ ğ‘‘ğ‘²ğ‘ğ‘¦ğ‘™ ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•',
                practice: 'Practice',
                play: 'Play',
                settings: 'Settings',
                keyboardLayout: 'Keyboard Layout',
                ligatures: 'Automatic ligatures (ğ‘©+ğ‘®â†’ğ‘¼, ğ‘˜+ğ‘µâ†’ğ‘¿)',
                lesson: 'Lesson:',
                wordLength: 'Word Length:',
                characters: 'characters',
                // Word length options
                length1: '1 character',
                length2: '2 characters',
                length3: '3 characters',
                length4: '4 characters',
                length5: '5 characters',
                length6: '6 characters',
                length7: '7 characters',
                length46: '4-6 characters',
                length57: '5-7 characters',
                lesson_label: 'Lesson',
                level_label: 'Level',
                words: 'Words',
                accuracy: 'Accuracy',
                gameInstructions: 'Type the words shown - hit space between words.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'Home Row Center',
                lessonFullHomeRow: 'Full Home Row',
                lessonIndexFingerReach: 'Index Finger Reach',
                lessonUpperLowerRows: 'Upper & Lower Rows',
                lessonNumberRowFocus: 'Number Row Focus',
                lessonHardToReach: 'Hard to Reach',
                lessonAllKeys: 'All Keys',
                lessonCompoundLetters: 'Compound Letters',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'Home Row + Shift',
                lessonAddUpperRow: 'Add Upper Row',
                lessonAddLowerRow: 'Add Lower Row',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'Essential Phonemes',
                lessonVowelVoyage: 'Vowel Voyage',
                lessonConsonantCommand: 'Consonant Command',
                lessonLigaturePower: 'Ligature Power',
                lessonShiftMastery: 'Shift Mastery',
                lessonCompleteControl: 'Complete Control',
                // Lesson names - JAFL
                lessonCoreFoundation: 'Core Foundation',
                lessonHomeSweet: 'Home Sweet Home',
                lessonUpperExpedition: 'Upper Expedition',
                lessonLowerExploration: 'Lower Exploration',
                lessonShiftIntroduction: 'Shift Introduction',
                lessonMasterTypist: 'Master Typist',
                congratulations: 'Congratulations!',
                lessonComplete: 'Lesson Complete!',
                sessionComplete: 'Session Complete!',
                completed30: 'You completed 30 words!',
                completed10: 'You completed 10 words!',
                completedWords: 'You completed {n} words!',
                wpm: 'WPM:',
                lettersPerMin: 'Letters/min:',
                accuracy_final: 'Accuracy:',
                levelReached: 'Level Reached:',
                practiceAgain: 'Practice Again',
                scoresTitle: 'Scores',
                noScoresYet: 'No high scores yet. Complete a game in Play mode to set your first records!',
                levels: 'Levels',
                bestTime: 'Best Time:',
                bestWPM: 'Best WPM:',
                bestAccuracy: 'Best Accuracy:',
                settingsTitle: 'Settings',
                displayShavian: 'Display UI in Shavian',
                displayShavianDesc: 'Show labels and text in Shavian alphabet instead of Latin',
                showVirtualKeyboard: 'Show virtual keyboard',
                showVirtualKeyboardDesc: 'Display a draggable on-screen keyboard showing Shavian characters',
                // Splash screen
                splashTitle: 'Welcome to Shaw Type!',
                whatsNew: 'What\'s New',
                dontShowAgain: 'Don\'t show this again',
                continueButton: 'Continue',
                // Setup dialog
                setupTitle: 'Get Started',
                setupSubtitle: 'Choose your keyboard layout and spelling preference:',
                setupNote: 'Don\'t worry too much. This choice, and more besides, can be changed later in settings.',
                startPracticing: 'Start Practicing!',
                close: 'Close',
                lessonModalTitle: 'Choose a Lesson',
                lessonModalSubtitle: 'Select a lesson to practice:',
                lessonModalCancel: 'Cancel',
                lessonPrefix: 'Lesson',
                // Lesson descriptions
                desc1: 'Middle fingers only, home row',
                desc2: 'All fingers, home row',
                desc3: 'Add index finger upper/lower reaches',
                desc4: 'Extend to more keys above and below',
                desc5: 'Add outer columns',
                desc6: 'Complete keyboard (all layers)',
                desc7: 'Practice typing ligatures: ğ‘¼ ğ‘¸ ğ‘¹ ğ‘¿ ğ‘½',
                desc8: 'Home row with shift layer',
                desc9: 'Add upper row (both layers)',
                desc10: 'Add lower row (both layers)',
                desc11: 'Master the 9 most common sounds in English',
                desc12: 'Navigate through English vowel sounds',
                desc13: 'Build confidence with base layer consonants',
                desc14: 'Harness the efficiency of compound letters',
                desc15: 'Unlock the full potential of the shift layer',
                desc16: 'Command every key with confidence',
                desc17: 'Build your foundation with essential sounds',
                desc18: 'Master the comfort of the home row',
                desc19: 'Journey to the upper reaches of your keyboard',
                desc20: 'Explore the depths below home position',
                desc21: 'Discover new dimensions with the shift key',
                desc22: 'Achieve mastery over the complete keyboard',
                desc23: 'All fingers, home row (unshifted)',
                desc24: 'Complete keyboard including number row',
                // Burger menu items
                menuAbout: 'About',
                menuKeyboards: 'Keyboards',
                menuResources: 'Resources',
                menuSettings: 'Settings',
                // Content modal titles
                titleAbout: 'About',
                titleKeyboards: 'Keyboards',
                titleResources: 'Resources',
                // Settings dialog labels
                dialectLabel: 'Choose spelling',
                dialectBritish: 'British',
                dialectAmerican: 'American',
                hideWelcome: 'Hide welcome screen when page opens',
                levelCountLabel: 'Play Mode Level Count',
                levelCount3: '3 levels (15 words)',
                levelCount6: '6 levels (30 words)',
                levelCount10: '10 levels (50 words)',
                // Layout names
                layoutImperial: 'Shaw Imperial',
                layoutIGC: 'Imperial Good Companion',
                layoutQwerty: 'Shaw QWERTY',
                layout2layer: 'Shaw 2-layer (shift)',
                layoutJafl: 'Shaw-JAFL'
            },
            shavian: {
                title: 'Â·ğ‘–ğ‘· ğ‘‘ğ‘²ğ‘',
                subtitle: 'Â·ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯ ğ‘‘ğ‘²ğ‘ğ‘¦ğ‘™ ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•',
                practice: 'ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•',
                play: 'ğ‘ğ‘¤ğ‘±',
                settings: 'ğ‘•ğ‘§ğ‘‘ğ‘¦ğ‘™ğ‘Ÿ',
                keyboardLayout: 'ğ‘’ğ‘°ğ‘šğ‘¹ğ‘› ğ‘¤ğ‘±ğ‘¬ğ‘‘',
                ligatures: 'ğ‘·ğ‘‘ğ‘©ğ‘¥ğ‘¨ğ‘‘ğ‘¦ğ‘’ ğ‘¤ğ‘¦ğ‘œğ‘©ğ‘—ğ‘¼ğ‘Ÿ (ğ‘©+ğ‘®â†’ğ‘¼, ğ‘˜+ğ‘µâ†’ğ‘¿)',
                lesson: 'ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯:',
                wordLength: 'ğ‘¢ğ‘»ğ‘› ğ‘¤ğ‘§ğ‘™ğ‘”:',
                characters: 'ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                // Word length options
                length1: '1 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼',
                length2: '2 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length3: '3 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length4: '4 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length5: '5 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length6: '6 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length7: '7 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length46: '4-6 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                length57: '5-7 ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                lesson_label: 'ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯',
                level_label: 'ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤',
                words: 'ğ‘¢ğ‘»ğ‘›ğ‘Ÿ',
                accuracy: 'ğ‘¨ğ‘’ğ‘˜ğ‘¼ğ‘©ğ‘•ğ‘¦',
                gameInstructions: 'ğ‘‘ğ‘²ğ‘ ğ‘ ğ‘¢ğ‘»ğ‘›ğ‘Ÿ ğ‘–ğ‘´ğ‘¯ - ğ‘£ğ‘¦ğ‘‘ ğ‘•ğ‘ğ‘±ğ‘• ğ‘šğ‘¦ğ‘‘ğ‘¢ğ‘°ğ‘¯ ğ‘¢ğ‘»ğ‘›ğ‘Ÿ.',
                // Lesson names - Imperial
                lessonHomeRowCenter: 'ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´ ğ‘•ğ‘§ğ‘¯ğ‘‘ğ‘¼',
                lessonFullHomeRow: 'ğ‘“ğ‘«ğ‘¤ ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´',
                lessonIndexFingerReach: 'ğ‘¦ğ‘¯ğ‘›ğ‘§ğ‘’ğ‘• ğ‘“ğ‘¦ğ‘™ğ‘œğ‘¼ ğ‘®ğ‘°ğ‘—',
                lessonUpperLowerRows: 'ğ‘³ğ‘ğ‘¼ & ğ‘¤ğ‘´ğ‘¼ ğ‘®ğ‘´ğ‘Ÿ',
                lessonNumberRowFocus: 'ğ‘¯ğ‘³ğ‘¥ğ‘šğ‘¼ ğ‘®ğ‘´ ğ‘“ğ‘´ğ‘’ğ‘©ğ‘•',
                lessonHardToReach: 'ğ‘£ğ‘­ğ‘®ğ‘› ğ‘‘ ğ‘®ğ‘°ğ‘—',
                lessonAllKeys: 'ğ‘·ğ‘¤ ğ‘’ğ‘°ğ‘Ÿ',
                lessonCompoundLetters: 'ğ‘’ğ‘ªğ‘¥ğ‘ğ‘¬ğ‘¯ğ‘› ğ‘¤ğ‘§ğ‘‘ğ‘¼ğ‘Ÿ',
                // Lesson names - QWERTY
                lessonHomeRowShift: 'ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´ + ğ‘–ğ‘¦ğ‘“ğ‘‘',
                lessonAddUpperRow: 'ğ‘¨ğ‘› ğ‘³ğ‘ğ‘¼ ğ‘®ğ‘´',
                lessonAddLowerRow: 'ğ‘¨ğ‘› ğ‘¤ğ‘´ğ‘¼ ğ‘®ğ‘´',
                // Lesson names - 2-layer
                lessonEssentialPhonemes: 'ğ‘¦ğ‘•ğ‘§ğ‘¯ğ‘–ğ‘©ğ‘¤ ğ‘“ğ‘´ğ‘¯ğ‘°ğ‘¥ğ‘Ÿ',
                lessonVowelVoyage: 'ğ‘ğ‘¬ğ‘©ğ‘¤ ğ‘ğ‘¶ğ‘¦ğ‘¡',
                lessonConsonantCommand: 'ğ‘’ğ‘ªğ‘¯ğ‘•ğ‘©ğ‘¯ğ‘©ğ‘¯ğ‘‘ ğ‘’ğ‘©ğ‘¥ğ‘­ğ‘¯ğ‘›',
                lessonLigaturePower: 'ğ‘¤ğ‘¦ğ‘œğ‘©ğ‘—ğ‘¼ ğ‘ğ‘¬ğ‘¼',
                lessonShiftMastery: 'ğ‘–ğ‘¦ğ‘“ğ‘‘ ğ‘¥ğ‘­ğ‘•ğ‘‘ğ‘¼ğ‘¦',
                lessonCompleteControl: 'ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ ğ‘’ğ‘©ğ‘¯ğ‘‘ğ‘®ğ‘´ğ‘¤',
                // Lesson names - JAFL
                lessonCoreFoundation: 'ğ‘’ğ‘¹ ğ‘“ğ‘¬ğ‘¯ğ‘›ğ‘±ğ‘–ğ‘©ğ‘¯',
                lessonHomeSweet: 'ğ‘£ğ‘´ğ‘¥ ğ‘•ğ‘¢ğ‘°ğ‘‘ ğ‘£ğ‘´ğ‘¥',
                lessonUpperExpedition: 'ğ‘³ğ‘ğ‘¼ ğ‘§ğ‘’ğ‘•ğ‘ğ‘©ğ‘›ğ‘¦ğ‘–ğ‘©ğ‘¯',
                lessonLowerExploration: 'ğ‘¤ğ‘´ğ‘¼ ğ‘§ğ‘’ğ‘•ğ‘ğ‘¤ğ‘¼ğ‘±ğ‘–ğ‘©ğ‘¯',
                lessonShiftIntroduction: 'ğ‘–ğ‘¦ğ‘“ğ‘‘ ğ‘¦ğ‘¯ğ‘‘ğ‘®ğ‘©ğ‘›ğ‘³ğ‘’ğ‘–ğ‘©ğ‘¯',
                lessonMasterTypist: 'ğ‘¥ğ‘­ğ‘•ğ‘‘ğ‘¼ ğ‘‘ğ‘²ğ‘ğ‘¦ğ‘•ğ‘‘',
                congratulations: 'ğ‘’ğ‘©ğ‘¯ğ‘œğ‘®ğ‘¨ğ‘—ğ‘©ğ‘¤ğ‘±ğ‘–ğ‘©ğ‘¯ğ‘Ÿ!',
                lessonComplete: 'ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘!',
                sessionComplete: 'ğ‘•ğ‘§ğ‘–ğ‘©ğ‘¯ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘!',
                completed30: 'ğ‘¿ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ğ‘©ğ‘› 30 ğ‘¢ğ‘»ğ‘›ğ‘Ÿ!',
                completed10: 'ğ‘¿ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ğ‘©ğ‘› 10 ğ‘¢ğ‘»ğ‘›ğ‘Ÿ!',
                completedWords: 'ğ‘¿ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ğ‘©ğ‘› {n} ğ‘¢ğ‘»ğ‘›ğ‘Ÿ!',
                wpm: 'WPM:',
                lettersPerMin: 'ğ‘¤ğ‘§ğ‘‘ğ‘¼ğ‘Ÿ/ğ‘¥ğ‘°ğ‘¯:',
                accuracy_final: 'ğ‘¨ğ‘’ğ‘˜ğ‘¼ğ‘©ğ‘•ğ‘¦:',
                levelReached: 'ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ ğ‘®ğ‘°ğ‘—ğ‘‘:',
                practiceAgain: 'ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘• ğ‘©ğ‘œğ‘§ğ‘¯',
                scoresTitle: 'ğ‘•ğ‘’ğ‘¹ğ‘Ÿ',
                noScoresYet: 'ğ‘¯ğ‘´ ğ‘£ğ‘² ğ‘•ğ‘’ğ‘¹ğ‘Ÿ ğ‘˜ğ‘§ğ‘‘. ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ ğ‘© ğ‘œğ‘±ğ‘¥ ğ‘¦ğ‘¯ ğ‘ğ‘¤ğ‘± ğ‘¥ğ‘´ğ‘› ğ‘‘ ğ‘•ğ‘§ğ‘‘ ğ‘˜ğ‘¹ ğ‘“ğ‘»ğ‘•ğ‘‘ ğ‘®ğ‘§ğ‘’ğ‘¼ğ‘›ğ‘Ÿ!',
                levels: 'ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ğ‘Ÿ',
                bestTime: 'ğ‘šğ‘§ğ‘•ğ‘‘ ğ‘‘ğ‘²ğ‘¥:',
                bestWPM: 'ğ‘šğ‘§ğ‘•ğ‘‘ WPM:',
                bestAccuracy: 'ğ‘šğ‘§ğ‘•ğ‘‘ ğ‘¨ğ‘’ğ‘˜ğ‘¼ğ‘©ğ‘•ğ‘¦:',
                settingsTitle: 'ğ‘•ğ‘§ğ‘‘ğ‘¦ğ‘™ğ‘Ÿ',
                displayShavian: 'ğ‘›ğ‘¦ğ‘•ğ‘ğ‘¤ğ‘± UI ğ‘¦ğ‘¯ Â·ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯',
                displayShavianDesc: 'ğ‘–ğ‘´ ğ‘¤ğ‘±ğ‘šğ‘©ğ‘¤ğ‘Ÿ ğ‘¯ ğ‘‘ğ‘§ğ‘’ğ‘•ğ‘‘ ğ‘¦ğ‘¯ Â·ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯ ğ‘¨ğ‘¤ğ‘“ğ‘©ğ‘šğ‘§ğ‘‘ ğ‘¦ğ‘¯ğ‘•ğ‘‘ğ‘§ğ‘› ğ‘ Â·ğ‘¤ğ‘¨ğ‘‘ğ‘¦ğ‘¯',
                showVirtualKeyboard: 'ğ‘–ğ‘´ ğ‘ğ‘»ğ‘—ğ‘µğ‘©ğ‘¤ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘›',
                showVirtualKeyboardDesc: 'ğ‘›ğ‘¦ğ‘•ğ‘ğ‘¤ğ‘± ğ‘© ğ‘›ğ‘®ğ‘¨ğ‘œğ‘©ğ‘šğ‘©ğ‘¤ ğ‘ªğ‘¯-ğ‘•ğ‘’ğ‘®ğ‘°ğ‘¯ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘› ğ‘–ğ‘´ğ‘¦ğ‘™ Â·ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯ ğ‘’ğ‘¨ğ‘®ğ‘©ğ‘’ğ‘‘ğ‘¼ğ‘Ÿ',
                // Splash screen
                splashTitle: 'ğ‘¢ğ‘§ğ‘¤ğ‘’ğ‘³ğ‘¥ ğ‘‘ Â·ğ‘–ğ‘· ğ‘‘ğ‘²ğ‘!',
                whatsNew: 'ğ‘¢ğ‘ªğ‘‘ğ‘• ğ‘¯ğ‘¿',
                dontShowAgain: 'ğ‘›ğ‘´ğ‘¯ğ‘‘ ğ‘–ğ‘´ ğ‘ğ‘¦ğ‘• ğ‘©ğ‘œğ‘§ğ‘¯',
                continueButton: 'ğ‘’ğ‘©ğ‘¯ğ‘‘ğ‘¦ğ‘¯ğ‘¿',
                // Setup dialog
                setupTitle: 'ğ‘œğ‘§ğ‘‘ ğ‘•ğ‘‘ğ‘¸ğ‘‘ğ‘©ğ‘›',
                setupSubtitle: 'ğ‘—ğ‘µğ‘Ÿ ğ‘˜ğ‘¹ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘› ğ‘¤ğ‘±ğ‘¬ğ‘‘ ğ‘¯ ğ‘•ğ‘ğ‘§ğ‘¤ğ‘¦ğ‘™ ğ‘ğ‘®ğ‘§ğ‘“ğ‘¼ğ‘©ğ‘¯ğ‘•:',
                setupNote: 'ğ‘›ğ‘´ğ‘¯ğ‘‘ ğ‘¢ğ‘³ğ‘®ğ‘¦ ğ‘‘ğ‘µ ğ‘¥ğ‘³ğ‘—. ğ‘ğ‘¦ğ‘• ğ‘—ğ‘¶ğ‘•, ğ‘¯ ğ‘¥ğ‘¹ ğ‘šğ‘¦ğ‘•ğ‘²ğ‘›ğ‘Ÿ, ğ‘’ğ‘¨ğ‘¯ ğ‘šğ‘° ğ‘—ğ‘±ğ‘¯ğ‘¡ğ‘› ğ‘¤ğ‘±ğ‘‘ğ‘¼ ğ‘¦ğ‘¯ ğ‘•ğ‘§ğ‘‘ğ‘¦ğ‘™ğ‘Ÿ.',
                startPracticing: 'ğ‘•ğ‘‘ğ‘¸ğ‘‘ ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•ğ‘¦ğ‘™!',
                close: 'ğ‘’ğ‘¤ğ‘´ğ‘Ÿ',
                lessonModalTitle: 'ğ‘—ğ‘µğ‘Ÿ ğ‘© ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯',
                lessonModalSubtitle: 'ğ‘•ğ‘¦ğ‘¤ğ‘§ğ‘’ğ‘‘ ğ‘© ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯ ğ‘‘ ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘•:',
                lessonModalCancel: 'ğ‘’ğ‘¨ğ‘¯ğ‘•ğ‘©ğ‘¤',
                lessonPrefix: 'ğ‘¤ğ‘§ğ‘•ğ‘©ğ‘¯',
                // Lesson descriptions
                desc1: 'ğ‘¥ğ‘¦ğ‘›ğ‘©ğ‘¤ ğ‘“ğ‘¦ğ‘™ğ‘œğ‘¼ğ‘Ÿ ğ‘´ğ‘¯ğ‘¤ğ‘¦, ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´',
                desc2: 'ğ‘·ğ‘¤ ğ‘“ğ‘¦ğ‘™ğ‘œğ‘¼ğ‘Ÿ, ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´',
                desc3: 'ğ‘¨ğ‘› ğ‘¦ğ‘¯ğ‘›ğ‘§ğ‘’ğ‘• ğ‘“ğ‘¦ğ‘™ğ‘œğ‘¼ ğ‘³ğ‘ğ‘¼/ğ‘¤ğ‘´ğ‘¼ ğ‘®ğ‘°ğ‘—ğ‘©ğ‘Ÿ',
                desc4: 'ğ‘¦ğ‘’ğ‘•ğ‘‘ğ‘§ğ‘¯ğ‘› ğ‘‘ ğ‘¥ğ‘¹ ğ‘’ğ‘°ğ‘Ÿ ğ‘©ğ‘šğ‘³ğ‘ ğ‘¯ ğ‘šğ‘¦ğ‘¤ğ‘´',
                desc5: 'ğ‘¨ğ‘› ğ‘¬ğ‘‘ğ‘¼ ğ‘’ğ‘ªğ‘¤ğ‘©ğ‘¥ğ‘Ÿ',
                desc6: 'ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘› (ğ‘·ğ‘¤ ğ‘¤ğ‘±ğ‘¼ğ‘Ÿ)',
                desc7: 'ğ‘ğ‘®ğ‘¨ğ‘’ğ‘‘ğ‘¦ğ‘• ğ‘‘ğ‘²ğ‘ğ‘¦ğ‘™ ğ‘¤ğ‘¦ğ‘œğ‘©ğ‘—ğ‘¼ğ‘Ÿ: ğ‘¼ ğ‘¸ ğ‘¹ ğ‘¿ ğ‘½',
                desc8: 'ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´ ğ‘¢ğ‘¦ğ‘ ğ‘–ğ‘¦ğ‘“ğ‘‘ ğ‘¤ğ‘±ğ‘¼',
                desc9: 'ğ‘¨ğ‘› ğ‘³ğ‘ğ‘¼ ğ‘®ğ‘´ (ğ‘šğ‘´ğ‘” ğ‘¤ğ‘±ğ‘¼ğ‘Ÿ)',
                desc10: 'ğ‘¨ğ‘› ğ‘¤ğ‘´ğ‘¼ ğ‘®ğ‘´ (ğ‘šğ‘´ğ‘” ğ‘¤ğ‘±ğ‘¼ğ‘Ÿ)',
                desc11: 'ğ‘¥ğ‘­ğ‘•ğ‘‘ğ‘¼ ğ‘ 9 ğ‘¥ğ‘´ğ‘•ğ‘‘ ğ‘’ğ‘ªğ‘¥ğ‘©ğ‘¯ ğ‘•ğ‘¬ğ‘¯ğ‘›ğ‘Ÿ ğ‘¦ğ‘¯ Â·ğ‘¦ğ‘™ğ‘œğ‘¤ğ‘¦ğ‘–',
                desc12: 'ğ‘¯ğ‘¨ğ‘ğ‘¦ğ‘œğ‘±ğ‘‘ ğ‘”ğ‘®ğ‘µ Â·ğ‘¦ğ‘™ğ‘œğ‘¤ğ‘¦ğ‘– ğ‘ğ‘¬ğ‘©ğ‘¤ ğ‘•ğ‘¬ğ‘¯ğ‘›ğ‘Ÿ',
                desc13: 'ğ‘šğ‘¦ğ‘¤ğ‘› ğ‘’ğ‘ªğ‘¯ğ‘“ğ‘¦ğ‘›ğ‘©ğ‘¯ğ‘• ğ‘¢ğ‘¦ğ‘ ğ‘šğ‘±ğ‘• ğ‘¤ğ‘±ğ‘¼ ğ‘’ğ‘ªğ‘¯ğ‘•ğ‘©ğ‘¯ğ‘©ğ‘¯ğ‘‘ğ‘•',
                desc14: 'ğ‘£ğ‘¸ğ‘¯ğ‘©ğ‘• ğ‘ ğ‘¦ğ‘“ğ‘¦ğ‘–ğ‘©ğ‘¯ğ‘•ğ‘¦ ğ‘ ğ‘’ğ‘ªğ‘¥ğ‘ğ‘¬ğ‘¯ğ‘› ğ‘¤ğ‘§ğ‘‘ğ‘¼ğ‘Ÿ',
                desc15: 'ğ‘³ğ‘¯ğ‘¤ğ‘ªğ‘’ ğ‘ ğ‘“ğ‘«ğ‘¤ ğ‘ğ‘©ğ‘‘ğ‘§ğ‘¯ğ‘–ğ‘©ğ‘¤ ğ‘ ğ‘ ğ‘–ğ‘¦ğ‘“ğ‘‘ ğ‘¤ğ‘±ğ‘¼',
                desc16: 'ğ‘’ğ‘©ğ‘¥ğ‘­ğ‘¯ğ‘› ğ‘§ğ‘ğ‘®ğ‘¦ ğ‘’ğ‘° ğ‘¢ğ‘¦ğ‘ ğ‘’ğ‘ªğ‘¯ğ‘“ğ‘¦ğ‘›ğ‘©ğ‘¯ğ‘•',
                desc17: 'ğ‘šğ‘¦ğ‘¤ğ‘› ğ‘˜ğ‘¹ ğ‘“ğ‘¬ğ‘¯ğ‘›ğ‘±ğ‘–ğ‘©ğ‘¯ ğ‘¢ğ‘¦ğ‘ ğ‘¦ğ‘•ğ‘§ğ‘¯ğ‘–ğ‘©ğ‘¤ ğ‘•ğ‘¬ğ‘¯ğ‘›ğ‘Ÿ',
                desc18: 'ğ‘¥ğ‘­ğ‘•ğ‘‘ğ‘¼ ğ‘ ğ‘’ğ‘³ğ‘¥ğ‘“ğ‘¼ğ‘‘ ğ‘ ğ‘ ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´',
                desc19: 'ğ‘¡ğ‘»ğ‘¯ğ‘¦ ğ‘‘ ğ‘ ğ‘³ğ‘ğ‘¼ ğ‘®ğ‘°ğ‘—ğ‘©ğ‘Ÿ ğ‘ ğ‘˜ğ‘¹ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘›',
                desc20: 'ğ‘¦ğ‘’ğ‘•ğ‘ğ‘¤ğ‘¹ ğ‘ ğ‘›ğ‘§ğ‘ğ‘”ğ‘• ğ‘šğ‘¦ğ‘¤ğ‘´ ğ‘£ğ‘´ğ‘¥ ğ‘ğ‘©ğ‘Ÿğ‘¦ğ‘–ğ‘©ğ‘¯',
                desc21: 'ğ‘›ğ‘¦ğ‘•ğ‘’ğ‘³ğ‘ğ‘¼ ğ‘¯ğ‘¿ ğ‘›ğ‘¦ğ‘¥ğ‘§ğ‘¯ğ‘–ğ‘©ğ‘¯ğ‘Ÿ ğ‘¢ğ‘¦ğ‘ ğ‘ ğ‘–ğ‘¦ğ‘“ğ‘‘ ğ‘’ğ‘°',
                desc22: 'ğ‘©ğ‘—ğ‘°ğ‘ ğ‘¥ğ‘­ğ‘•ğ‘‘ğ‘¼ğ‘¦ ğ‘´ğ‘ğ‘¼ ğ‘ ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘›',
                desc23: 'ğ‘·ğ‘¤ ğ‘“ğ‘¦ğ‘™ğ‘œğ‘¼ğ‘Ÿ, ğ‘£ğ‘´ğ‘¥ ğ‘®ğ‘´ (ğ‘³ğ‘¯ğ‘–ğ‘¦ğ‘“ğ‘‘ğ‘©ğ‘›)',
                desc24: 'ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¤ğ‘°ğ‘‘ ğ‘’ğ‘°ğ‘šğ‘¹ğ‘› ğ‘¦ğ‘¯ğ‘’ğ‘¤ğ‘µğ‘›ğ‘¦ğ‘™ ğ‘¯ğ‘³ğ‘¥ğ‘šğ‘¼ ğ‘®ğ‘´',
                // Burger menu items
                menuAbout: 'ğ‘©ğ‘šğ‘¬ğ‘‘',
                menuKeyboards: 'ğ‘’ğ‘°ğ‘šğ‘¹ğ‘›ğ‘Ÿ',
                menuResources: 'ğ‘®ğ‘¦ğ‘Ÿğ‘¹ğ‘•ğ‘©ğ‘Ÿ',
                menuSettings: 'ğ‘•ğ‘§ğ‘‘ğ‘¦ğ‘™ğ‘Ÿ',
                // Content modal titles
                titleAbout: 'ğ‘©ğ‘šğ‘¬ğ‘‘',
                titleKeyboards: 'ğ‘’ğ‘°ğ‘šğ‘¹ğ‘›ğ‘Ÿ',
                titleResources: 'ğ‘®ğ‘¦ğ‘Ÿğ‘¹ğ‘•ğ‘©ğ‘Ÿ',
                // Settings dialog labels
                dialectLabel: 'ğ‘—ğ‘µğ‘Ÿ ğ‘•ğ‘ğ‘§ğ‘¤ğ‘¦ğ‘™',
                dialectBritish: 'Â·ğ‘šğ‘®ğ‘¦ğ‘‘ğ‘¦ğ‘–',
                dialectAmerican: 'Â·ğ‘©ğ‘¥ğ‘§ğ‘®ğ‘¦ğ‘’ğ‘©ğ‘¯',
                hideWelcome: 'ğ‘£ğ‘²ğ‘› ğ‘¢ğ‘§ğ‘¤ğ‘’ğ‘³ğ‘¥ ğ‘•ğ‘’ğ‘®ğ‘°ğ‘¯ ğ‘¢ğ‘§ğ‘¯ ğ‘ğ‘±ğ‘¡ ğ‘´ğ‘ğ‘©ğ‘¯ğ‘Ÿ',
                levelCountLabel: 'ğ‘ğ‘¤ğ‘± ğ‘¥ğ‘´ğ‘› ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ ğ‘’ğ‘¬ğ‘¯ğ‘‘',
                levelCount3: '3 ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ğ‘Ÿ (15 ğ‘¢ğ‘»ğ‘›ğ‘Ÿ)',
                levelCount6: '6 ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ğ‘Ÿ (30 ğ‘¢ğ‘»ğ‘›ğ‘Ÿ)',
                levelCount10: '10 ğ‘¤ğ‘§ğ‘ğ‘©ğ‘¤ğ‘Ÿ (50 ğ‘¢ğ‘»ğ‘›ğ‘Ÿ)',
                // Layout names
                layoutImperial: 'Â·ğ‘–ğ‘· ğ‘¦ğ‘¥ğ‘ğ‘½ğ‘¾ğ‘¤',
                layoutIGC: 'Â·ğ‘¦ğ‘¥ğ‘ğ‘½ğ‘¾ğ‘¤ ğ‘œğ‘«ğ‘› ğ‘’ğ‘©ğ‘¥ğ‘ğ‘¨ğ‘¯ğ‘˜ğ‘©ğ‘¯',
                layoutQwerty: 'Â·ğ‘–ğ‘· QWERTY',
                layout2layer: 'Â·ğ‘–ğ‘· 2-ğ‘¤ğ‘±ğ‘¼ (ğ‘–ğ‘¦ğ‘“ğ‘‘)',
                layoutJafl: 'Â·ğ‘–ğ‘·-JAFL'
            }
        };

        const wordSlots = [
            document.getElementById('wordSlot0'),
            document.getElementById('wordSlot1'),
            document.getElementById('wordSlot2'),
            document.getElementById('wordSlot3')
        ];
        const typingInput = document.getElementById('typingInput');
        const wordCountEl = document.getElementById('wordCount');
        const accuracyEl = document.getElementById('accuracy');
        const levelDisplayEl = document.getElementById('levelDisplay');

        // Get current level based on words completed (5 words per level)
        function getCurrentLevel() {
            if (currentMode === 'learn' && currentLayout === 'imperial' && useLigatures) {
                // Imperial with ligatures has 7 levels (compound letters at level 5)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5; // Compound letters lesson
                if (wordsCompleted < 30) return 6; // Almost Complete
                return 7; // All Keys
            } else {
                // Other modes use 6 levels (5 words per level = 30 words total)
                if (wordsCompleted < 5) return 1;
                if (wordsCompleted < 10) return 2;
                if (wordsCompleted < 15) return 3;
                if (wordsCompleted < 20) return 4;
                if (wordsCompleted < 25) return 5;
                return 6;
            }
        }

        // UI Navigation
        function goHome() {
            // Cancel any running countdown
            cancelCountdown();

            // Hide game content and countdown, show home screen
            document.getElementById('gameContent').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('backBtn').classList.add('hidden');

            // Reset subtitle to default
            const t = getCurrentTranslations();
            document.getElementById('mainSubtitle').textContent = t.subtitle;

            // Clear any modals
            closeLessonModal();
            document.getElementById('completionModal').classList.remove('show');
        }

        function showGameContent() {
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('countdownScreen').classList.add('hidden');
            document.getElementById('gameContent').classList.remove('hidden');
            document.getElementById('backBtn').classList.remove('hidden');
        }

        function startPlay() {
            currentMode = 'play';
            localStorage.setItem('currentMode', currentMode);

            // Hide home screen, show back button
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('backBtn').classList.remove('hidden');

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];
            pauseStartTime = null;
            totalPausedTime = 0;

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Update UI language
            updateUILanguage();

            // Show countdown, then start game
            const t = getCurrentTranslations();
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function playAgain() {
            // Hide completion modal
            document.getElementById('completionModal').style.display = 'none';

            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];
            pauseStartTime = null;
            totalPausedTime = 0;

            // Update display
            updateStats();
            updateLevel();
            updateSubtitleForGame();

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display = 'none';

            // Show countdown, then start game
            const t = getCurrentTranslations();
            const levelData = getPlayLevelData(1);
            showCountdown(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
        }

        function startPractice() {
            currentMode = 'learn';
            localStorage.setItem('currentMode', currentMode);

            // Open lesson selector first
            openLessonSelector();
        }

        function updateSubtitleForGame() {
            const t = getCurrentTranslations();
            const subtitle = document.getElementById('mainSubtitle');

            if (currentMode === 'play') {
                subtitle.textContent = `${t.level_label} ${currentLevelNumber}`;
            } else if (currentMode === 'learn') {
                // Lesson name will be set when lesson is selected
                subtitle.textContent = '';
            }
        }

        // Mode switching (legacy - now mainly used internally)
        function setMode(mode) {
            currentMode = mode;
            localStorage.setItem('currentMode', currentMode);

            // Show/hide lesson info
            document.getElementById('currentLessonInfo').style.display =
                mode === 'learn' ? 'block' : 'none';

            // Update subtitle
            updateSubtitleForGame();

            // Open lesson selector when switching to practice mode
            if (mode === 'learn') {
                openLessonSelector();
            }

            // Update stat label based on mode
            updateUILanguage();

            // Reset and reload
            resetPractice();
        }

        function onDialectChangeSettings() {
            const selected = document.querySelector('input[name="dialectSettings"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Update UI translations for new dialect
                updateUILanguage();
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    // Only reinitialize if not in an active game
                    const isGameActive = !document.getElementById('gameContent').classList.contains('hidden');
                    if (!isGameActive) {
                        initializeGame();
                    }
                });
            }
        }

        function onLayoutChangeSettings() {
            currentLayout = document.getElementById('layoutSelectSettings').value;
            localStorage.setItem('keyboardLayout', currentLayout);
            // Show/hide ligature toggle based on layout
            // Only show for imperial, igc, qwerty, and jafl
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'igc' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';
            updateLevelSelector();

            // Only reinitialize if not in an active game
            const isGameActive = !document.getElementById('gameContent').classList.contains('hidden');
            if (!isGameActive) {
                initializeGame();
            }

            // Update virtual keyboard labels
            updateVirtualKeyboardLabels();
        }

        function onLigatureToggleSettings() {
            useLigatures = document.getElementById('ligatureToggleSettings').checked;
            localStorage.setItem('useLigatures', useLigatures);
            updateLevelSelector();

            // Only reinitialize if not in an active game
            const isGameActive = !document.getElementById('gameContent').classList.contains('hidden');
            if (!isGameActive) {
                initializeGame();
            }
        }

        function onLevelCountChange() {
            levelCount = parseInt(document.getElementById('levelCountSelect').value);
            localStorage.setItem('levelCount', levelCount.toString());
        }

        function onLevelChange() {
            selectedLevel = document.getElementById('levelSelect').value;
            initializeGame();
        }

        function getLearnWords() {
            // Get the appropriate word list for current layout and ligature settings
            if (currentLayout === 'imperial') {
                return useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'igc') {
                return useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                return learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                return learnWords2layer;
            } else if (currentLayout === 'jafl') {
                return useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }
            return null;
        }

        function translateLessonName(name) {
            const t = getCurrentTranslations();

            // Map English lesson names to translation keys
            const nameMap = {
                'Home Row Center': t.lessonHomeRowCenter,
                'Full Home Row': t.lessonFullHomeRow,
                'Index Finger Reach': t.lessonIndexFingerReach,
                'Upper & Lower Rows': t.lessonUpperLowerRows,
                'Number Row Focus': t.lessonNumberRowFocus,
                'Hard to Reach': t.lessonHardToReach,
                'All Keys': t.lessonAllKeys,
                'Compound Letters': t.lessonCompoundLetters,
                'Home Row + Shift': t.lessonHomeRowShift,
                'Add Upper Row': t.lessonAddUpperRow,
                'Add Lower Row': t.lessonAddLowerRow,
                'Essential Phonemes': t.lessonEssentialPhonemes,
                'Vowel Voyage': t.lessonVowelVoyage,
                'Consonant Command': t.lessonConsonantCommand,
                'Ligature Power': t.lessonLigaturePower,
                'Shift Mastery': t.lessonShiftMastery,
                'Complete Control': t.lessonCompleteControl,
                'Core Foundation': t.lessonCoreFoundation,
                'Home Sweet Home': t.lessonHomeSweet,
                'Upper Expedition': t.lessonUpperExpedition,
                'Lower Exploration': t.lessonLowerExploration,
                'Shift Introduction': t.lessonShiftIntroduction,
                'Master Typist': t.lessonMasterTypist
            };

            return nameMap[name] || name;
        }

        function translateLessonDescription(description) {
            const t = getCurrentTranslations();

            // Map English descriptions to translation keys
            const descMap = {
                'Middle fingers only, home row': t.desc1,
                'All fingers, home row': t.desc2,
                'Add index finger upper/lower reaches': t.desc3,
                'Extend to more keys above and below': t.desc4,
                'Add outer columns': t.desc5,
                'Complete keyboard (all layers)': t.desc6,
                'Practice typing ligatures: ğ‘¼ ğ‘¸ ğ‘¹ ğ‘¿ ğ‘½': t.desc7,
                'Home row with shift layer': t.desc8,
                'Add upper row (both layers)': t.desc9,
                'Add lower row (both layers)': t.desc10,
                'Master the 9 most common sounds in English': t.desc11,
                'Navigate through English vowel sounds': t.desc12,
                'Build confidence with base layer consonants': t.desc13,
                'Harness the efficiency of compound letters': t.desc14,
                'Unlock the full potential of the shift layer': t.desc15,
                'Command every key with confidence': t.desc16,
                'Build your foundation with essential sounds': t.desc17,
                'Master the comfort of the home row': t.desc18,
                'Journey to the upper reaches of your keyboard': t.desc19,
                'Explore the depths below home position': t.desc20,
                'Discover new dimensions with the shift key': t.desc21,
                'Achieve mastery over the complete keyboard': t.desc22,
                'All fingers, home row (unshifted)': t.desc23,
                'Complete keyboard including number row': t.desc24
            };

            return descMap[description] || description;
        }

        function updateLevelSelector() {
            const levelSelect = document.getElementById('levelSelect');

            // Level selector only exists in the main UI, not in settings
            if (!levelSelect) {
                return;
            }

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            // Clear existing options
            const t = getCurrentTranslations();
            levelSelect.innerHTML = ``;

            // Add lesson options with names
            if (learnWords) {
                const maxLevel = Object.keys(learnWords).length;

                for (let i = 1; i <= maxLevel; i++) {
                    const levelData = learnWords[i];
                    if (levelData) {
                        const option = document.createElement('option');
                        option.value = i;
                        const translatedName = translateLessonName(levelData.name);
                        option.textContent = `${i}. ${translatedName}`;
                        levelSelect.appendChild(option);
                    }
                }
            }

            // Reset to level 1 if selected level is now unavailable
            const maxLevel = (currentLayout === 'imperial' && useLigatures) ? 7 : 6;
            if (parseInt(selectedLevel) > maxLevel) {
                selectedLevel = 1;
            }

            // Restore selected value
            levelSelect.value = selectedLevel;
        }

        // Level configuration for different level counts
        const LEVEL_CONFIGS = {
            3: [
                { lengths: [1, 2, 3], title: 'Short Words' },
                { lengths: [3, 4, 5], title: 'Medium Words' },
                { lengths: [5, 6, 7], title: 'Long Words' }
            ],
            6: [
                { lengths: [1, 2], title: '1-2 Letters' },
                { lengths: [2, 3], title: '2-3 Letters' },
                { lengths: [3, 4], title: '3-4 Letters' },
                { lengths: [4, 5, 6], title: '4-6 Letters' },
                { lengths: [5, 6, 7], title: '5+ Letters' },
                { lengths: [6, 7], title: '6+ Letters' }
            ],
            10: [
                { lengths: [1], title: '1 Letter' },
                { lengths: [2], title: '2 Letters' },
                { lengths: [3], title: '3 Letters' },
                { lengths: [4], title: '4 Letters' },
                { lengths: [5], title: '5 Letters' },
                { lengths: [6], title: '6 Letters' },
                { lengths: [7], title: '7 Letters' },
                { lengths: [5, 6], title: '5-6 Letters' },
                { lengths: [6, 7], title: '6-7 Letters' },
                { lengths: [7], title: '7+ Letters' }
            ]
        };

        // Get word pool and metadata for a play level
        function getPlayLevelData(levelNum) {
            // Return null if beyond configured level count
            if (levelNum > levelCount || levelNum < 1) {
                return null;
            }

            const config = LEVEL_CONFIGS[levelCount];
            if (!config || levelNum > config.length) {
                return null;
            }

            const levelConfig = config[levelNum - 1];
            const pool = [];

            // Combine words from all specified lengths
            levelConfig.lengths.forEach(length => {
                if (wordsByLength[length]) {
                    pool.push(...wordsByLength[length]);
                }
            });

            return {
                wordPool: pool,
                wordCount: 5,
                title: levelConfig.title
            };
        }

        // Get word pool and metadata for a learn lesson
        function getLearnLessonData(lessonIndex) {
            let learnWords;

            if (currentLayout === 'imperial') {
                learnWords = useLigatures ? learnWordsImperial : learnWordsImperialNoLig;
            } else if (currentLayout === 'igc') {
                learnWords = useLigatures ? learnWordsNewImperial : learnWordsNewImperialNoLig;
            } else if (currentLayout === 'qwerty') {
                learnWords = learnWordsQwerty;
            } else if (currentLayout === '2layer') {
                learnWords = learnWords2layer;
            } else if (currentLayout === 'jafl') {
                learnWords = useLigatures ? learnWordsJafl : learnWordsJaflNoLig;
            }

            const levelData = learnWords[lessonIndex];
            if (levelData && levelData.words) {
                const translatedName = translateLessonName(levelData.name);
                return {
                    wordPool: levelData.words,
                    wordCount: 10,
                    title: translatedName
                };
            }

            return null;
        }

        // Load words from JSON
        async function loadWords() {
            try {
                // Load practice words
                const wordsResponse = await fetch(`words_${currentDialect}.json`);
                const wordsData = await wordsResponse.json();
                // Convert string keys to numbers
                Object.keys(wordsData).forEach(key => {
                    wordsByLength[parseInt(key)] = wordsData[key];
                });

                // Load learn mode words for Imperial
                const learnImperialResponse = await fetch(`learn_words_imperial_${currentDialect}.json`);
                const learnImperialData = await learnImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialData).forEach(key => {
                    learnWordsImperial[parseInt(key)] = learnImperialData[key];
                });

                // Load learn mode words for QWERTY
                const learnQwertyResponse = await fetch(`learn_words_qwerty_${currentDialect}.json`);
                const learnQwertyData = await learnQwertyResponse.json();
                // Convert string keys to numbers
                Object.keys(learnQwertyData).forEach(key => {
                    learnWordsQwerty[parseInt(key)] = learnQwertyData[key];
                });

                // Load learn mode words for Imperial (no ligatures)
                const learnImperialNoLigResponse = await fetch(`learn_words_imperial_${currentDialect}_no_lig.json`);
                const learnImperialNoLigData = await learnImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnImperialNoLigData).forEach(key => {
                    learnWordsImperialNoLig[parseInt(key)] = learnImperialNoLigData[key];
                });

                // Load learn mode words for New Imperial
                const learnNewImperialResponse = await fetch(`learn_words_igc_${currentDialect}.json`);
                const learnNewImperialData = await learnNewImperialResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialData).forEach(key => {
                    learnWordsNewImperial[parseInt(key)] = learnNewImperialData[key];
                });

                // Load learn mode words for New Imperial (no ligatures)
                const learnNewImperialNoLigResponse = await fetch(`learn_words_igc_${currentDialect}_no_lig.json`);
                const learnNewImperialNoLigData = await learnNewImperialNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnNewImperialNoLigData).forEach(key => {
                    learnWordsNewImperialNoLig[parseInt(key)] = learnNewImperialNoLigData[key];
                });

                // Load learn mode words for Shaw 2-layer
                const learn2layerResponse = await fetch(`learn_words_2layer_${currentDialect}.json`);
                const learn2layerData = await learn2layerResponse.json();
                // Convert string keys to numbers
                Object.keys(learn2layerData).forEach(key => {
                    learnWords2layer[parseInt(key)] = learn2layerData[key];
                });

                // Load learn mode words for Shaw-JAFL (with ligatures)
                const learnJaflResponse = await fetch(`learn_words_jafl_${currentDialect}.json`);
                const learnJaflData = await learnJaflResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflData).forEach(key => {
                    learnWordsJafl[parseInt(key)] = learnJaflData[key];
                });

                // Load learn mode words for Shaw-JAFL (no ligatures)
                const learnJaflNoLigResponse = await fetch(`learn_words_jafl_${currentDialect}_no_lig.json`);
                const learnJaflNoLigData = await learnJaflNoLigResponse.json();
                // Convert string keys to numbers
                Object.keys(learnJaflNoLigData).forEach(key => {
                    learnWordsJaflNoLig[parseInt(key)] = learnJaflNoLigData[key];
                });

                wordsLoaded = true;
                return true;
            } catch (error) {
                console.error('Failed to load words:', error);
                alert('Failed to load word list. Please refresh the page.');
                return false;
            }
        }

        // Initialize
        async function init() {
            await loadWords();
            if (wordsLoaded) {
                // Show splash for all users (first-time and returning)
                // Splash will then show setup dialog for first-time users
                showSplashIfNeeded();
                // Start on home screen - don't auto-load game
                // User will click Play or Practice to start
            }
        }

        // Countdown state
        let countdownTimeouts = [];
        let countdownCancelled = false;

        // Countdown animation before starting level
        function showCountdown(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            debug('[showCountdown] Starting countdown');

            // Clear any existing countdown
            cancelCountdown();
            countdownCancelled = false;

            const countdownScreen = document.getElementById('countdownScreen');
            const gameContent = document.getElementById('gameContent');
            const text = document.getElementById('countdownText');

            // Set instructions in subtitle
            const t = getCurrentTranslations();
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            // Show countdown, hide game content
            countdownScreen.classList.remove('hidden');
            gameContent.classList.add('hidden');

            let count = 3;
            function updateCountdown() {
                if (countdownCancelled) return; // Stop if cancelled

                if (count > 0) {
                    text.textContent = count;
                    // Reset animation
                    text.style.animation = 'none';
                    const animTimeout = setTimeout(() => {
                        if (countdownCancelled) return;
                        text.style.animation = 'countdown-pulse 0.5s ease-in-out';
                    }, 10);
                    countdownTimeouts.push(animTimeout);
                    count--;
                    const nextTimeout = setTimeout(updateCountdown, 800);
                    countdownTimeouts.push(nextTimeout);
                } else {
                    // Hide countdown, show game content
                    countdownScreen.classList.add('hidden');
                    gameContent.classList.remove('hidden');
                    // Call startLevel with the parameters
                    startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback);
                }
            }

            updateCountdown();
        }

        function cancelCountdown() {
            countdownCancelled = true;
            countdownTimeouts.forEach(timeout => clearTimeout(timeout));
            countdownTimeouts = [];
        }

        // Start a new level/lesson with given word pool, count, and metadata
        function startLevel(wordPool, wordCount, type, title, typeLabel, completionCallback) {
            debug(`[startLevel] Starting ${type}: "${title}" (${wordCount} words from pool of ${wordPool.length})`);

            // Set level state
            currentLevelWordPool = wordPool;
            currentLevelWordCount = wordCount;
            currentLevelType = type;
            currentLevelTitle = title;
            currentLevelTypeLabel = typeLabel;
            currentLevelCompletionCallback = completionCallback;
            wordsInCurrentLevel = 0;
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            recentWords = [];

            // Initialize game (loads words)
            initializeGame();

            // Clear input and shadow
            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;

            // Start timer only for play mode at level 1 (beginning of game)
            if (currentMode === 'play' && currentLevelNumber === 1 && wordsCompleted === 0) {
                startTime = Date.now();
            }

            // Focus input
            typingInput.focus();

            // Show virtual keyboard if setting is enabled
            const savedShowKeyboard = localStorage.getItem('showVirtualKeyboard');
            if (savedShowKeyboard === 'true') {
                showVirtualKeyboard();
                updateVirtualKeyboardLabels();
            }
        }

        function pickRandomWord() {
            const pool = currentLevelWordPool;
            if (!pool || pool.length === 0) {
                console.error('No word pool available!');
                return '';
            }

            const historySize = Math.min(10, Math.floor(pool.length / 2));
            let newWord;
            let attempts = 0;
            const maxAttempts = 50;

            do {
                newWord = pool[Math.floor(Math.random() * pool.length)];
                attempts++;
            } while (recentWords.includes(newWord) && attempts < maxAttempts);

            // Update recent words history
            recentWords.push(newWord);
            if (recentWords.length > historySize) {
                recentWords.shift();
            }

            return newWord;
        }

        function loadNewWord() {
            // Check if this is the last word of the level
            const isLastWordOfLevel = (wordsInCurrentLevel === currentLevelWordCount - 1);

            debug(`[loadNewWord] wordsInCurrentLevel=${wordsInCurrentLevel}, wordCount=${currentLevelWordCount}, isLastWord=${isLastWordOfLevel}`);

            // BEFORE advancing: update the slot that will become "next" after rotation
            // The slot at prev-prev position will rotate to next position
            const prevPrevSlot = (carouselOffset - 2 + 4) % 4;
            const slot = wordSlots[prevPrevSlot];

            // For the last word of a level, put an empty string in the next slot
            const newWord = isLastWordOfLevel ? '' : pickRandomWord();
            words[prevPrevSlot] = newWord;

            debug(`[loadNewWord] newWord="${newWord}", slot=${prevPrevSlot}`);

            if (newWord) {
                // Load a new word normally
                // Disable transitions for the new slot so it appears instantly
                slot.style.transition = 'none';

                // Form ligatures in the word if enabled (for display purposes)
                const displayWord = useLigatures ? formLigaturesInWord(newWord) : newWord;

                // Update the slot's HTML content so offsetWidth is accurate
                let html = '';
                const wordChars = Array.from(displayWord);
                for (let j = 0; j < wordChars.length; j++) {
                    html += `<span class="char">${wordChars[j]}</span>`;
                }
                slot.innerHTML = html;

                // Position it at next-next location (after current next word) BEFORE advancing
                // Calculate where next-next should be
                const currentSlotIndex = carouselOffset;
                const nextSlotIndex = (carouselOffset + 1) % 4;
                const carouselWidth = wordSlots[0].parentElement.clientWidth;
                const currentWidth = wordSlots[currentSlotIndex].offsetWidth;
                const nextWidth = wordSlots[nextSlotIndex].offsetWidth;
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Position the new slot at next-next location and make it visible
                slot.classList.remove('pos-prev-prev', 'pos-prev', 'pos-current', 'pos-next');
                slot.classList.add('pos-next-next');
                slot.style.transform = `translateX(${nextNextX}px) translateY(-50%)`;

                // Force reflow to apply the next-next position
                slot.offsetHeight;

                // Re-enable transitions so it can animate when repositioned
                slot.style.transition = '';
            } else {
                // Empty slot for after last word
                debug('[loadNewWord] Last word - empty next slot');
                slot.innerHTML = '';
            }

            // NOW advance carousel
            carouselOffset = (carouselOffset + 1) % 4;

            // Get current word from carousel
            currentWord = words[carouselOffset];

            // If ligatures are enabled, form them in the expected word
            if (useLigatures) {
                currentWord = formLigaturesInWord(currentWord);
            }

            // Append space or period to currentWord
            if (isLastWordOfLevel) {
                currentWord = currentWord + '.';
            } else {
                currentWord = currentWord + ' ';
            }

            // Store the processed word back (with ligatures if enabled, and space if needed)
            words[carouselOffset] = currentWord;

            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;
            updateWordDisplay();

            updateLevel();
        }

        function initializeGame() {
            debug(`[initializeGame] wordPool length: ${currentLevelWordPool.length}, wordCount: ${currentLevelWordCount}`);
            // Reset carousel completely
            words = ['', '', '', ''];
            carouselOffset = 2; // Will advance to 3, then 0
            // Run the cycle twice to load first two words
            loadNewWord(); // Loads first word, advances to offset 3
            loadNewWord(); // Loads second word, advances to offset 0 (current)
        }

        function advanceToNextWord() {
            // Just call loadNewWord - carousel positions will update via CSS transitions
            loadNewWord();
        }

        function updateLevel() {
            // Display the current level/lesson number
            levelDisplayEl.textContent = currentLevelNumber;
        }

        // Calculate appropriate font size based on max word length
        function getFontSizeForMaxLength(maxLength) {
            const baseFontSize = 48;
            // Reduce font size as max length increases: 48px for short words, down to 24px for very long
            if (maxLength <= 4) return baseFontSize;
            if (maxLength <= 6) return 42;
            if (maxLength <= 8) return 36;
            if (maxLength <= 10) return 30;
            return 24;
        }

        function updateWordDisplay() {
            const userInput = typingInput.value;

            // Calculate max word length in current pool for font sizing
            let maxWordLength = 4;
            if (currentLevelWordPool && currentLevelWordPool.length > 0) {
                maxWordLength = Math.max(...currentLevelWordPool.map(w => Array.from(w).length));
            }
            const fontSize = getFontSizeForMaxLength(maxWordLength);

            // Update each carousel slot
            for (let i = 0; i < 4; i++) {
                const slot = wordSlots[i];
                const word = words[i];

                // Calculate position relative to current
                const posOffset = (i - carouselOffset + 4) % 4;

                // Remove old position classes
                slot.className = 'word-slot slot-' + i;

                // Set font size based on max word length
                slot.style.fontSize = fontSize + 'px';

                // Add appropriate position class
                if (posOffset === 0) {
                    // Current word
                    slot.classList.add('pos-current');

                    // Build HTML with coloring for current word
                    let html = '';
                    const wordChars = Array.from(currentWord);
                    const inputChars = Array.from(userInput);

                    // Normalize arrays to treat char+VS1 as single units for comparison
                    const normalizedWordChars = normalizeCharArray(wordChars);
                    const normalizedInputChars = normalizeCharArray(inputChars);
                    const isPending = isPendingLigatureStart(inputChars, wordChars);

                    for (let j = 0; j < normalizedWordChars.length; j++) {
                        const char = normalizedWordChars[j];
                        let className = '';

                        if (j < normalizedInputChars.length) {
                            // User has typed this position
                            if (normalizedInputChars[j] === char) {
                                className = 'correct';
                            } else if (isPending && j === normalizedInputChars.length - 1) {
                                // Waiting for ligature completion - don't mark as wrong yet
                                className = '';
                            } else {
                                className = 'incorrect';
                            }
                        }
                        // else: not typed yet, no className

                        html += `<span class="char ${className}">${char}</span>`;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 1) {
                    // Next word
                    slot.classList.add('pos-next');
                    const displayWord = (useLigatures && word) ? formLigaturesInWord(word) : (word || '');
                    let html = '';
                    const wordChars = Array.from(displayWord);
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else if (posOffset === 3) {
                    // Previous word (already has ligatures formed when it was current)
                    slot.classList.add('pos-prev');
                    let html = '';
                    const wordChars = Array.from(word || '');
                    for (let j = 0; j < wordChars.length; j++) {
                        html += `<span class="char">${wordChars[j]}</span>`;
                    }
                    slot.innerHTML = html;
                } else {
                    // Previous-previous word (off screen)
                    slot.classList.add('pos-prev-prev');
                    slot.innerHTML = '';
                }
            }

            // Calculate positions based on actual widths
            // Wait for next frame to ensure content is rendered
            requestAnimationFrame(() => {
                const carouselWidth = wordSlots[0].parentElement.clientWidth;

                // Find which slot is at each position
                let currentSlot = -1, prevSlot = -1, nextSlot = -1, nextNextSlot = -1;
                for (let i = 0; i < 4; i++) {
                    const posOffset = (i - carouselOffset + 4) % 4;
                    if (posOffset === 0) currentSlot = i;
                    else if (posOffset === 1) nextSlot = i;
                    else if (posOffset === 2) nextNextSlot = i;
                    else if (posOffset === 3) prevSlot = i;
                }

                // Get widths
                const currentWidth = wordSlots[currentSlot].offsetWidth;
                const prevWidth = prevSlot >= 0 ? wordSlots[prevSlot].offsetWidth : 0;
                const nextWidth = nextSlot >= 0 ? wordSlots[nextSlot].offsetWidth : 0;

                // Calculate positions - center current word, position others relative to it
                const currentX = (carouselWidth / 2) - (currentWidth / 2);
                const prevX = currentX - prevWidth;
                const nextX = currentX + currentWidth;
                const nextNextX = nextX + nextWidth;

                // Apply transforms (include translateY for vertical centering)
                wordSlots[currentSlot].style.transform = `translateX(${currentX}px) translateY(-50%)`;
                if (prevSlot >= 0) wordSlots[prevSlot].style.transform = `translateX(${prevX}px) translateY(-50%)`;
                if (nextSlot >= 0) wordSlots[nextSlot].style.transform = `translateX(${nextX}px) translateY(-50%)`;
                if (nextNextSlot >= 0) wordSlots[nextNextSlot].style.transform = `translateX(${nextNextX}px) translateY(-50%)`;
            });
        }

        function updateStats() {
            wordCountEl.textContent = wordsCompleted;
            const accuracy = totalLettersTyped === 0 ? 100 : ((correctLetters / totalLettersTyped) * 100).toFixed(1);
            accuracyEl.textContent = accuracy + '%';
        }

        function checkCompletion() {
            const userInput = typingInput.value;

            // Check if user typed the complete word correctly
            if (userInput === currentWord) {
                // Word completed correctly
                wordsCompleted++;
                wordsInCurrentLevel++;
                debug(`[checkCompletion] Word ${wordsInCurrentLevel} of level completed (total: ${wordsCompleted})`);
                updateStats();

                // After first word, update subtitle with level/lesson info
                if (wordsCompleted === 1) {
                    document.getElementById('mainSubtitle').textContent =
                        `${currentLevelTypeLabel} ${currentLevelNumber}: ${currentLevelTitle}`;
                }

                // Check if level is complete
                if (wordsInCurrentLevel === currentLevelWordCount) {
                    // Level completed - transition to next level
                    debug(`[checkCompletion] ${currentLevelType.toUpperCase()} COMPLETED`);
                    transitionToNextLevel();
                } else {
                    // Advance to next word
                    advanceToNextWord();
                }
            }
        }

        function transitionToNextLevel() {
            console.log('[transitionToNextLevel] Starting transition');

            // Save stats for completed level
            const finalLevelAccuracy = currentLevelLettersTyped === 0 ? 100.0 :
                ((currentLevelCorrectLetters / currentLevelLettersTyped) * 100);
            levelStats.push({
                level: currentLevelNumber,
                accuracy: finalLevelAccuracy,
                lettersTyped: currentLevelLettersTyped,
                correctLetters: currentLevelCorrectLetters
            });

            // If there's a completion callback, use it
            if (currentLevelCompletionCallback) {
                currentLevelCompletionCallback();
                return;
            }

            // Default behavior: try to advance to next level
            let nextLevelData = null;
            if (currentMode === 'learn') {
                const nextLessonIndex = parseInt(selectedLevel) + 1;
                nextLevelData = getLearnLessonData(nextLessonIndex);
                if (nextLevelData) {
                    selectedLevel = nextLessonIndex.toString();
                    currentLevelNumber = nextLessonIndex;
                }
            } else {
                const nextLevelNum = currentLevelNumber + 1;
                if (nextLevelNum <= levelCount) {
                    nextLevelData = getPlayLevelData(nextLevelNum);
                    currentLevelNumber = nextLevelNum;
                }
            }

            if (nextLevelData) {
                // Start new level with new words (no countdown between levels!)
                const t = getCurrentTranslations();
                const type = currentMode === 'learn' ? 'lesson' : 'level';
                const typeLabel = type === 'lesson' ? t.lesson_label : t.level_label;

                // Set instructions in subtitle for practice mode
                if (type === 'lesson') {
                    document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                }

                // Just start the level directly (both play and practice)
                startLevel(nextLevelData.wordPool, nextLevelData.wordCount, type, nextLevelData.title, typeLabel, currentLevelCompletionCallback);
            } else {
                // No more levels/lessons - show completion modal
                showCompletionModal();
            }
        }

        function showLessonCompletionDialog() {

            // Calculate stats for this lesson
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Set modal content for lesson completion
            const t = getCurrentTranslations();
            document.getElementById('completionTitle').textContent = t.lessonComplete;
            document.getElementById('completionMessage').textContent = t.completedWords.replace('{n}', wordsCompleted);

            // Hide game-specific stats
            document.getElementById('finalScore').style.display = 'none';
            document.getElementById('finalWPM').parentElement.style.display = 'none';
            document.getElementById('finalLPM').parentElement.style.display = 'none';
            document.getElementById('bestTimeRow').style.display = 'none';
            document.getElementById('levelReachedRow').style.display = 'none';
            document.getElementById('levelStatsContainer').style.display = 'none';

            // Show accuracy
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';

            // Show lesson completion buttons
            const learnWords = getLearnWords();
            const maxLesson = learnWords ? Object.keys(learnWords).length : 6;
            const hasNextLesson = parseInt(selectedLevel) < maxLesson;

            document.getElementById('completionButtons').innerHTML = `
                <button onclick="continueLesson()">Keep practicing this lesson</button>
                ${hasNextLesson ? '<button onclick="nextLesson()" style="margin-left: 10px;">Next lesson</button>' : ''}
                <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
            `;

            document.getElementById('completionModal').classList.add('show');
        }

        function showCompletionModal() {
            // Stats already saved in transitionToNextLevel
            const accuracy = totalLettersTyped === 0 ? 100.0 : ((correctLetters / totalLettersTyped) * 100);
            const accuracyFormatted = accuracy.toFixed(1) + '%';

            // Calculate time-based metrics (excluding paused time)
            const endTime = Date.now();
            const elapsedMilliseconds = (endTime - startTime) - totalPausedTime;
            const elapsedSeconds = elapsedMilliseconds / 1000;
            const elapsedMinutes = elapsedSeconds / 60;
            const wpm = wordsCompleted / elapsedMinutes;
            const lettersPerMinute = totalLettersTyped / elapsedMinutes;

            // Format time as MM:SS
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = Math.floor(elapsedSeconds % 60);
            const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Track high scores per level count
            const levelCountKey = levelCount.toString();
            if (!highScores[levelCountKey]) {
                highScores[levelCountKey] = { time: null, wpm: null, accuracy: null };
            }

            const currentHighScores = highScores[levelCountKey];
            let isNewTimeRecord = false;
            let isNewWPMRecord = false;
            let isNewAccuracyRecord = false;

            // Check and update time record (lower is better)
            if (currentHighScores.time === null || elapsedSeconds < currentHighScores.time) {
                currentHighScores.time = elapsedSeconds;
                isNewTimeRecord = true;
            }

            // Check and update WPM record (higher is better)
            if (currentHighScores.wpm === null || wpm > currentHighScores.wpm) {
                currentHighScores.wpm = wpm;
                isNewWPMRecord = true;
            }

            // Check and update accuracy record (higher is better)
            if (currentHighScores.accuracy === null || accuracy > currentHighScores.accuracy) {
                currentHighScores.accuracy = accuracy;
                isNewAccuracyRecord = true;
            }

            // Save high scores
            localStorage.setItem('highScores', JSON.stringify(highScores));

            // Legacy bestTime support
            const isNewBest = bestTime === null || elapsedSeconds < bestTime;
            if (isNewBest) {
                bestTime = elapsedSeconds;
            }

            // Get translations
            const t = getCurrentTranslations();

            // Customize modal based on mode
            if (currentMode === 'learn') {
                document.getElementById('completionTitle').textContent = t.sessionComplete;
                document.getElementById('completionMessage').textContent = t.completed10;
                document.getElementById('levelReachedRow').style.display = 'none';
                document.getElementById('levelStatsContainer').style.display = 'none';

                // Show buttons for continue or choose lesson
                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="continueLesson()">Continue</button>
                    <button onclick="chooseDifferentLesson()" style="margin-left: 10px; background: white; color: #667eea; border: 2px solid #667eea;">Choose Different Lesson</button>
                `;
            } else {
                document.getElementById('completionTitle').textContent = t.congratulations;
                document.getElementById('completionMessage').textContent = t.completedWords.replace('{n}', wordsCompleted);
                document.getElementById('levelReachedRow').style.display = 'block';
                document.getElementById('levelStatsContainer').style.display = 'block';

                document.getElementById('finalLevel').textContent = currentLevelNumber;

                // Generate per-level stats HTML
                let levelStatsHTML = '';
                levelStats.forEach(stat => {
                    const levelAccuracyFormatted = stat.accuracy.toFixed(1);
                    const levelLabel = currentMode === 'learn' ? t.lesson_label : t.level_label;
                    levelStatsHTML += `<div class="level-stat">${levelLabel} ${stat.level}: ${levelAccuracyFormatted}%</div>`;
                });
                document.getElementById('levelStatsContainer').innerHTML = levelStatsHTML;

                document.getElementById('completionButtons').innerHTML = `
                    <button onclick="playAgain()">Play Again</button>
                `;
            }

            // Update main display (time is the primary score)
            document.getElementById('finalScore').textContent = timeFormatted;
            document.getElementById('finalScore').style.display = 'block';

            // Update all stat rows and show them for play mode
            document.getElementById('finalAccuracy').textContent = accuracyFormatted;
            document.getElementById('finalAccuracy').parentElement.style.display = 'block';
            document.getElementById('finalWPM').textContent = wpm.toFixed(1);
            document.getElementById('finalWPM').parentElement.style.display = 'block';
            document.getElementById('finalLPM').textContent = lettersPerMinute.toFixed(0);
            document.getElementById('finalLPM').parentElement.style.display = 'block';

            // Show personal best records for this level count
            let recordsHTML = '';
            const records = [];

            if (isNewTimeRecord) {
                records.push('Time');
            }
            if (isNewWPMRecord) {
                records.push('WPM');
            }
            if (isNewAccuracyRecord) {
                records.push('Accuracy');
            }

            if (records.length > 0) {
                const recordsText = records.join(', ');
                recordsHTML = `<span style="color: #28a745; font-weight: bold;">New Personal Best: ${recordsText}!</span>`;
            } else if (currentHighScores.time !== null) {
                // Show current records for this level count
                const bestMinutes = Math.floor(currentHighScores.time / 60);
                const bestSeconds = Math.floor(currentHighScores.time % 60);
                const bestTimeFormatted = `${bestMinutes}:${bestSeconds.toString().padStart(2, '0')}`;
                const bestWPM = currentHighScores.wpm ? currentHighScores.wpm.toFixed(1) : 'N/A';
                const bestAccuracy = currentHighScores.accuracy ? currentHighScores.accuracy.toFixed(1) + '%' : 'N/A';
                recordsHTML = `Personal Bests (${levelCount} levels): Time ${bestTimeFormatted} | WPM ${bestWPM} | Accuracy ${bestAccuracy}`;
            }

            document.getElementById('bestTimeRow').innerHTML = recordsHTML;

            document.getElementById('completionModal').classList.add('show');
        }

        function resetPractice() {
            // Reset all stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            currentLevelNumber = 1;
            recentWords = [];
            levelStats = [];

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();
            updateLevel();

            // Start first level
            const t = getCurrentTranslations();

            if (currentMode === 'play') {
                const levelData = getPlayLevelData(1);
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;
                startLevel(levelData.wordPool, levelData.wordCount, 'level', levelData.title, t.level_label, null);
            } else {
                // In learn mode, use the selected lesson
                // Set instructions in subtitle
                document.getElementById('mainSubtitle').textContent = t.gameInstructions;

                const levelData = getLearnLessonData(parseInt(selectedLevel));
                if (levelData) {
                    currentLevelNumber = parseInt(selectedLevel);
                    startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
                }
            }
        }

        function continueLesson() {
            // Reset session stats but keep same lesson
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;

            // Hide modal
            document.getElementById('completionModal').classList.remove('show');

            // Update display
            updateStats();

            // Restart current level/lesson with same word pool
            startLevel(currentLevelWordPool, currentLevelWordCount, currentLevelType, currentLevelTitle, currentLevelTypeLabel, currentLevelCompletionCallback);
            typingInput.focus();
        }

        function nextLesson() {
            // Advance to next lesson
            const nextLessonNum = parseInt(selectedLevel) + 1;
            const learnWords = getLearnWords();
            const maxLesson = learnWords ? Object.keys(learnWords).length : 6;

            if (nextLessonNum <= maxLesson) {
                selectedLevel = nextLessonNum.toString();

                // Hide modal
                document.getElementById('completionModal').classList.remove('show');

                // Reset session stats
                wordsCompleted = 0;
                totalLettersTyped = 0;
                correctLetters = 0;
                recentWords = [];
                currentLevelLettersTyped = 0;
                currentLevelCorrectLetters = 0;
                updateStats();

                // Start next lesson
                const t = getCurrentTranslations();
                const levelData = getLearnLessonData(nextLessonNum);
                if (levelData) {
                    currentLevelNumber = nextLessonNum;
                    startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
                    typingInput.focus();
                }
            }
        }

        function chooseDifferentLesson() {
            // Hide completion modal
            document.getElementById('completionModal').classList.remove('show');

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            recentWords = [];
            currentLevelLettersTyped = 0;
            currentLevelCorrectLetters = 0;
            updateStats();

            // Open lesson selector
            openLessonSelector();
        }

        // Expose helper functions for console testing
        // Helper function to set the current word (for testing)
        // Usage: loadWord("ğ‘•ğ‘©ğ‘¥ğ‘¢ğ‘»ğ‘›")
        window.loadWord = function(word) {
            const currentSlot = carouselOffset;
            words[currentSlot] = word;
            currentWord = word;

            // Clear input and reset state
            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;

            // Temporarily modify word pool to include this word at max length for font sizing test
            const wordLength = Array.from(word).length;
            const tempPool = [...(currentLevelWordPool || []), word];
            currentLevelWordPool = tempPool;

            // Update display to show the word and apply font sizing
            updateWordDisplay();

            debug(`[loadWord] Current word set to: "${word}" (length: ${wordLength})`);
        };

        // Helper function to advance to next word with a specific word (for testing)
        // Usage: setNextWord("ğ‘•ğ‘©ğ‘¥ğ‘¢ğ‘»ğ‘›")
        window.setNextWord = function(word) {
            // Advance carousel as if completing current word
            carouselOffset = (carouselOffset + 1) % 4;

            // Set the new "next-next" word (slot that will become next after this rotation)
            const nextNextSlot = (carouselOffset + 2) % 4;
            words[nextNextSlot] = word;

            // Update currentWord to the new current slot
            currentWord = words[carouselOffset];

            // Clear input and reset state for new word
            typingInput.value = '';
            shadowInput = '';
            previousInput = '';
            maxEffectiveLength = 0;
            isInErrorState = false;

            // Temporarily modify word pool to include this word at max length for font sizing test
            const wordLength = Array.from(word).length;
            const tempPool = [...(currentLevelWordPool || []), word];
            currentLevelWordPool = tempPool;

            // Update display to show the rotated carousel and apply font sizing
            updateWordDisplay();

            debug(`[setNextWord] Advanced carousel, current="${currentWord}", queued="${word}" (length: ${wordLength})`);
        };

        // Event listeners
        let previousInput = '';  // For error state reversion
        let maxEffectiveLength = 0;  // High water mark for counting (excludes pending ligature starts)
        let isInErrorState = false; // Track if last typed character was incorrect

        // Helper: Convert string to array of Unicode code points for debugging
        function toCodePoints(str) {
            return Array.from(str).map(c =>
                'U+' + c.codePointAt(0).toString(16).toUpperCase().padStart(4, '0')
            ).join(' ');
        }

        // Helper: Form ligatures in input string if enabled
        function formLigatures(input) {
            if (!useLigatures) return input;
            const chars = Array.from(input);

            // Normalize to treat base+VS1 as single units
            const normalizedChars = normalizeCharArray(chars);

            // Check if last 2 normalized characters form a ligature
            if (normalizedChars.length >= 2) {
                const lastTwo = normalizedChars[normalizedChars.length - 2] + normalizedChars[normalizedChars.length - 1];
                debug('ğŸ”— LIGATURE CHECK: lastTwo="' + lastTwo + '" [' + toCodePoints(lastTwo) + ']' +
                      ' | maps to: ' + (COMPONENT_TO_LIGATURE[lastTwo] || 'none'));
                if (COMPONENT_TO_LIGATURE[lastTwo]) {
                    const result = normalizedChars.slice(0, -2).join('') + COMPONENT_TO_LIGATURE[lastTwo];
                    debug('âœ… LIGATURE FORMED: "' + result + '" [' + toCodePoints(result) + ']');
                    return result;
                }
            }

            return input;
        }

        // Helper: Normalize character array to merge VS1 with preceding character
        // Converts ['ğ‘»', 'ï¸€', 'ğ‘®'] to ['ğ‘»ï¸€', 'ğ‘®']
        function normalizeCharArray(chars) {
            const result = [];
            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                // Check if this is VS1 and we have a previous character
                if (char === VS1 && result.length > 0) {
                    // Merge VS1 with the previous character
                    result[result.length - 1] = result[result.length - 1] + VS1;
                } else {
                    result.push(char);
                }
            }
            return result;
        }

        // Helper: Check if last character is a pending ligature start
        function isPendingLigatureStart(inputChars, wordChars) {
            if (!useLigatures || inputChars.length === 0) return false;

            // Normalize arrays to treat char+VS1 as single units
            const normalizedInput = normalizeCharArray(inputChars);
            const normalizedWord = normalizeCharArray(wordChars);

            const lastIdx = normalizedInput.length - 1;
            if (lastIdx >= normalizedWord.length) return false;

            const expectedChar = normalizedWord[lastIdx];
            const lastChar = normalizedInput[lastIdx];

            // Check if the last character is the first of any pair that forms the expected ligature
            if (LIGATURES[expectedChar]) {
                return LIGATURES[expectedChar].some(pair => pair[0] === lastChar);
            }

            return false;
        }

        // Helper: Update shadow input based on InputEvent
        // Returns the updated shadow input string
        // browserValue is what the browser's input field currently shows (after the event)
        function updateShadowInput(inputType, eventData, currentShadow, browserValue) {
            switch (inputType) {
                case 'insertText':
                    // Normal typing - append what was actually typed (preserves VS1)
                    return currentShadow + (eventData || '');

                case 'deleteContentBackward':
                    // Backspace - remove last character (treating base+VS1 as single unit)
                    const chars = Array.from(currentShadow); // Split into code points
                    if (chars.length === 0) return '';

                    // Check if last code point is VS1 (U+FE00)
                    if (chars.length >= 2 && chars[chars.length - 1].codePointAt(0) === 0xFE00) {
                        // Last code point is VS1, delete both base character and VS1
                        return chars.slice(0, -2).join('');
                    }

                    // Normal deletion - remove last code point
                    return chars.slice(0, -1).join('');

                case 'deleteContentForward':
                    // Delete key - remove first character (shouldn't happen in our UI)
                    const charsForward = Array.from(currentShadow);
                    return charsForward.slice(1).join('');

                case 'insertReplacementText':
                    // Safari uses this for ligature formation from virtual keyboard
                    // Use the replacement range captured from beforeinput event
                    if (pendingReplacementStart >= 0 && pendingReplacementEnd >= 0) {
                        const chars = Array.from(currentShadow);
                        const before = chars.slice(0, pendingReplacementStart).join('');
                        const after = chars.slice(pendingReplacementEnd).join('');
                        const result = before + (eventData || '') + after;
                        // Reset pending replacement
                        pendingReplacementStart = -1;
                        pendingReplacementEnd = -1;
                        return result;
                    }
                    // Fallback if we didn't capture the range
                    return browserValue;

                case 'insertFromPaste':
                case 'insertFromDrop':
                    // Paste or drop - replace entire content
                    return eventData || browserValue;

                case 'deleteWordBackward':
                case 'deleteWordForward':
                case 'deleteByCut':
                    // Word deletion or cut - use browser's resulting value
                    return browserValue;

                case 'insertCompositionText':
                    // IME composition - trust browser value
                    return browserValue;

                default:
                    // Unknown or null inputType - trust browser value
                    return browserValue;
            }
        }

        // Helper: Update statistics based on new input length
        function updateInputStatistics(effectiveLength, inputChars, wordChars) {
            if (effectiveLength < maxEffectiveLength) {
                // Backspace or deletion - clear error state
                isInErrorState = false;
                maxEffectiveLength = effectiveLength;
            } else if (effectiveLength > maxEffectiveLength) {
                // New characters to count
                const numNew = effectiveLength - maxEffectiveLength;
                totalLettersTyped += numNew;
                currentLevelLettersTyped += numNew;

                // Check correctness
                let allCorrect = true;
                for (let i = maxEffectiveLength; i < effectiveLength; i++) {
                    if (i >= wordChars.length || inputChars[i] !== wordChars[i]) {
                        allCorrect = false;
                        break;
                    }
                }

                if (allCorrect) {
                    correctLetters += numNew;
                    currentLevelCorrectLetters += numNew;
                    isInErrorState = false;
                } else {
                    isInErrorState = true;
                }

                maxEffectiveLength = effectiveLength;
            }
        }

        // Helper: Convert UTF-16 code unit position to character index
        function codeUnitPosToCharIndex(str, codeUnitPos) {
            let charIndex = 0;
            let codeUnitIndex = 0;
            for (const char of str) {
                if (codeUnitIndex >= codeUnitPos) break;
                codeUnitIndex += char.length; // Shavian chars are 2 code units
                charIndex++;
            }
            return charIndex;
        }

        // Capture target ranges before input is processed (for insertReplacementText)
        typingInput.addEventListener('beforeinput', (e) => {
            if (e.inputType === 'insertReplacementText') {
                // Get the selection/range being replaced (in UTF-16 code units)
                const startCodeUnit = typingInput.selectionStart;
                const endCodeUnit = typingInput.selectionEnd;

                // Convert to character positions for shadow input
                const currentValue = typingInput.value;
                pendingReplacementStart = codeUnitPosToCharIndex(currentValue, startCodeUnit);
                pendingReplacementEnd = codeUnitPosToCharIndex(currentValue, endCodeUnit);

                debug('ğŸ” BEFOREINPUT: replacing code units ' + startCodeUnit + '-' + endCodeUnit +
                      ' (chars ' + pendingReplacementStart + '-' + pendingReplacementEnd + ')' +
                      ' with "' + (e.data || '') + '" [' + toCodePoints(e.data || '') + ']');
            }
        });

        typingInput.addEventListener('input', (e) => {
            let browserInput = e.target.value;
            let eventData = e.data || '';

            // Virtual keyboard: translate QWERTY input to Shavian if needed
            if (useVirtualKeyboard && e.inputType === 'insertText' && eventData.length > 0) {
                const keyboardMap = KEYBOARD_MAPS[currentLayout];
                if (keyboardMap) {
                    // Check if the input data is a Latin character that needs translation
                    const codePoint = eventData.codePointAt(0);
                    const isShavian = codePoint >= 0x10450 && codePoint <= 0x1047F;

                    if (!isShavian && keyboardMap[eventData]) {
                        // Input is Latin and has a mapping - translate it
                        const translatedChar = keyboardMap[eventData];
                        debug('âŒ¨ï¸  Translating: "' + eventData + '" â†’ "' + translatedChar + '" [' + toCodePoints(translatedChar) + ']');

                        // Remove the Latin character that was inserted and replace with Shavian
                        const originalLength = eventData.length;
                        const selectionPos = typingInput.selectionStart;
                        const before = browserInput.substring(0, selectionPos - originalLength);
                        const after = browserInput.substring(selectionPos);
                        browserInput = before + after; // Remove the original character

                        eventData = translatedChar;
                    }
                }
            }

            // Check if this character would complete a ligature
            let completesLigature = false;
            if (useLigatures && e.inputType === 'insertText' && eventData) {
                const chars = Array.from(shadowInput);
                const normalizedChars = normalizeCharArray(chars);
                if (normalizedChars.length > 0) {
                    const potentialPair = normalizedChars[normalizedChars.length - 1] + eventData;
                    completesLigature = !!COMPONENT_TO_LIGATURE[potentialPair];
                }
            }

            // Block if user is in error state and trying to add more characters
            // (but allow ligature completion)
            const isAddingCharacters = e.inputType === 'insertText' ||
                                      e.inputType === 'insertFromPaste' ||
                                      e.inputType === 'insertReplacementText';

            if (isInErrorState && isAddingCharacters && !completesLigature) {
                // Block the input - revert and flash red
                typingInput.value = previousInput;
                typingInput.style.animation = 'none';
                setTimeout(() => {
                    typingInput.style.animation = 'error-flash 0.4s ease-out';
                }, 10);
                debug('ğŸš« BLOCKED: user in error state, rejecting input');
                return;
            }

            if (completesLigature) {
                debug('âœ… ALLOWING: completes ligature' + (isInErrorState ? ' (in error state)' : ''));
            }

            // Update shadow input based on what was actually typed
            shadowInput = updateShadowInput(e.inputType, eventData, shadowInput, browserInput);

            // Debug: log raw input with Unicode code points
            debug('ğŸ“¥ INPUT: browser="' + browserInput + '" [' + toCodePoints(browserInput) + ']' +
                  ' | inputType=' + e.inputType +
                  ' | event.data="' + eventData + '" [' + toCodePoints(eventData) + ']' +
                  ' | shadow="' + shadowInput + '" [' + toCodePoints(shadowInput) + ']' +
                  ' | expected="' + currentWord + '" [' + toCodePoints(currentWord) + ']');

            // Use shadow input as source of truth
            let userInput = shadowInput;

            // Ignore leading spaces at the start of the level
            if (maxEffectiveLength === 0 && userInput.trim() === '') {
                shadowInput = '';
                typingInput.value = '';
                return;
            }

            // Form ligatures if enabled (for keyboards that don't do it themselves)
            userInput = formLigatures(userInput);

            // Update both shadow and display to match formed ligatures
            shadowInput = userInput;
            typingInput.value = userInput;

            // Get character arrays for comparison
            const inputChars = Array.from(userInput);
            const wordChars = Array.from(currentWord);

            // Normalize to treat char+VS1 as single units
            const normalizedInputChars = normalizeCharArray(inputChars);
            const normalizedWordChars = normalizeCharArray(wordChars);

            // Calculate effective length (excludes pending ligature start)
            const pendingLigature = isPendingLigatureStart(inputChars, wordChars);
            const effectiveLength = pendingLigature ? normalizedInputChars.length - 1 : normalizedInputChars.length;

            // Update statistics
            const result = updateInputStatistics(effectiveLength, normalizedInputChars, normalizedWordChars);
            previousInput = typingInput.value;

            // Debug: log final state
            debug('ğŸ“Š POSTCONDITION: input=' + JSON.stringify(typingInput.value) +
                  ', correct=' + correctLetters + '/' + totalLettersTyped +
                  ', maxEffectiveLength=' + maxEffectiveLength +
                  ', isInErrorState=' + isInErrorState);

            updateWordDisplay();
            updateStats();
            checkCompletion();
        });

        // No need for separate keydown handler - space is part of the word now
        // Auto-advance happens in checkCompletion when word+space is typed

        // Burger menu functions
        function toggleBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.toggle('show');
        }

        function closeBurgerMenu() {
            const dropdown = document.getElementById('burgerDropdown');
            dropdown.classList.remove('show');
        }

        // Close burger menu if clicking outside
        window.addEventListener('click', function(e) {
            if (!e.target.matches('.burger-btn') && !e.target.closest('.burger-menu')) {
                closeBurgerMenu();
            }
        });

        // Content modal functions
        async function openContentModal(page) {
            closeBurgerMenu();

            // Pause timer if in play mode
            if (currentMode === 'play') {
                pauseTimer();
            }

            const modal = document.getElementById('contentModal');
            const bodyEl = document.getElementById('contentModalBody');

            bodyEl.innerHTML = 'Loading...';

            // Show modal
            modal.classList.add('show');

            // Load content based on current dialect (for Shavian) or use latin
            let filename;
            if (useShavianUI) {
                // Use dialect-specific Shavian content
                const dialect = currentDialect === 'gb' ? 'british' : 'american';
                filename = `${page}_${dialect}.html`;
            } else {
                // Use Latin content (no dialect variation needed)
                filename = `${page}_latin.html`;
            }

            try {
                const response = await fetch(filename);
                if (response.ok) {
                    const html = await response.text();
                    bodyEl.innerHTML = html;
                } else {
                    bodyEl.innerHTML = '<p>Content not found.</p>';
                }
            } catch (error) {
                bodyEl.innerHTML = '<p>Error loading content.</p>';
                console.error('Error loading content:', error);
            }
        }

        function closeContentModal() {
            document.getElementById('contentModal').classList.remove('show');

            // Resume timer if in play mode
            if (currentMode === 'play') {
                resumeTimer();
            }
        }

        // Welcome modal functions
        // Setup dialog functions
        function onDialectChangeSetup() {
            const selected = document.querySelector('input[name="dialectSetup"]:checked');
            if (selected) {
                currentDialect = selected.value;
                localStorage.setItem('dialect', currentDialect);
                // Update UI translations for new dialect
                updateUILanguage();
                // Reload words with new dialect
                loadWords().then(() => {
                    updateLevelSelector();
                    initializeGame();
                });
            }
        }

        function onLayoutChangeSetup() {
            currentLayout = document.getElementById('layoutSelectSetup').value;
            localStorage.setItem('keyboardLayout', currentLayout);
        }

        function updateWelcomeLanguage() {
            const lang = useShavianUI ? 'shavian' : 'latin';
            // TODO: Add Shavian translations for welcome screen
            if (useShavianUI) {
                document.getElementById('welcomeTitle').textContent = 'ğ‘¢ğ‘§ğ‘¤ğ‘’ğ‘³ğ‘¥ ğ‘‘ Â·ğ‘–ğ‘· ğ‘‘ğ‘²ğ‘!';
                document.getElementById('welcomeSubtitle').textContent = 'ğ‘—ğ‘µğ‘Ÿ ğ‘˜ğ‘¹ ğ‘ğ‘®ğ‘§ğ‘“ğ‘¼ğ‘©ğ‘¯ğ‘•ğ‘©ğ‘Ÿ ğ‘‘ ğ‘œğ‘§ğ‘‘ ğ‘•ğ‘‘ğ‘¸ğ‘‘ğ‘©ğ‘›:';
                document.getElementById('welcomeDialectLabel').textContent = 'ğ‘—ğ‘µğ‘Ÿ ğ‘•ğ‘ğ‘§ğ‘¤ğ‘¦ğ‘™';
                document.getElementById('welcomeDialectBritish').textContent = 'ğ‘šğ‘®ğ‘¦ğ‘‘ğ‘¦ğ‘–';
                document.getElementById('welcomeDialectAmerican').textContent = 'ğ‘©ğ‘¥ğ‘§ğ‘®ğ‘¦ğ‘’ğ‘©ğ‘¯';
                document.getElementById('welcomeLayoutLabel').textContent = 'ğ‘’ğ‘°ğ‘šğ‘ªğ‘®ğ‘› ğ‘¤ğ‘±ğ‘¬ğ‘‘';
                document.getElementById('welcomeLigatureLabel').textContent = 'ğ‘·ğ‘‘ğ‘©ğ‘¥ğ‘¨ğ‘‘ğ‘¦ğ‘’ ğ‘¤ğ‘¦ğ‘œğ‘©ğ‘—ğ‘¼ğ‘Ÿ (ğ‘©+ğ‘®â†’ğ‘¼, ğ‘˜+ğ‘µâ†’ğ‘¿)';
                document.getElementById('welcomeShavianUILabel').textContent = 'ğ‘›ğ‘¦ğ‘•ğ‘ğ‘¤ğ‘± UI ğ‘¦ğ‘¯ Â·ğ‘–ğ‘±ğ‘ğ‘¾ğ‘¯';
                document.getElementById('welcomeStartButton').textContent = 'ğ‘•ğ‘‘ğ‘¸ğ‘‘';
            } else {
                document.getElementById('welcomeTitle').textContent = 'Welcome to Shaw Type!';
                document.getElementById('welcomeSubtitle').textContent = 'Choose your preferences to get started:';
                document.getElementById('welcomeDialectLabel').textContent = 'Choose spelling';
                document.getElementById('welcomeDialectBritish').textContent = 'British';
                document.getElementById('welcomeDialectAmerican').textContent = 'American';
                document.getElementById('welcomeLayoutLabel').textContent = 'Keyboard Layout';
                document.getElementById('welcomeLigatureLabel').textContent = 'Automatic ligatures (ğ‘©+ğ‘®â†’ğ‘¼, ğ‘˜+ğ‘µâ†’ğ‘¿)';
                document.getElementById('welcomeShavianUILabel').textContent = 'Display UI in Shavian';
                document.getElementById('welcomeStartButton').textContent = 'Start';
            }
        }

        // Splash screen functions
        const APP_VERSION = '2.0.0';

        // Parse version string into comparable parts
        function parseVersion(versionStr) {
            const parts = versionStr.split('.').map(p => parseInt(p, 10));
            return {
                major: parts[0] || 0,
                minor: parts[1] || 0,
                patch: parts[2] || 0
            };
        }

        // Compare two versions: returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal
        function compareVersions(v1, v2) {
            const ver1 = parseVersion(v1);
            const ver2 = parseVersion(v2);

            if (ver1.major !== ver2.major) return ver1.major > ver2.major ? 1 : -1;
            if (ver1.minor !== ver2.minor) return ver1.minor > ver2.minor ? 1 : -1;
            if (ver1.patch !== ver2.patch) return ver1.patch > ver2.patch ? 1 : -1;
            return 0;
        }

        function closeSplashModal() {
            const dontShow = document.getElementById('dontShowSplash').checked;

            if (dontShow) {
                // Store the current version so we don't show splash again for this version
                localStorage.setItem('lastSeenVersion', APP_VERSION);
            }
            document.getElementById('splashModal').classList.remove('show');

            // After closing splash, show setup dialog for first-time users
            showSetupIfNeeded();
        }

        async function showSplashIfNeeded() {
            const lastSeenVersion = localStorage.getItem('lastSeenVersion');

            // Show splash if:
            // 1. First time user (no lastSeenVersion), OR
            // 2. Current version is newer than last seen version
            const shouldShowSplash = !lastSeenVersion || compareVersions(APP_VERSION, lastSeenVersion) > 0;

            if (shouldShowSplash) {
                document.getElementById('splashModal').classList.add('show');

                // Load content based on current language
                const lang = useShavianUI ? 'shavian' : 'latin';
                const filename = `whats_new_${lang}.html`;
                const contentEl = document.getElementById('splashContent');

                try {
                    const response = await fetch(filename);
                    if (response.ok) {
                        const html = await response.text();
                        contentEl.innerHTML = html;
                    } else {
                        contentEl.innerHTML = '<p>Content not found.</p>';
                    }
                } catch (error) {
                    contentEl.innerHTML = '<p>Error loading content.</p>';
                    console.error('Error loading splash content:', error);
                }

                // Set focus on Continue button
                setTimeout(() => {
                    document.getElementById('splashContinueBtn').focus();
                }, 100);
            }
        }

        // First-time setup dialog functions
        function closeSetupModal() {
            document.getElementById('setupModal').classList.remove('show');
            currentMode = 'play';
            localStorage.setItem('currentMode', currentMode);
        }

        function showSetupIfNeeded() {
            const hasKeyboard = localStorage.getItem('keyboardLayout');
            if (!hasKeyboard) {
                // First-time user - sync setup modal with defaults
                const dialectRadio = document.querySelector(`input[name="dialectSetup"][value="${currentDialect}"]`);
                if (dialectRadio) dialectRadio.checked = true;
                document.getElementById('layoutSelectSetup').value = currentLayout;

                document.getElementById('setupModal').classList.add('show');
                return true;
            }
            return false;
        }

        // Settings functions
        function pauseTimer() {
            if (startTime !== null && pauseStartTime === null) {
                pauseStartTime = Date.now();
            }
        }

        function resumeTimer() {
            if (pauseStartTime !== null) {
                totalPausedTime += Date.now() - pauseStartTime;
                pauseStartTime = null;
            }
        }

        function openSettings() {
            // Pause timer if in play mode
            if (currentMode === 'play') {
                pauseTimer();
            }

            // Sync settings with current state
            const dialectRadio = document.querySelector(`input[name="dialectSettings"][value="${currentDialect}"]`);
            if (dialectRadio) dialectRadio.checked = true;

            document.getElementById('layoutSelectSettings').value = currentLayout;
            document.getElementById('ligatureToggleSettings').checked = useLigatures;


            // Show/hide ligature option based on current layout
            const supportsLigatures = currentLayout === 'imperial' ||
                                     currentLayout === 'igc' ||
                                     currentLayout === 'qwerty' ||
                                     currentLayout === 'jafl';
            document.getElementById('ligatureSettingOption').style.display =
                supportsLigatures ? 'block' : 'none';

            document.getElementById('settingsModal').classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');

            // Resume timer if in play mode
            if (currentMode === 'play') {
                resumeTimer();
            }
        }

        function openHighScores() {
            // Pause timer if in play mode
            if (currentMode === 'play') {
                pauseTimer();
            }
            // Get current translations
            const t = getCurrentTranslations();

            // Populate high scores content
            let html = '';

            if (Object.keys(highScores).length === 0) {
                html = `<p style="text-align: center; color: #999;">${t.noScoresYet}</p>`;
            } else {
                html = '<div style="display: flex; flex-direction: column; gap: 20px;">';

                // Show high scores for each level count
                ['3', '6', '10'].forEach(levelCountKey => {
                    if (highScores[levelCountKey]) {
                        const scores = highScores[levelCountKey];
                        const totalWords = parseInt(levelCountKey) * 5;

                        html += `<div style="border: 2px solid #e0e0e0; border-radius: 8px; padding: 15px;">`;
                        html += `<h3 style="margin-top: 0; color: #667eea;">${levelCountKey} ${t.levels} (${totalWords} ${t.words})</h3>`;

                        if (scores.time !== null) {
                            const minutes = Math.floor(scores.time / 60);
                            const seconds = Math.floor(scores.time % 60);
                            const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            html += `<div style="margin: 8px 0;"><strong>${t.bestTime}</strong> ${timeFormatted}</div>`;
                        } else {
                            html += `<div style="margin: 8px 0;"><strong>${t.bestTime}</strong> N/A</div>`;
                        }

                        if (scores.wpm !== null) {
                            html += `<div style="margin: 8px 0;"><strong>${t.bestWPM}</strong> ${scores.wpm.toFixed(1)}</div>`;
                        } else {
                            html += `<div style="margin: 8px 0;"><strong>${t.bestWPM}</strong> N/A</div>`;
                        }

                        if (scores.accuracy !== null) {
                            html += `<div style="margin: 8px 0;"><strong>${t.bestAccuracy}</strong> ${scores.accuracy.toFixed(1)}%</div>`;
                        } else {
                            html += `<div style="margin: 8px 0;"><strong>${t.bestAccuracy}</strong> N/A</div>`;
                        }

                        html += `</div>`;
                    }
                });

                html += '</div>';
            }

            document.getElementById('highScoresContent').innerHTML = html;
            document.getElementById('highScoresModal').classList.add('show');
        }

        function closeHighScores() {
            document.getElementById('highScoresModal').classList.remove('show');

            // Resume timer if in play mode
            if (currentMode === 'play') {
                resumeTimer();
            }
        }

        // Lesson selector functions
        function openLessonSelector() {
            // Get current translations
            const t = getCurrentTranslations();

            // Get the appropriate word list for current settings
            const learnWords = getLearnWords();

            const lessonList = document.getElementById('lessonList');
            lessonList.innerHTML = '';

            // Dynamically determine max level from actual data
            const maxLevel = learnWords ? Object.keys(learnWords).length : 6;

            // Add lesson options
            for (let i = 1; i <= maxLevel; i++) {
                const levelData = learnWords[i];

                if (levelData) {
                    const lessonBtn = document.createElement('div');
                    lessonBtn.className = 'lesson-option';
                    const translatedName = translateLessonName(levelData.name);
                    const translatedDescription = translateLessonDescription(levelData.description);
                    lessonBtn.innerHTML = `
                        <strong>${t.lessonPrefix} ${i}: ${translatedName}</strong>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #888;">${translatedDescription}</p>
                    `;
                    lessonBtn.onclick = () => selectLesson(i);
                    if (selectedLevel == i) {
                        lessonBtn.style.background = '#f0f0ff';
                    }
                    lessonList.appendChild(lessonBtn);
                }
            }

            document.getElementById('lessonModal').classList.add('show');
        }

        function selectLesson(level) {
            selectedLevel = level;
            closeLessonModal();

            // Show game content
            showGameContent();

            // Reset session stats
            wordsCompleted = 0;
            totalLettersTyped = 0;
            correctLetters = 0;
            levelStats = [];

            updateStats();

            // Start the selected lesson
            const t = getCurrentTranslations();

            // Set instructions in subtitle
            document.getElementById('mainSubtitle').textContent = t.gameInstructions;

            const levelData = getLearnLessonData(parseInt(level));
            if (levelData) {
                currentLevelNumber = parseInt(level);
                startLevel(levelData.wordPool, levelData.wordCount, 'lesson', levelData.title, t.lesson_label, showLessonCompletionDialog);
            }
        }

        function closeLessonModal() {
            document.getElementById('lessonModal').classList.remove('show');
        }

        function toggleShavianUI() {
            useShavianUI = document.getElementById('shavianUIToggle').checked;
            localStorage.setItem('useShavianUI', useShavianUI);
            updateUILanguage();
        }

        function updateUILanguage() {
            const t = getCurrentTranslations();

            if (!t || Object.keys(t).length === 0) {
                console.error('Translations not loaded yet!');
                return;
            }

            updateUIWithTranslations(t);
        }

        function updateUIWithTranslations(t) {

            // Update title
            document.getElementById('mainTitle').textContent = t.title;

            // Update subtitle based on current state
            const subtitle = document.getElementById('mainSubtitle');
            const homeScreen = document.getElementById('homeScreen');
            if (!homeScreen.classList.contains('hidden')) {
                // On home screen, show default subtitle
                subtitle.textContent = t.subtitle;
            } else {
                // In game, subtitle is managed by game logic
                updateSubtitleForGame();
            }

            // Update home screen buttons
            document.getElementById('homePlayBtn').textContent = t.play;
            document.getElementById('homePracticeBtn').textContent = t.practice;
            document.getElementById('homeSettingsBtn').textContent = t.settings;

            // Update stats labels
            document.querySelector('.stat-label').textContent =
                currentMode === 'learn' ? t.lesson_label : t.level_label;
            document.querySelectorAll('.stat-label')[1].textContent = t.words;
            document.querySelectorAll('.stat-label')[2].textContent = t.accuracy;

            // Update completion modal
            document.querySelector('#completionModal h2').textContent = t.congratulations;
            document.querySelector('#completionModal p').textContent = t.completed30;
            document.querySelectorAll('.stat-row')[0].childNodes[0].textContent = t.wpm + ' ';
            document.querySelectorAll('.stat-row')[1].childNodes[0].textContent = t.lettersPerMin + ' ';
            document.querySelectorAll('.stat-row')[2].childNodes[0].textContent = t.accuracy_final + ' ';
            document.querySelectorAll('.stat-row')[4].childNodes[0].textContent = t.levelReached + ' ';
            document.querySelector('#completionModal button').textContent = t.practiceAgain;

            // Update high scores modal
            document.getElementById('highScoresTitle').textContent = t.scoresTitle;
            document.getElementById('highScoresCloseBtn').textContent = t.close;

            // Update settings modal
            document.querySelector('#settingsModal h2').textContent = t.settingsTitle;
            document.querySelector('#shavianUIToggle + span').textContent = t.displayShavian;

            // Update settings labels
            document.getElementById('settingsKeyboardLayoutLabel').textContent = t.keyboardLayout;
            document.getElementById('settingsLevelCountLabel').textContent = t.levelCountLabel;
            document.querySelector('#ligatureToggleSettings + span').textContent = t.ligatures;

            // Update level count options
            const levelCountSelect = document.getElementById('levelCountSelect');
            levelCountSelect.options[0].textContent = t.levelCount3;
            levelCountSelect.options[1].textContent = t.levelCount6;
            levelCountSelect.options[2].textContent = t.levelCount10;

            // Update lesson modal
            document.getElementById('lessonModalTitle').textContent = t.lessonModalTitle;
            document.getElementById('lessonModalSubtitle').textContent = t.lessonModalSubtitle;

            // Update burger menu items
            document.getElementById('menuAbout').textContent = t.menuAbout;
            document.getElementById('menuKeyboards').textContent = t.menuKeyboards;
            document.getElementById('menuResources').textContent = t.menuResources;
            document.getElementById('menuHighScores').textContent = t.scoresTitle;
            document.getElementById('menuSettings').textContent = t.menuSettings;

            // Update settings dialog labels
            document.getElementById('settingsDialectLabel').textContent = t.dialectLabel;
            document.getElementById('settingsDialectBritish').textContent = t.dialectBritish;
            document.getElementById('settingsDialectAmerican').textContent = t.dialectAmerican;
            document.getElementById('settingsVirtualKeyboard').textContent = t.showVirtualKeyboard;

            // Update splash screen
            document.getElementById('splashTitle').textContent = t.splashTitle;
            document.getElementById('splashContinueBtn').textContent = t.continueButton;
            document.getElementById('splashDontShowAgain').textContent = t.dontShowAgain;

            // Reload splash content in current language if modal is showing
            const splashModal = document.getElementById('splashModal');
            if (splashModal.classList.contains('show')) {
                const filename = `whats_new_${lang}.html`;
                const contentEl = document.getElementById('splashContent');
                fetch(filename)
                    .then(response => response.ok ? response.text() : '<p>Content not found.</p>')
                    .then(html => contentEl.innerHTML = html)
                    .catch(error => {
                        contentEl.innerHTML = '<p>Error loading content.</p>';
                        console.error('Error loading splash content:', error);
                    });
            }

            // Update setup dialog
            document.getElementById('setupTitle').textContent = t.setupTitle;
            document.getElementById('setupSubtitle').textContent = t.setupSubtitle;
            document.getElementById('setupKeyboardLayoutLabel').textContent = t.keyboardLayout;
            document.getElementById('setupDialectLabel').textContent = t.dialectLabel;
            document.getElementById('setupDialectBritish').textContent = t.dialectBritish;
            document.getElementById('setupDialectAmerican').textContent = t.dialectAmerican;
            document.getElementById('setupNote').textContent = t.setupNote;
            document.getElementById('setupStartBtn').textContent = t.startPracticing;

            // Update layout select options
            updateLayoutSelectOptions();
        }

        function updateLayoutSelectOptions() {
            const t = getCurrentTranslations();

            // Update both layout selects (settings and welcome)
            const selects = [
                document.getElementById('layoutSelectSettings'),
                document.getElementById('layoutSelectWelcome')
            ];

            selects.forEach(select => {
                if (select) {
                    const currentValue = select.value;
                    const options = select.querySelectorAll('option');

                    options.forEach(option => {
                        const value = option.value;
                        switch(value) {
                            case 'imperial':
                                option.textContent = t.layoutImperial;
                                break;
                            case 'igc':
                                option.textContent = t.layoutIGC;
                                break;
                            case 'qwerty':
                                option.textContent = t.layoutQwerty;
                                break;
                            case '2layer':
                                option.textContent = t.layout2layer;
                                break;
                            case 'jafl':
                                option.textContent = t.layoutJafl;
                                break;
                        }
                    });

                    // Restore selected value
                    select.value = currentValue;
                }
            });
        }

        // Load saved preferences
        // localStorage patch system - sorted list of patches to apply
        const PATCHES = [
            [1, function patch1_clearBestTime() {
                // Clear best time due to timer bug fix
                localStorage.removeItem('bestTime');
                debug('Patch 1: Cleared bestTime from localStorage');
            }],
            [2, function patch2_migrateToHighScores() {
                // Migrate old bestTime to new highScores structure
                const oldBestTime = localStorage.getItem('bestTime');
                if (oldBestTime !== null) {
                    // Load existing high scores or create new object
                    const highScoresJSON = localStorage.getItem('highScores');
                    const highScores = highScoresJSON ? JSON.parse(highScoresJSON) : {};
                    const timeValue = parseFloat(oldBestTime);
                    // Copy the old best time to the 6-level entry (only if not already set)
                    if (!highScores['6'] || highScores['6'].time === null) {
                        highScores['6'] = { time: timeValue, wpm: null, accuracy: null };
                    }
                    localStorage.setItem('highScores', JSON.stringify(highScores));
                    localStorage.removeItem('bestTime');
                    debug('Patch 2: Migrated bestTime to highScores[6]');
                } else {
                    debug('Patch 2: No bestTime to migrate');
                }
            }]
        ];

        function applyPatches() {
            const currentPatchLevel = parseInt(localStorage.getItem('patchLevel') || '0');
            debug(`Current patch level: ${currentPatchLevel}`);

            // Apply all patches greater than current level
            PATCHES.forEach(([patchNumber, patchFunction]) => {
                if (patchNumber > currentPatchLevel) {
                    debug(`Applying patch ${patchNumber}...`);
                    patchFunction();
                }
            });

            // Update patch level to highest patch number
            if (PATCHES.length > 0) {
                const latestPatch = PATCHES[PATCHES.length - 1][0];
                if (latestPatch > currentPatchLevel) {
                    localStorage.setItem('patchLevel', latestPatch.toString());
                    debug(`Updated patch level to ${latestPatch}`);
                }
            }
        }

        function loadPreferences() {
            // Load Shavian UI preference
            const savedShavianUI = localStorage.getItem('useShavianUI');
            if (savedShavianUI !== null) {
                useShavianUI = savedShavianUI === 'true';
                document.getElementById('shavianUIToggle').checked = useShavianUI;
            }

            // Load dialect preference
            const savedDialect = localStorage.getItem('dialect');
            if (savedDialect !== null && (savedDialect === 'gb' || savedDialect === 'us')) {
                currentDialect = savedDialect;
            }

            // Load keyboard layout
            let savedLayout = localStorage.getItem('keyboardLayout');
            // Migration: rename "new-imperial" to "igc"
            if (savedLayout === 'new-imperial') {
                savedLayout = 'igc';
                localStorage.setItem('keyboardLayout', 'igc');
            }
            if (savedLayout !== null) {
                currentLayout = savedLayout;
            }

            // Load ligature preference
            const savedLigatures = localStorage.getItem('useLigatures');
            if (savedLigatures !== null) {
                useLigatures = savedLigatures === 'true';
            }

            // Load current mode (just restore the value, no UI updates needed on home screen)
            const savedMode = localStorage.getItem('currentMode');
            if (savedMode !== null && (savedMode === 'learn' || savedMode === 'play')) {
                currentMode = savedMode;
            }

            // Load best time (legacy - now migrated to highScores)
            const savedBestTime = localStorage.getItem('bestTime');
            if (savedBestTime !== null) {
                bestTime = parseFloat(savedBestTime);
            }

            // Load high scores
            const savedHighScores = localStorage.getItem('highScores');
            if (savedHighScores !== null) {
                try {
                    highScores = JSON.parse(savedHighScores);
                } catch (e) {
                    console.error('Failed to parse highScores:', e);
                    highScores = {};
                }
            }

            // Load level count preference
            const savedLevelCount = localStorage.getItem('levelCount');
            if (savedLevelCount !== null) {
                const count = parseInt(savedLevelCount);
                if ([3, 6, 10].includes(count)) {
                    levelCount = count;
                    document.getElementById('levelCountSelect').value = count.toString();
                }
            }

            // Load debug mode preference
            const savedDebugMode = localStorage.getItem('debugMode');
            if (savedDebugMode !== null) {
                debugMode = savedDebugMode === 'true';
            }

            // Load virtual keyboard preference
            const savedShowKeyboard = localStorage.getItem('showVirtualKeyboard');
            if (savedShowKeyboard === 'true') {
                document.getElementById('virtualKeyboardToggle').checked = true;
            }
        }

        // Keyboard support for dialogs
        document.addEventListener('keydown', (e) => {
            // Check which modal is open
            const completionModal = document.getElementById('completionModal');
            const settingsModal = document.getElementById('settingsModal');
            const lessonModal = document.getElementById('lessonModal');
            const contentModal = document.getElementById('contentModal');

            const isModalOpen = completionModal.classList.contains('show') ||
                               settingsModal.classList.contains('show') ||
                               lessonModal.classList.contains('show') ||
                               contentModal.classList.contains('show');

            if (!isModalOpen) return;

            // Handle Escape key - close/back action
            if (e.key === 'Escape') {
                e.preventDefault();
                if (completionModal.classList.contains('show')) {
                    goHome();
                } else if (settingsModal.classList.contains('show')) {
                    closeSettings();
                } else if (lessonModal.classList.contains('show')) {
                    closeLessonModal();
                } else if (contentModal.classList.contains('show')) {
                    closeContentModal();
                }
                return;
            }

            // Handle Enter key - activate first/default button
            if (e.key === 'Enter') {
                e.preventDefault();
                if (completionModal.classList.contains('show')) {
                    const firstButton = completionModal.querySelector('button');
                    if (firstButton) firstButton.click();
                } else if (lessonModal.classList.contains('show')) {
                    // In lesson selector, no default button action
                }
                return;
            }

            // Handle Tab key - cycle between buttons
            if (e.key === 'Tab') {
                const activeModal = completionModal.classList.contains('show') ? completionModal :
                                  settingsModal.classList.contains('show') ? settingsModal :
                                  lessonModal.classList.contains('show') ? lessonModal :
                                  contentModal;

                const buttons = Array.from(activeModal.querySelectorAll('button'));
                if (buttons.length > 1) {
                    e.preventDefault();
                    const currentFocus = document.activeElement;
                    const currentIndex = buttons.indexOf(currentFocus);

                    let nextIndex;
                    if (e.shiftKey) {
                        // Shift+Tab - go backwards
                        nextIndex = currentIndex <= 0 ? buttons.length - 1 : currentIndex - 1;
                    } else {
                        // Tab - go forwards
                        nextIndex = currentIndex >= buttons.length - 1 ? 0 : currentIndex + 1;
                    }

                    buttons[nextIndex].focus();
                }
            }
        });

        // Start the app
        applyPatches();
        loadPreferences();

        // Translations are already loaded synchronously in <head>
        // Initialize the app
        init();
        updateUILanguage();
    </script>
    <script src="virtual-keyboard.js"></script>
</body>
</html>
